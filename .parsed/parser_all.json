{
  "gitRepository": {
    "name": "parser-utility",
    "path": "/home/joshuasalcedo-io/parser-utility",
    "currentBranch": "main",
    "remoteUrl": "git@github.com:joshuasalcedo-io/parser-utility.git",
    "branches": [
      {
        "name": "main",
        "current": true,
        "remote": false,
        "commitId": "77832614c9c273d1a586e2514a8ae75c5ff94616",
        "merged": true
      },
      {
        "name": "main",
        "current": false,
        "remote": true,
        "remoteName": "remotes/origin",
        "commitId": "e00c18ddd200bfe556a65ad1915046cf59139957",
        "merged": false
      }
    ],
    "tags": [],
    "hasUncommittedChanges": true,
    "commitCount": 11,
    "statistics": {
      "commitsPerDayOfWeek": {
        "Monday": 0,
        "Thursday": 4,
        "Friday": 0,
        "Sunday": 0,
        "Wednesday": 7,
        "Tuesday": 0,
        "Saturday": 0
      },
      "totalCommits": 11,
      "commitsPerHour": {
        "0": 0,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 0,
        "5": 0,
        "6": 0,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0,
        "12": 5,
        "13": 0,
        "14": 0,
        "15": 1,
        "16": 0,
        "17": 0,
        "18": 0,
        "19": 1,
        "20": 2,
        "21": 0,
        "22": 0,
        "23": 2
      },
      "averageChangedFilesPerCommit": 15.0,
      "commitsPerMonth": {
        "June": 0,
        "October": 0,
        "December": 0,
        "May": 11,
        "September": 0,
        "March": 0,
        "July": 0,
        "January": 0,
        "February": 0,
        "April": 0,
        "August": 0,
        "November": 0
      }
    },
    "topContributors": [
      {
        "name": "joshuasalcedo-dev",
        "email": "dev@joshuasalcedo.io",
        "commitCount": 11,
        "linesAdded": 59240,
        "linesDeleted": 33200,
        "firstCommitDate": "May 7, 2025, 12:24:30 PM",
        "lastCommitDate": "May 8, 2025, 8:35:56 PM"
      }
    ],
    "creationDate": "May 8, 2025, 8:35:56 PM",
    "fileExtensionCounts": {}
  },
  "fileStatistics": {
    "pomFiles": 3,
    "totalFiles": 666,
    "javaFiles": 50,
    "htmlFiles": 102,
    "markdownFiles": 9
  },
  "pomFiles": {
    "src/test/resources/test/pom/sample-project/pom.xml": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/resources/test/pom/sample-project/pom.xml",
      "groupId": "com.example",
      "artifactId": "multi-module-parent",
      "version": "1.0.0",
      "dependencies": []
    },
    "pom.xml": {
      "path": "/home/joshuasalcedo-io/parser-utility/pom.xml",
      "groupId": "io.joshuasalcedo",
      "name": "Java Structure Analyzer",
      "description": "A Java-based tool for analyzing code repositories",
      "artifactId": "parser-utility",
      "version": "1.0.0",
      "dependencies": [
        {
          "groupId": "org.junit.jupiter",
          "scope": "test",
          "artifactId": "junit-jupiter",
          "version": "5.10.2"
        },
        {
          "groupId": "com.google.code.gson",
          "artifactId": "gson",
          "version": "2.13.1"
        },
        {
          "groupId": "commons-io",
          "artifactId": "commons-io",
          "version": "2.19.0"
        },
        {
          "groupId": "org.apache.maven",
          "artifactId": "maven-model",
          "version": "4.0.0-rc-3"
        },
        {
          "groupId": "org.apache.maven",
          "artifactId": "maven-api-model",
          "version": "4.0.0-rc-3"
        },
        {
          "groupId": "org.eclipse.jgit",
          "artifactId": "org.eclipse.jgit",
          "version": "7.2.0.202503040940-r"
        },
        {
          "groupId": "org.commonmark",
          "artifactId": "commonmark",
          "version": "0.24.0"
        },
        {
          "groupId": "org.projectlombok",
          "scope": "provided",
          "artifactId": "lombok",
          "version": "1.18.38"
        },
        {
          "groupId": "org.commonmark",
          "artifactId": "commonmark-ext-autolink",
          "version": "0.24.0"
        },
        {
          "groupId": "org.commonmark",
          "artifactId": "commonmark-ext-gfm-tables",
          "version": "0.24.0"
        },
        {
          "groupId": "org.jsoup",
          "artifactId": "jsoup",
          "version": "1.20.1"
        },
        {
          "groupId": "org.commonmark",
          "artifactId": "commonmark-ext-gfm-strikethrough",
          "version": "0.24.0"
        },
        {
          "groupId": "org.commonmark",
          "artifactId": "commonmark-ext-heading-anchor",
          "version": "0.24.0"
        },
        {
          "groupId": "org.commonmark",
          "artifactId": "commonmark-ext-yaml-front-matter",
          "version": "0.24.0"
        },
        {
          "groupId": "org.commonmark",
          "artifactId": "commonmark-ext-ins",
          "version": "0.24.0"
        },
        {
          "groupId": "io.joshuasalcedo",
          "artifactId": "boot-utility-starter",
          "version": "1.0-SNAPSHOT"
        }
      ]
    },
    "target/test-classes/test/pom/sample-project/pom.xml": {
      "path": "/home/joshuasalcedo-io/parser-utility/target/test-classes/test/pom/sample-project/pom.xml",
      "groupId": "com.example",
      "artifactId": "multi-module-parent",
      "version": "1.0.0",
      "dependencies": []
    }
  },
  "javaFiles": {
    "src/test/java/io/joshuasalcedo/parsers/PomParserTest.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/java/io/joshuasalcedo/parsers/PomParserTest.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "setUp",
          "parameters": [],
          "body": "{\r\n        // Set up the test POM file locations\r\n        singlePomFile \u003d new File(\"src/test/resources/test/pom/single-pom/sample-pom.xml\");\r\n        multiModulePomFile \u003d new File(\"src/test/resources/test/pom/multi-module-pom.xml\");\r\n\r\n        // Ensure the test files exist\r\n        assertTrue(singlePomFile.exists(), \"Single module test POM file does not exist at: \"\r\n                + singlePomFile.getAbsolutePath());\r\n        assertTrue(multiModulePomFile.exists(), \"Multi-module test POM file does not exist at: \"\r\n                + multiModulePomFile.getAbsolutePath());\r\n\r\n        // Set up output file\r\n        outputFile \u003d new File(\"target/pom-parser-output.txt\");\r\n        outputFile.getParentFile().mkdirs();\r\n    }",
          "comments": [
            "Set up the test POM file locations"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            if (!singlePomFile.exists()) {\r\n                System.out.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                writer.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Parse the single module POM file\r\n                Model model \u003d PomParser.parsePom(singlePomFile);\r\n\r\n                // Test basic parsing\r\n                assertNotNull(model, \"Model should not be null\");\r\n\r\n                // Print basic model information\r\n                System.out.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Group ID: \" + model.getGroupId());\r\n                System.out.println(\"Artifact ID: \" + model.getArtifactId());\r\n                System.out.println(\"Version: \" + model.getVersion());\r\n                System.out.println(\"Packaging: \" + model.getPackaging());\r\n                System.out.println(\"Name: \" + model.getName());\r\n                System.out.println(\"Description: \" + model.getDescription());\r\n\r\n                writer.println(\"Group ID: \" + model.getGroupId());\r\n                writer.println(\"Artifact ID: \" + model.getArtifactId());\r\n                writer.println(\"Version: \" + model.getVersion());\r\n                writer.println(\"Packaging: \" + model.getPackaging());\r\n                writer.println(\"Name: \" + model.getName());\r\n                writer.println(\"Description: \" + model.getDescription());\r\n\r\n                // Test for parent\r\n                Parent parent \u003d model.getParent();\r\n                if (parent !\u003d null) {\r\n                    System.out.println(\"\\nParent:\");\r\n                    System.out.println(\"Group ID: \" + parent.getGroupId());\r\n                    System.out.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    System.out.println(\"Version: \" + parent.getVersion());\r\n\r\n                    writer.println(\"\\nParent:\");\r\n                    writer.println(\"Group ID: \" + parent.getGroupId());\r\n                    writer.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    writer.println(\"Version: \" + parent.getVersion());\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"Error parsing POM: \" + e.getMessage());\r\n                writer.println(\"Error parsing POM: \" + e.getMessage());\r\n                fail(\"Failed to parse POM file: \" + e.getMessage());\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while writing to output file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": [
            "Set up the test POM file locations"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            if (!singlePomFile.exists()) {\r\n                System.out.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                writer.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Parse the single module POM file\r\n                Model model \u003d PomParser.parsePom(singlePomFile);\r\n\r\n                // Test basic parsing\r\n                assertNotNull(model, \"Model should not be null\");\r\n\r\n                // Print basic model information\r\n                System.out.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Group ID: \" + model.getGroupId());\r\n                System.out.println(\"Artifact ID: \" + model.getArtifactId());\r\n                System.out.println(\"Version: \" + model.getVersion());\r\n                System.out.println(\"Packaging: \" + model.getPackaging());\r\n                System.out.println(\"Name: \" + model.getName());\r\n                System.out.println(\"Description: \" + model.getDescription());\r\n\r\n                writer.println(\"Group ID: \" + model.getGroupId());\r\n                writer.println(\"Artifact ID: \" + model.getArtifactId());\r\n                writer.println(\"Version: \" + model.getVersion());\r\n                writer.println(\"Packaging: \" + model.getPackaging());\r\n                writer.println(\"Name: \" + model.getName());\r\n                writer.println(\"Description: \" + model.getDescription());\r\n\r\n                // Test for parent\r\n                Parent parent \u003d model.getParent();\r\n                if (parent !\u003d null) {\r\n                    System.out.println(\"\\nParent:\");\r\n                    System.out.println(\"Group ID: \" + parent.getGroupId());\r\n                    System.out.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    System.out.println(\"Version: \" + parent.getVersion());\r\n\r\n                    writer.println(\"\\nParent:\");\r\n                    writer.println(\"Group ID: \" + parent.getGroupId());\r\n                    writer.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    writer.println(\"Version: \" + parent.getVersion());\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"Error parsing POM: \" + e.getMessage());\r\n                writer.println(\"Error parsing POM: \" + e.getMessage());\r\n                fail(\"Failed to parse POM file: \" + e.getMessage());\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while writing to output file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": [
            "Set up the test POM file locations",
            "Ensure the test files e"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "exist",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            if (!singlePomFile.exists()) {\r\n                System.out.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                writer.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Parse the single module POM file\r\n                Model model \u003d PomParser.parsePom(singlePomFile);\r\n\r\n                // Test basic parsing\r\n                assertNotNull(model, \"Model should not be null\");\r\n\r\n                // Print basic model information\r\n                System.out.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Group ID: \" + model.getGroupId());\r\n                System.out.println(\"Artifact ID: \" + model.getArtifactId());\r\n                System.out.println(\"Version: \" + model.getVersion());\r\n                System.out.println(\"Packaging: \" + model.getPackaging());\r\n                System.out.println(\"Name: \" + model.getName());\r\n                System.out.println(\"Description: \" + model.getDescription());\r\n\r\n                writer.println(\"Group ID: \" + model.getGroupId());\r\n                writer.println(\"Artifact ID: \" + model.getArtifactId());\r\n                writer.println(\"Version: \" + model.getVersion());\r\n                writer.println(\"Packaging: \" + model.getPackaging());\r\n                writer.println(\"Name: \" + model.getName());\r\n                writer.println(\"Description: \" + model.getDescription());\r\n\r\n                // Test for parent\r\n                Parent parent \u003d model.getParent();\r\n                if (parent !\u003d null) {\r\n                    System.out.println(\"\\nParent:\");\r\n                    System.out.println(\"Group ID: \" + parent.getGroupId());\r\n                    System.out.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    System.out.println(\"Version: \" + parent.getVersion());\r\n\r\n                    writer.println(\"\\nParent:\");\r\n                    writer.println(\"Group ID: \" + parent.getGroupId());\r\n                    writer.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    writer.println(\"Version: \" + parent.getVersion());\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"Error parsing POM: \" + e.getMessage());\r\n                writer.println(\"Error parsing POM: \" + e.getMessage());\r\n                fail(\"Failed to parse POM file: \" + e.getMessage());\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while writing to output file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": [
            "Ensure the test files exist"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            if (!singlePomFile.exists()) {\r\n                System.out.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                writer.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Parse the single module POM file\r\n                Model model \u003d PomParser.parsePom(singlePomFile);\r\n\r\n                // Test basic parsing\r\n                assertNotNull(model, \"Model should not be null\");\r\n\r\n                // Print basic model information\r\n                System.out.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Group ID: \" + model.getGroupId());\r\n                System.out.println(\"Artifact ID: \" + model.getArtifactId());\r\n                System.out.println(\"Version: \" + model.getVersion());\r\n                System.out.println(\"Packaging: \" + model.getPackaging());\r\n                System.out.println(\"Name: \" + model.getName());\r\n                System.out.println(\"Description: \" + model.getDescription());\r\n\r\n                writer.println(\"Group ID: \" + model.getGroupId());\r\n                writer.println(\"Artifact ID: \" + model.getArtifactId());\r\n                writer.println(\"Version: \" + model.getVersion());\r\n                writer.println(\"Packaging: \" + model.getPackaging());\r\n                writer.println(\"Name: \" + model.getName());\r\n                writer.println(\"Description: \" + model.getDescription());\r\n\r\n                // Test for parent\r\n                Parent parent \u003d model.getParent();\r\n                if (parent !\u003d null) {\r\n                    System.out.println(\"\\nParent:\");\r\n                    System.out.println(\"Group ID: \" + parent.getGroupId());\r\n                    System.out.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    System.out.println(\"Version: \" + parent.getVersion());\r\n\r\n                    writer.println(\"\\nParent:\");\r\n                    writer.println(\"Group ID: \" + parent.getGroupId());\r\n                    writer.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    writer.println(\"Version: \" + parent.getVersion());\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"Error parsing POM: \" + e.getMessage());\r\n                writer.println(\"Error parsing POM: \" + e.getMessage());\r\n                fail(\"Failed to parse POM file: \" + e.getMessage());\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while writing to output file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": [
            "Set up output file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParsePom",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            if (!singlePomFile.exists()) {\r\n                System.out.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                writer.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Parse the single module POM file\r\n                Model model \u003d PomParser.parsePom(singlePomFile);\r\n\r\n                // Test basic parsing\r\n                assertNotNull(model, \"Model should not be null\");\r\n\r\n                // Print basic model information\r\n                System.out.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Group ID: \" + model.getGroupId());\r\n                System.out.println(\"Artifact ID: \" + model.getArtifactId());\r\n                System.out.println(\"Version: \" + model.getVersion());\r\n                System.out.println(\"Packaging: \" + model.getPackaging());\r\n                System.out.println(\"Name: \" + model.getName());\r\n                System.out.println(\"Description: \" + model.getDescription());\r\n\r\n                writer.println(\"Group ID: \" + model.getGroupId());\r\n                writer.println(\"Artifact ID: \" + model.getArtifactId());\r\n                writer.println(\"Version: \" + model.getVersion());\r\n                writer.println(\"Packaging: \" + model.getPackaging());\r\n                writer.println(\"Name: \" + model.getName());\r\n                writer.println(\"Description: \" + model.getDescription());\r\n\r\n                // Test for parent\r\n                Parent parent \u003d model.getParent();\r\n                if (parent !\u003d null) {\r\n                    System.out.println(\"\\nParent:\");\r\n                    System.out.println(\"Group ID: \" + parent.getGroupId());\r\n                    System.out.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    System.out.println(\"Version: \" + parent.getVersion());\r\n\r\n                    writer.println(\"\\nParent:\");\r\n                    writer.println(\"Group ID: \" + parent.getGroupId());\r\n                    writer.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    writer.println(\"Version: \" + parent.getVersion());\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"Error parsing POM: \" + e.getMessage());\r\n                writer.println(\"Error parsing POM: \" + e.getMessage());\r\n                fail(\"Failed to parse POM file: \" + e.getMessage());\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while writing to output file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": [
            "Set up output file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            if (!singlePomFile.exists()) {\r\n                System.out.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                writer.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Parse the single module POM file\r\n                Model model \u003d PomParser.parsePom(singlePomFile);\r\n\r\n                // Test basic parsing\r\n                assertNotNull(model, \"Model should not be null\");\r\n\r\n                // Print basic model information\r\n                System.out.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Group ID: \" + model.getGroupId());\r\n                System.out.println(\"Artifact ID: \" + model.getArtifactId());\r\n                System.out.println(\"Version: \" + model.getVersion());\r\n                System.out.println(\"Packaging: \" + model.getPackaging());\r\n                System.out.println(\"Name: \" + model.getName());\r\n                System.out.println(\"Description: \" + model.getDescription());\r\n\r\n                writer.println(\"Group ID: \" + model.getGroupId());\r\n                writer.println(\"Artifact ID: \" + model.getArtifactId());\r\n                writer.println(\"Version: \" + model.getVersion());\r\n                writer.println(\"Packaging: \" + model.getPackaging());\r\n                writer.println(\"Name: \" + model.getName());\r\n                writer.println(\"Description: \" + model.getDescription());\r\n\r\n                // Test for parent\r\n                Parent parent \u003d model.getParent();\r\n                if (parent !\u003d null) {\r\n                    System.out.println(\"\\nParent:\");\r\n                    System.out.println(\"Group ID: \" + parent.getGroupId());\r\n                    System.out.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    System.out.println(\"Version: \" + parent.getVersion());\r\n\r\n                    writer.println(\"\\nParent:\");\r\n                    writer.println(\"Group ID: \" + parent.getGroupId());\r\n                    writer.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    writer.println(\"Version: \" + parent.getVersion());\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"Error parsing POM: \" + e.getMessage());\r\n                writer.println(\"Error parsing POM: \" + e.getMessage());\r\n                fail(\"Failed to parse POM file: \" + e.getMessage());\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parsing",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Model",
              "name": "should"
            }
          ],
          "body": "{\r\n                    System.out.println(\"\\nParent:\");\r\n                    System.out.println(\"Group ID: \" + parent.getGroupId());\r\n                    System.out.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    System.out.println(\"Version: \" + parent.getVersion());\r\n\r\n                    writer.println(\"\\nParent:\");\r\n                    writer.println(\"Group ID: \" + parent.getGroupId());\r\n                    writer.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    writer.println(\"Version: \" + parent.getVersion());\r\n                }",
          "comments": [
            "Parse the single module POM file",
            "Test basic parsing",
            "Pr"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testExtractCoordinates",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            // Extract coordinates from the single module POM file\r\n            PomCoordinates coordinates \u003d PomParser.extractCoordinates(singlePomFile);\r\n\r\n            // Test coordinate extraction\r\n            assertNotNull(coordinates, \"Coordinates should not be null\");\r\n\r\n            // Print coordinates\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Group ID: \" + coordinates.getGroupId());\r\n            System.out.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            System.out.println(\"Version: \" + coordinates.getVersion());\r\n\r\n            writer.println(\"Group ID: \" + coordinates.getGroupId());\r\n            writer.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            writer.println(\"Version: \" + coordinates.getVersion());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            // Extract coordinates from the single module POM file\r\n            PomCoordinates coordinates \u003d PomParser.extractCoordinates(singlePomFile);\r\n\r\n            // Test coordinate extraction\r\n            assertNotNull(coordinates, \"Coordinates should not be null\");\r\n\r\n            // Print coordinates\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Group ID: \" + coordinates.getGroupId());\r\n            System.out.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            System.out.println(\"Version: \" + coordinates.getVersion());\r\n\r\n            writer.println(\"Group ID: \" + coordinates.getGroupId());\r\n            writer.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            writer.println(\"Version: \" + coordinates.getVersion());\r\n        }",
          "comments": [
            "Extract coordinates from the s"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "extraction",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Coordinates",
              "name": "should"
            }
          ],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            // Extract dependencies from the single module POM file\r\n            List\u003cDependency\u003e dependencies \u003d PomParser.extractDependencies(singlePomFile);\r\n\r\n            // Test dependency extraction\r\n            assertNotNull(dependencies, \"Dependencies list should not be null\");\r\n\r\n            // Print dependencies\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM DEPENDENCIES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM DEPENDENCIES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Found \" + dependencies.size() + \" dependencies:\");\r\n            writer.println(\"Found \" + dependencies.size() + \" dependencies:\");\r\n\r\n            for (Dependency dependency : dependencies) {\r\n                String scope \u003d dependency.getScope() !\u003d null ? dependency.getScope() : \"compile\";\r\n\r\n                System.out.println(dependency.getGroupId() + \":\" +\r\n                        dependency.getArtifactId() + \":\" +\r\n                        dependency.getVersion() + \" (Scope: \" + scope + \")\");\r\n\r\n                writer.println(dependency.getGroupId() + \":\" +\r\n                        dependency.getArtifactId() + \":\" +\r\n                        dependency.getVersion() + \" (Scope: \" + scope + \")\");\r\n            }\r\n        }\r\n    }",
          "comments": [
            "Extract coordinates from the single module POM file",
            "Test coordinate extraction"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testExtractDependencies",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            // Extract dependencies from the single module POM file\r\n            List\u003cDependency\u003e dependencies \u003d PomParser.extractDependencies(singlePomFile);\r\n\r\n            // Test dependency extraction\r\n            assertNotNull(dependencies, \"Dependencies list should not be null\");\r\n\r\n            // Print dependencies\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM DEPENDENCIES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM DEPENDENCIES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Found \" + dependencies.size() + \" dependencies:\");\r\n            writer.println(\"Found \" + dependencies.size() + \" dependencies:\");\r\n\r\n            for (Dependency dependency : dependencies) {\r\n                String scope \u003d dependency.getScope() !\u003d null ? dependency.getScope() : \"compile\";\r\n\r\n                System.out.println(dependency.getGroupId() + \":\" +\r\n                        dependency.getArtifactId() + \":\" +\r\n                        dependency.getVersion() + \" (Scope: \" + scope + \")\");\r\n\r\n                writer.println(dependency.getGroupId() + \":\" +\r\n                        dependency.getArtifactId() + \":\" +\r\n                        dependency.getVersion() + \" (Scope: \" + scope + \")\");\r\n            }\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            // Extract coordinates from the single module POM file\r\n            PomCoordinates coordinates \u003d PomParser.extractCoordinates(singlePomFile);\r\n\r\n            // Test coordinate extraction\r\n            assertNotNull(coordinates, \"Coordinates should not be null\");\r\n\r\n            // Print coordinates\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Group ID: \" + coordinates.getGroupId());\r\n            System.out.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            System.out.println(\"Version: \" + coordinates.getVersion());\r\n\r\n            writer.println(\"Group ID: \" + coordinates.getGroupId());\r\n            writer.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            writer.println(\"Version: \" + coordinates.getVersion());\r\n        }",
          "comments": [
            "Extract dependencies from the"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "extraction",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Dependencies",
              "name": "list"
            }
          ],
          "body": "{\r\n                String scope \u003d dependency.getScope() !\u003d null ? dependency.getScope() : \"compile\";\r\n\r\n                System.out.println(dependency.getGroupId() + \":\" +\r\n                        dependency.getArtifactId() + \":\" +\r\n                        dependency.getVersion() + \" (Scope: \" + scope + \")\");\r\n\r\n                writer.println(dependency.getGroupId() + \":\" +\r\n                        dependency.getArtifactId() + \":\" +\r\n                        dependency.getVersion() + \" (Scope: \" + scope + \")\");\r\n            }",
          "comments": [
            "Extract dependencies from the single module POM file",
            "Test dependency extraction"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testExtractParentInfo",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            // Extract parent information from the single module POM file\r\n            Parent parent \u003d PomParser.extractParentInfo(singlePomFile);\r\n\r\n            // Print parent information\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM PARENT INFO \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM PARENT INFO \u003d\u003d\u003d\");\r\n\r\n            if (parent !\u003d null) {\r\n                System.out.println(\"Parent Group ID: \" + parent.getGroupId());\r\n                System.out.println(\"Parent Artifact ID: \" + parent.getArtifactId());\r\n                System.out.println(\"Parent Version: \" + parent.getVersion());\r\n                System.out.println(\"Relative Path: \" + parent.getRelativePath());\r\n\r\n                writer.println(\"Parent Group ID: \" + parent.getGroupId());\r\n                writer.println(\"Parent Artifact ID: \" + parent.getArtifactId());\r\n                writer.println(\"Parent Version: \" + parent.getVersion());\r\n                writer.println(\"Relative Path: \" + parent.getRelativePath());\r\n            } else {\r\n                System.out.println(\"No parent information found\");\r\n                writer.println(\"No parent information found\");\r\n            }\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            // Extract coordinates from the single module POM file\r\n            PomCoordinates coordinates \u003d PomParser.extractCoordinates(singlePomFile);\r\n\r\n            // Test coordinate extraction\r\n            assertNotNull(coordinates, \"Coordinates should not be null\");\r\n\r\n            // Print coordinates\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Group ID: \" + coordinates.getGroupId());\r\n            System.out.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            System.out.println(\"Version: \" + coordinates.getVersion());\r\n\r\n            writer.println(\"Group ID: \" + coordinates.getGroupId());\r\n            writer.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            writer.println(\"Version: \" + coordinates.getVersion());\r\n        }",
          "comments": [
            "Extract parent information fro"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testExtractPlugins",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            // Extract plugins from the single module POM file\r\n            List\u003cPlugin\u003e plugins \u003d PomParser.extractPlugins(singlePomFile);\r\n\r\n            // Test plugin extraction\r\n            assertNotNull(plugins, \"Plugins list should not be null\");\r\n\r\n            // Print plugins\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM PLUGINS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM PLUGINS \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Found \" + plugins.size() + \" plugins:\");\r\n            writer.println(\"Found \" + plugins.size() + \" plugins:\");\r\n\r\n            for (Plugin plugin : plugins) {\r\n                System.out.println(plugin.getGroupId() + \":\" +\r\n                        plugin.getArtifactId() + \":\" +\r\n                        plugin.getVersion());\r\n\r\n                writer.println(plugin.getGroupId() + \":\" +\r\n                        plugin.getArtifactId() + \":\" +\r\n                        plugin.getVersion());\r\n\r\n                // Print configuration if available\r\n                if (plugin.getConfiguration() !\u003d null) {\r\n                    System.out.println(\"  Configuration: \" + plugin.getConfiguration());\r\n                    writer.println(\"  Configuration: \" + plugin.getConfiguration());\r\n                }\r\n            }\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            // Extract coordinates from the single module POM file\r\n            PomCoordinates coordinates \u003d PomParser.extractCoordinates(singlePomFile);\r\n\r\n            // Test coordinate extraction\r\n            assertNotNull(coordinates, \"Coordinates should not be null\");\r\n\r\n            // Print coordinates\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Group ID: \" + coordinates.getGroupId());\r\n            System.out.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            System.out.println(\"Version: \" + coordinates.getVersion());\r\n\r\n            writer.println(\"Group ID: \" + coordinates.getGroupId());\r\n            writer.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            writer.println(\"Version: \" + coordinates.getVersion());\r\n        }",
          "comments": [
            "Extract plugins from the singl"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "extraction",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Plugins",
              "name": "list"
            }
          ],
          "body": "{\r\n                System.out.println(plugin.getGroupId() + \":\" +\r\n                        plugin.getArtifactId() + \":\" +\r\n                        plugin.getVersion());\r\n\r\n                writer.println(plugin.getGroupId() + \":\" +\r\n                        plugin.getArtifactId() + \":\" +\r\n                        plugin.getVersion());\r\n\r\n                // Print configuration if available\r\n                if (plugin.getConfiguration() !\u003d null) {\r\n                    System.out.println(\"  Configuration: \" + plugin.getConfiguration());\r\n                    writer.println(\"  Configuration: \" + plugin.getConfiguration());\r\n                }\r\n            }",
          "comments": [
            "Extract plugins from the single module POM file",
            "Test plugin extraction"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    System.out.println(\"  Configuration: \" + plugin.getConfiguration());\r\n                    writer.println(\"  Configuration: \" + plugin.getConfiguration());\r\n                }",
          "comments": [
            "Print configuration if available"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testExtractModules",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            try {\r\n                // Extract modules from the multi-module POM file\r\n                List\u003cString\u003e modules \u003d PomParser.extractModules(multiModulePomFile);\r\n\r\n                // Test module extraction\r\n                assertNotNull(modules, \"Modules list should not be null\");\r\n\r\n                // Print modules\r\n                System.out.println(\"\\n\u003d\u003d\u003d POM MODULES \u003d\u003d\u003d\");\r\n                writer.println(\"\\n\u003d\u003d\u003d POM MODULES \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Found \" + modules.size() + \" modules:\");\r\n                writer.println(\"Found \" + modules.size() + \" modules:\");\r\n\r\n                for (String module : modules) {\r\n                    System.out.println(\"- \" + module);\r\n                    writer.println(\"- \" + module);\r\n                }\r\n            } catch (IOException e) {\r\n                // Log the error but don\u0027t fail the test\r\n                System.out.println(\"\\n\u003d\u003d\u003d POM MODULES TEST ERROR \u003d\u003d\u003d\");\r\n                writer.println(\"\\n\u003d\u003d\u003d POM MODULES TEST ERROR \u003d\u003d\u003d\");\r\n                System.out.println(\"Error extracting modules: \" + e.getMessage());\r\n                writer.println(\"Error extracting modules: \" + e.getMessage());\r\n                System.out.println(\"This is expected if the multi-module POM file has XML format issues.\");\r\n                writer.println(\"This is expected if the multi-module POM file has XML format issues.\");\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while writing to output file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            // Extract coordinates from the single module POM file\r\n            PomCoordinates coordinates \u003d PomParser.extractCoordinates(singlePomFile);\r\n\r\n            // Test coordinate extraction\r\n            assertNotNull(coordinates, \"Coordinates should not be null\");\r\n\r\n            // Print coordinates\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Group ID: \" + coordinates.getGroupId());\r\n            System.out.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            System.out.println(\"Version: \" + coordinates.getVersion());\r\n\r\n            writer.println(\"Group ID: \" + coordinates.getGroupId());\r\n            writer.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            writer.println(\"Version: \" + coordinates.getVersion());\r\n        }",
          "comments": [
            "Extract"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "extraction",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Modules",
              "name": "list"
            }
          ],
          "body": "{\r\n                    System.out.println(\"- \" + module);\r\n                    writer.println(\"- \" + module);\r\n                }",
          "comments": [
            "Extract modules from the multi-module POM file",
            "Test module extraction"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testFindPomFiles",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            // Find POM files in the test resources directory\r\n            File testResourcesDir \u003d new File(\"src/test/resources\");\r\n            List\u003cFile\u003e pomFiles \u003d PomParser.findPomFiles(testResourcesDir);\r\n\r\n            // Test POM file finding\r\n            assertNotNull(pomFiles, \"POM files list should not be null\");\r\n            assertFalse(pomFiles.isEmpty(), \"POM files list should not be empty\");\r\n\r\n            // Print found POM files\r\n            System.out.println(\"\\n\u003d\u003d\u003d FOUND POM FILES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d FOUND POM FILES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Found \" + pomFiles.size() + \" POM files:\");\r\n            writer.println(\"Found \" + pomFiles.size() + \" POM files:\");\r\n\r\n            for (File pomFile : pomFiles) {\r\n                System.out.println(\"- \" + pomFile.getAbsolutePath());\r\n                writer.println(\"- \" + pomFile.getAbsolutePath());\r\n            }\r\n\r\n            System.out.println(\"\\nPOM parser test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while writing to output file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            // Extract coordinates from the single module POM file\r\n            PomCoordinates coordinates \u003d PomParser.extractCoordinates(singlePomFile);\r\n\r\n            // Test coordinate extraction\r\n            assertNotNull(coordinates, \"Coordinates should not be null\");\r\n\r\n            // Print coordinates\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Group ID: \" + coordinates.getGroupId());\r\n            System.out.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            System.out.println(\"Version: \" + coordinates.getVersion());\r\n\r\n            writer.println(\"Group ID: \" + coordinates.getGroupId());\r\n            writer.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            writer.println(\"Version: \" + coordinates.getVersion());\r\n        }",
          "comments": [
            "Find POM files in the test res"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                System.out.println(\"- \" + pomFile.getAbsolutePath());\r\n                writer.println(\"- \" + pomFile.getAbsolutePath());\r\n            }",
          "comments": [
            "Find POM files in the test resources directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "finding",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"POM",
              "name": "files"
            }
          ],
          "body": "{\r\n                System.out.println(\"- \" + pomFile.getAbsolutePath());\r\n                writer.println(\"- \" + pomFile.getAbsolutePath());\r\n            }",
          "comments": [
            "Test POM file finding"
          ]
        }
      ],
      "className": "PomParserTest",
      "packageName": "io.joshuasalcedo.parsers"
    },
    "src/main/java/io/joshuasalcedo/parsers/MarkdownParser.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/parsers/MarkdownParser.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "MarkdownParser",
          "parameters": [],
          "body": "{\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Markdown content using CommonMark.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AssertionError",
          "parameters": [
            {
              "type": "\"Utility",
              "name": "class"
            }
          ],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return MarkdownContent.builder().rawContent(\"\").htmlContent(\"\").build();\r\n        }\r\n\r\n        // Create parser with extensions\r\n        List\u003corg.commonmark.Extension\u003e extensions \u003d Arrays.asList(\r\n                AutolinkExtension.create(),\r\n                TablesExtension.create(),\r\n                StrikethroughExtension.create(),\r\n                InsExtension.create(),\r\n                HeadingAnchorExtension.create(),\r\n                YamlFrontMatterExtension.create()\r\n        );\r\n\r\n        Parser parser \u003d Parser.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n\r\n        HtmlRenderer renderer \u003d HtmlRenderer.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n\r\n        // Parse markdown\r\n        Node document \u003d parser.parse(markdown);\r\n\r\n        // Process front matter\r\n        YamlFrontMatterVisitor frontMatterVisitor \u003d new YamlFrontMatterVisitor();\r\n        document.accept(frontMatterVisitor);\r\n        Map\u003cString, Object\u003e frontMatter \u003d convertFrontMatter(frontMatterVisitor.getData());\r\n\r\n        // Collect structural elements\r\n        List\u003cMarkdownHeading\u003e headings \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownLink\u003e links \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownImage\u003e images \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownCodeBlock\u003e codeBlocks \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Extract structure by visiting nodes\r\n        StructureCollector collector \u003d new StructureCollector(headings, links, images, codeBlocks);\r\n        document.accept(collector);\r\n\r\n        // Extract title (first heading if available)\r\n        String title \u003d null;\r\n        if (!headings.isEmpty()) {\r\n            title \u003d headings.get(0).getText();\r\n        }\r\n\r\n        // Count words and estimate reading time\r\n        int wordCount \u003d countWords(markdown);\r\n        int readingTimeMinutes \u003d calculateReadingTime(wordCount);\r\n\r\n        // Render HTML\r\n        String htmlContent \u003d renderer.render(document);\r\n\r\n        return MarkdownContent.builder()\r\n                .title(title)\r\n                .rawContent(markdown)\r\n                .htmlContent(htmlContent)\r\n                .headings(headings)\r\n                .links(links)\r\n                .images(images)\r\n                .codeBlocks(codeBlocks)\r\n                .frontMatter(frontMatter)\r\n                .wordCount(wordCount)\r\n                .readingTimeMinutes(readingTimeMinutes)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Markdown content using CommonMark.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "MarkdownContent",
          "methodName": "parseMarkdown",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return MarkdownContent.builder().rawContent(\"\").htmlContent(\"\").build();\r\n        }\r\n\r\n        // Create parser with extensions\r\n        List\u003corg.commonmark.Extension\u003e extensions \u003d Arrays.asList(\r\n                AutolinkExtension.create(),\r\n                TablesExtension.create(),\r\n                StrikethroughExtension.create(),\r\n                InsExtension.create(),\r\n                HeadingAnchorExtension.create(),\r\n                YamlFrontMatterExtension.create()\r\n        );\r\n\r\n        Parser parser \u003d Parser.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n\r\n        HtmlRenderer renderer \u003d HtmlRenderer.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n\r\n        // Parse markdown\r\n        Node document \u003d parser.parse(markdown);\r\n\r\n        // Process front matter\r\n        YamlFrontMatterVisitor frontMatterVisitor \u003d new YamlFrontMatterVisitor();\r\n        document.accept(frontMatterVisitor);\r\n        Map\u003cString, Object\u003e frontMatter \u003d convertFrontMatter(frontMatterVisitor.getData());\r\n\r\n        // Collect structural elements\r\n        List\u003cMarkdownHeading\u003e headings \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownLink\u003e links \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownImage\u003e images \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownCodeBlock\u003e codeBlocks \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Extract structure by visiting nodes\r\n        StructureCollector collector \u003d new StructureCollector(headings, links, images, codeBlocks);\r\n        document.accept(collector);\r\n\r\n        // Extract title (first heading if available)\r\n        String title \u003d null;\r\n        if (!headings.isEmpty()) {\r\n            title \u003d headings.get(0).getText();\r\n        }\r\n\r\n        // Count words and estimate reading time\r\n        int wordCount \u003d countWords(markdown);\r\n        int readingTimeMinutes \u003d calculateReadingTime(wordCount);\r\n\r\n        // Render HTML\r\n        String htmlContent \u003d renderer.render(document);\r\n\r\n        return MarkdownContent.builder()\r\n                .title(title)\r\n                .rawContent(markdown)\r\n                .htmlContent(htmlContent)\r\n                .headings(headings)\r\n                .links(links)\r\n                .images(images)\r\n                .codeBlocks(codeBlocks)\r\n                .frontMatter(frontMatter)\r\n                .wordCount(wordCount)\r\n                .readingTimeMinutes(readingTimeMinutes)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Parse markdown content into a structured MarkdownContent object.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to parse"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "YamlFrontMatterVisitor",
          "parameters": [],
          "body": "{\r\n            title \u003d headings.get(0).getText();\r\n        }",
          "comments": [
            "Parse markdown",
            "Process front matter"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StructureCollector",
          "parameters": [],
          "body": "{\r\n            title \u003d headings.get(0).getText();\r\n        }",
          "comments": [
            "Extract structure by visiting nodes"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Extract",
          "methodName": "title",
          "parameters": [
            {
              "type": "first",
              "name": "heading"
            }
          ],
          "body": "{\r\n            title \u003d headings.get(0).getText();\r\n        }",
          "comments": [
            "Extract structure by visiting nodes",
            "Extract title (first heading if available)"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "MarkdownContent",
          "methodName": "parseMarkdownFile",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            }
          ],
          "body": "{\r\n        String content \u003d io.joshuasalcedo.utility.FileUtils.readFileAsString(file);\r\n        return parseMarkdown(content);\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The markdown file to parse"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "parseMarkdown",
          "parameters": [],
          "body": "{\r\n        String content \u003d io.joshuasalcedo.utility.FileUtils.readFileAsString(path.toFile());\r\n        return parseMarkdown(content);\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The markdown file to parse"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "MarkdownContent",
          "methodName": "parseMarkdownFile",
          "parameters": [
            {
              "type": "Path",
              "name": "path"
            }
          ],
          "body": "{\r\n        String content \u003d io.joshuasalcedo.utility.FileUtils.readFileAsString(path.toFile());\r\n        return parseMarkdown(content);\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a Path.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to the markdown file"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "parseMarkdown",
          "parameters": [],
          "body": "{\r\n        String content \u003d io.joshuasalcedo.utility.FileUtils.readFileAsString(path.toFile());\r\n        return parseMarkdown(content);\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a Path.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to the markdown file"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "MarkdownContent",
          "methodName": "parseMarkdownReader",
          "parameters": [
            {
              "type": "Reader",
              "name": "reader"
            }
          ],
          "body": "{\r\n        StringBuilder sb \u003d new StringBuilder();\r\n        char[] buffer \u003d new char[4096];\r\n        int n;\r\n        while ((n \u003d reader.read(buffer)) !\u003d -1) {\r\n            sb.append(buffer, 0, n);\r\n        }\r\n        return parseMarkdown(sb.toString());\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a Reader.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "reader The reader containing markdown content"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StringBuilder",
          "parameters": [],
          "body": "{\r\n            sb.append(buffer, 0, n);\r\n        }",
          "javadoc": {
            "description": "Parse markdown content from a Reader.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "reader The reader containing markdown content"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "parseMarkdown",
          "parameters": [],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return \"\";\r\n        }\r\n\r\n        List\u003corg.commonmark.Extension\u003e extensions \u003d Arrays.asList(\r\n                AutolinkExtension.create(),\r\n                TablesExtension.create(),\r\n                StrikethroughExtension.create(),\r\n                InsExtension.create()\r\n        );\r\n\r\n        Parser parser \u003d Parser.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n\r\n        HtmlRenderer renderer \u003d HtmlRenderer.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n\r\n        Node document \u003d parser.parse(markdown);\r\n        return renderer.render(document);\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "markdownToHtml",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return \"\";\r\n        }\r\n\r\n        List\u003corg.commonmark.Extension\u003e extensions \u003d Arrays.asList(\r\n                AutolinkExtension.create(),\r\n                TablesExtension.create(),\r\n                StrikethroughExtension.create(),\r\n                InsExtension.create()\r\n        );\r\n\r\n        Parser parser \u003d Parser.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n\r\n        HtmlRenderer renderer \u003d HtmlRenderer.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n\r\n        Node document \u003d parser.parse(markdown);\r\n        return renderer.render(document);\r\n    }",
          "javadoc": {
            "description": "Simply convert markdown to HTML.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to convert"
              },
              {
                "name": "return",
                "value": "HTML representation of the markdown"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMarkdownHeading\u003e",
          "methodName": "extractHeadings",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        MarkdownContent content \u003d parseMarkdown(markdown);\r\n        return content.getHeadings();\r\n    }",
          "javadoc": {
            "description": "Extract all headings from markdown content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to process"
              },
              {
                "name": "return",
                "value": "List of headings"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMarkdownLink\u003e",
          "methodName": "extractLinks",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        MarkdownContent content \u003d parseMarkdown(markdown);\r\n        return content.getLinks();\r\n    }",
          "javadoc": {
            "description": "Extract all links from markdown content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to process"
              },
              {
                "name": "return",
                "value": "List of links"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMarkdownImage\u003e",
          "methodName": "extractImages",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        MarkdownContent content \u003d parseMarkdown(markdown);\r\n        return content.getImages();\r\n    }",
          "javadoc": {
            "description": "Extract all images from markdown content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to process"
              },
              {
                "name": "return",
                "value": "List of images"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMarkdownCodeBlock\u003e",
          "methodName": "extractCodeBlocks",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        MarkdownContent content \u003d parseMarkdown(markdown);\r\n        return content.getCodeBlocks();\r\n    }",
          "javadoc": {
            "description": "Extract all code blocks from markdown content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to process"
              },
              {
                "name": "return",
                "value": "List of code blocks"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "int",
          "methodName": "countWords",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return 0;\r\n        }\r\n\r\n        // Remove YAML front matter if present\r\n        String content \u003d markdown;\r\n        if (content.startsWith(\"---\")) {\r\n            int end \u003d content.indexOf(\"---\", 3);\r\n            if (end \u003e 0) {\r\n                content \u003d content.substring(end + 3);\r\n            }\r\n        }\r\n\r\n        // Remove code blocks\r\n        content \u003d content.replaceAll(\"```.*?```\", \" \");\r\n\r\n        // Remove HTML tags\r\n        content \u003d content.replaceAll(\"\u003c[^\u003e]*\u003e\", \" \");\r\n\r\n        // Remove markdown symbols\r\n        content \u003d content.replaceAll(\"[#*_~`\\\\[\\\\](){}|]+\", \" \");\r\n\r\n        // Split by whitespace and count non-empty words\r\n        String[] words \u003d content.trim().split(\"\\\\s+\");\r\n        int count \u003d 0;\r\n        for (String word : words) {\r\n            if (!word.isEmpty()) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }",
          "javadoc": {
            "description": "Count the words in a markdown text.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content"
              },
              {
                "name": "return",
                "value": "The word count"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "int",
          "methodName": "calculateReadingTime",
          "parameters": [
            {
              "type": "int",
              "name": "wordCount"
            }
          ],
          "body": "{\r\n        // Average reading speed: 200-250 words per minute\r\n        final int wordsPerMinute \u003d 225;\r\n        int minutes \u003d wordCount / wordsPerMinute;\r\n        if (wordCount % wordsPerMinute \u003e 0) {\r\n            minutes++;\r\n        }\r\n        return Math.max(1, minutes);\r\n    }",
          "javadoc": {
            "description": "Calculate estimated reading time in minutes.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "wordCount The number of words"
              },
              {
                "name": "return",
                "value": "Estimated reading time in minutes"
              }
            ]
          },
          "comments": [
            "Average reading speed: 200-250"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "convertFrontMatter",
          "parameters": [
            {
              "type": "List\u003cString\u003e\u003e",
              "name": "frontMatterData"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n        for (Map.Entry\u003cString, List\u003cString\u003e\u003e entry : frontMatterData.entrySet()) {\r\n            String key \u003d entry.getKey();\r\n            List\u003cString\u003e values \u003d entry.getValue();\r\n\r\n            if (values.size() \u003d\u003d 1) {\r\n                // Single value\r\n                result.put(key, values.get(0));\r\n            } else {\r\n                // Multiple values\r\n                result.put(key, values);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }",
          "javadoc": {
            "description": "Convert front matter data to a map of objects.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "frontMatterData The front matter data from the visitor"
              },
              {
                "name": "return",
                "value": "Converted front matter map"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "public",
          "methodName": "StructureCollector",
          "parameters": [
            {
              "type": "List\u003cMarkdownHeading\u003e",
              "name": "headings"
            },
            {
              "type": "List\u003cMarkdownLink\u003e",
              "name": "links"
            },
            {
              "type": "List\u003cMarkdownImage\u003e",
              "name": "images"
            },
            {
              "type": "List\u003cMarkdownCodeBlock\u003e",
              "name": "codeBlocks"
            }
          ],
          "body": "{\r\n            this.headings \u003d headings;\r\n            this.links \u003d links;\r\n            this.images \u003d images;\r\n            this.codeBlocks \u003d codeBlocks;\r\n        }",
          "javadoc": {
            "description": "A node visitor that collects structural elements from a markdown document.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "Heading",
              "name": "heading"
            }
          ],
          "body": "{\r\n            String id \u003d \"\";\r\n            // Get heading ID from attributes if available\r\n            if (heading.getFirstChild() instanceof Text) {\r\n                String text \u003d ((Text) heading.getFirstChild()).getLiteral();\r\n                // Generate simplified ID from heading text\r\n                id \u003d text.toLowerCase()\r\n                        .replaceAll(\"[^\\\\w\\\\s-]\", \"\")\r\n                        .replaceAll(\"\\\\s+\", \"-\");\r\n            }\r\n\r\n            StringBuilder textBuilder \u003d new StringBuilder();\r\n            Node child \u003d heading.getFirstChild();\r\n            while (child !\u003d null) {\r\n                if (child instanceof Text) {\r\n                    textBuilder.append(((Text) child).getLiteral());\r\n                }\r\n                child \u003d child.getNext();\r\n            }\r\n\r\n            MarkdownHeading mdHeading \u003d MarkdownHeading.builder()\r\n                    .level(heading.getLevel())\r\n                    .text(textBuilder.toString())\r\n                    .id(id)\r\n                    .position(nodePosition++)\r\n                    .build();\r\n\r\n            headings.add(mdHeading);\r\n            visitChildren(heading);\r\n        }",
          "comments": [
            "Get heading ID fro"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                String text \u003d ((Text) heading.getFirstChild()).getLiteral();\r\n                // Generate simplified ID from heading text\r\n                id \u003d text.toLowerCase()\r\n                        .replaceAll(\"[^\\\\w\\\\s-]\", \"\")\r\n                        .replaceAll(\"\\\\s+\", \"-\");\r\n            }",
          "comments": [
            "Get heading ID from attributes if available"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StringBuilder",
          "parameters": [],
          "body": "{\r\n            sb.append(buffer, 0, n);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "Link",
              "name": "link"
            }
          ],
          "body": "{\r\n            String text \u003d \"\";\r\n            if (link.getFirstChild() instanceof Text) {\r\n                text \u003d ((Text) link.getFirstChild()).getLiteral();\r\n            }\r\n\r\n            MarkdownLink mdLink \u003d MarkdownLink.builder()\r\n                    .text(text)\r\n                    .url(link.getDestination())\r\n                    .title(link.getTitle())\r\n                    .internal(link.getDestination().startsWith(\"#\"))\r\n                    .build();\r\n\r\n            links.add(mdLink);\r\n            visitChildren(link);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "Image",
              "name": "image"
            }
          ],
          "body": "{\r\n            MarkdownImage mdImage \u003d MarkdownImage.builder()\r\n                    .altText(image.getTitle())\r\n                    .url(image.getDestination())\r\n                    .title(image.getTitle())\r\n                    .local(!image.getDestination().startsWith(\"http\"))\r\n                    .build();\r\n\r\n            images.add(mdImage);\r\n            visitChildren(image);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "FencedCodeBlock",
              "name": "codeBlock"
            }
          ],
          "body": "{\r\n            MarkdownCodeBlock mdCodeBlock \u003d MarkdownCodeBlock.builder()\r\n                    .content(codeBlock.getLiteral())\r\n                    .language(codeBlock.getInfo())\r\n                    .fenced(true)\r\n                    .position(nodePosition++)\r\n                    .build();\r\n\r\n            codeBlocks.add(mdCodeBlock);\r\n            visitChildren(codeBlock);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "IndentedCodeBlock",
              "name": "codeBlock"
            }
          ],
          "body": "{\r\n            MarkdownCodeBlock mdCodeBlock \u003d MarkdownCodeBlock.builder()\r\n                    .content(codeBlock.getLiteral())\r\n                    .language(null)\r\n                    .fenced(false)\r\n                    .position(nodePosition++)\r\n                    .build();\r\n\r\n            codeBlocks.add(mdCodeBlock);\r\n            visitChildren(codeBlock);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "toJson",
          "parameters": [
            {
              "type": "MarkdownContent",
              "name": "content"
            }
          ],
          "body": "{\r\n        return io.joshuasalcedo.utility.JsonUtils.toPrettyJson(content);\r\n    }",
          "javadoc": {
            "description": "Convert MarkdownContent to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The MarkdownContent object"
              },
              {
                "name": "return",
                "value": "JSON representation of the MarkdownContent"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "headingsToJson",
          "parameters": [
            {
              "type": "List\u003cMarkdownHeading\u003e",
              "name": "headings"
            }
          ],
          "body": "{\r\n        return io.joshuasalcedo.utility.JsonUtils.toPrettyJson(headings);\r\n    }",
          "javadoc": {
            "description": "Convert a list of headings to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "headings The list of headings"
              },
              {
                "name": "return",
                "value": "JSON representation of the headings"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "linksToJson",
          "parameters": [
            {
              "type": "List\u003cMarkdownLink\u003e",
              "name": "links"
            }
          ],
          "body": "{\r\n        return io.joshuasalcedo.utility.JsonUtils.toPrettyJson(links);\r\n    }",
          "javadoc": {
            "description": "Convert a list of links to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "links The list of links"
              },
              {
                "name": "return",
                "value": "JSON representation of the links"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "imagesToJson",
          "parameters": [
            {
              "type": "List\u003cMarkdownImage\u003e",
              "name": "images"
            }
          ],
          "body": "{\r\n        return io.joshuasalcedo.utility.JsonUtils.toPrettyJson(images);\r\n    }",
          "javadoc": {
            "description": "Convert a list of images to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "images The list of images"
              },
              {
                "name": "return",
                "value": "JSON representation of the images"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "codeBlocksToJson",
          "parameters": [
            {
              "type": "List\u003cMarkdownCodeBlock\u003e",
              "name": "codeBlocks"
            }
          ],
          "body": "{\r\n        return io.joshuasalcedo.utility.JsonUtils.toPrettyJson(codeBlocks);\r\n    }",
          "javadoc": {
            "description": "Convert a list of code blocks to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "codeBlocks The list of code blocks"
              },
              {
                "name": "return",
                "value": "JSON representation of the code blocks"
              }
            ]
          },
          "comments": []
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    "src/main/java/io/joshuasalcedo/model/markdown/MarkdownContent.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/markdown/MarkdownContent.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "document",
          "parameters": [
            {
              "type": "usually",
              "name": "from"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Represents the parsed structure of a Markdown document.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "if",
          "methodName": "present",
          "parameters": [
            {
              "type": "for",
              "name": "formats"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "List of all code blocks in the document.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "MarkdownContent",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    "src/main/java/io/joshuasalcedo/model/maven/PomCoordinates.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/maven/PomCoordinates.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "project",
          "parameters": [],
          "body": "",
          "javadoc": {
            "description": "The version of the project.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "PomCoordinates",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    "src/main/java/io/joshuasalcedo/utility/JsonUtils.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/utility/JsonUtils.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "GsonBuilder",
          "parameters": [],
          "body": "{\r\n        return gson.toJson(obj);\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "GsonBuilder",
          "parameters": [],
          "body": "{\r\n        return gson.toJson(obj);\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "toJson",
          "parameters": [
            {
              "type": "Object",
              "name": "obj"
            }
          ],
          "body": "{\r\n        return gson.toJson(obj);\r\n    }",
          "javadoc": {
            "description": "Convert any object to a JSON string",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "toPrettyJson",
          "parameters": [
            {
              "type": "Object",
              "name": "obj"
            }
          ],
          "body": "{\r\n        return prettyGson.toJson(obj);\r\n    }",
          "javadoc": {
            "description": "Convert any object to a JSON string with pretty printing",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "toJsonMap",
          "parameters": [
            {
              "type": "Object",
              "name": "obj"
            }
          ],
          "body": "{\r\n        String json \u003d gson.toJson(obj);\r\n        return gson.fromJson(json, Map.class);\r\n    }",
          "javadoc": {
            "description": "Convert any object to a JSON Map",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "JsonUtils",
      "packageName": "io.joshuasalcedo.utility"
    },
    "target/test-classes/repo/Feature.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/target/test-classes/repo/Feature.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "doSomething",
          "parameters": [],
          "body": "{ }",
          "comments": []
        }
      ],
      "className": "Feature",
      "packageName": "default"
    },
    "src/test/resources/repo/src/main/java/com/test/feature/FeatureClass.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/resources/repo/src/main/java/com/test/feature/FeatureClass.java",
      "methods": [],
      "className": "FeatureClass",
      "packageName": "com.test.feature"
    },
    "src/main/java/io/joshuasalcedo/model/maven/Dependency.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/maven/Dependency.java",
      "methods": [],
      "className": "Dependency",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    "src/test/resources/test/java/TestSample.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/resources/test/java/TestSample.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "public",
          "methodName": "TestSample",
          "parameters": [],
          "body": "{\r\n        this.name \u003d \"default\";\r\n        this.count \u003d 0;\r\n    }",
          "javadoc": {
            "description": "Default constructor.",
            "tags": []
          },
          "comments": [
            "Class-level fields"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "public",
          "methodName": "TestSample",
          "parameters": [
            {
              "type": "String",
              "name": "name"
            },
            {
              "type": "int",
              "name": "count"
            }
          ],
          "body": "{\r\n        this.name \u003d name;\r\n        this.count \u003d count;\r\n    }",
          "javadoc": {
            "description": "Parameterized constructor.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "name The name to set"
              },
              {
                "name": "param",
                "value": "count The count to set"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "String",
          "methodName": "getName",
          "parameters": [],
          "body": "{\r\n        return this.name;\r\n    }",
          "javadoc": {
            "description": "Returns the name field.\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The name field"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "setName",
          "parameters": [
            {
              "type": "String",
              "name": "name"
            }
          ],
          "body": "{\r\n        this.name \u003d name;\r\n    }",
          "javadoc": {
            "description": "Sets the name field.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "name The new name value"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "int",
          "methodName": "getCount",
          "parameters": [],
          "body": "{\r\n        return this.count;\r\n    }",
          "javadoc": {
            "description": "Returns the count field.\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The count field"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "setCount",
          "parameters": [
            {
              "type": "int",
              "name": "count"
            }
          ],
          "body": "{\r\n        this.count \u003d count;\r\n    }",
          "javadoc": {
            "description": "Sets the count field.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "count The new count value"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "List\u003cString\u003e",
          "methodName": "processItems",
          "parameters": [
            {
              "type": "List\u003cString\u003e",
              "name": "items"
            },
            {
              "type": "String",
              "name": "filter"
            }
          ],
          "body": "{\r\n        if (items \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Items list cannot be null\");\r\n        }\r\n\r\n        List\u003cString\u003e result \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Filter items based on the provided filter\r\n        for (String item : items) {\r\n            if (filter \u003d\u003d null || item.contains(filter)) {\r\n                result.add(item);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }",
          "javadoc": {
            "description": "Processes a list of strings and returns a filtered list.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "items The list of strings to process"
              },
              {
                "name": "param",
                "value": "filter The filter string to apply"
              },
              {
                "name": "return",
                "value": "A filtered list of strings"
              },
              {
                "name": "throws",
                "value": "IllegalArgumentException If items is null"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "IllegalArgumentException",
          "parameters": [
            {
              "type": "\"Items",
              "name": "list"
            }
          ],
          "body": "{\r\n            if (filter \u003d\u003d null || item.contains(filter)) {\r\n                result.add(item);\r\n            }\r\n        }",
          "javadoc": {
            "description": "Processes a list of strings and returns a filtered list.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "items The list of strings to process"
              },
              {
                "name": "param",
                "value": "filter The filter string to apply"
              },
              {
                "name": "return",
                "value": "A filtered list of strings"
              },
              {
                "name": "throws",
                "value": "IllegalArgumentException If items is null"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "filter",
          "methodName": "for",
          "parameters": [
            {
              "type": "String",
              "name": "item"
            }
          ],
          "body": "{\r\n            if (filter \u003d\u003d null || item.contains(filter)) {\r\n                result.add(item);\r\n            }\r\n        }",
          "comments": [
            "Filter items based on the provided filter"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "int",
          "methodName": "calculateSum",
          "parameters": [
            {
              "type": "int[]",
              "name": "numbers"
            }
          ],
          "body": "{\r\n        int sum \u003d 0;\r\n\r\n        // Simple summation\r\n        for (int num : numbers) {\r\n            sum +\u003d num;\r\n        }\r\n\r\n        return sum;\r\n    }",
          "javadoc": {
            "description": "Static utility method to calculate the sum of an array of integers.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "numbers The array of integers to sum"
              },
              {
                "name": "return",
                "value": "The sum of all numbers in the array"
              }
            ]
          },
          "comments": [
            "Simple summation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "summation",
          "methodName": "for",
          "parameters": [
            {
              "type": "int",
              "name": "num"
            }
          ],
          "body": "{\r\n            sum +\u003d num;\r\n        }",
          "javadoc": {
            "description": "Static utility method to calculate the sum of an array of integers.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "numbers The array of integers to sum"
              },
              {
                "name": "return",
                "value": "The sum of all numbers in the array"
              }
            ]
          },
          "comments": [
            "Simple summation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "helperMethod",
          "parameters": [],
          "body": "{\r\n            // This is a helper method in an inner class\r\n            System.out.println(\"Helper method called\");\r\n        }",
          "javadoc": {
            "description": "Static utility method to calculate the sum of an array of integers.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "numbers The array of integers to sum"
              },
              {
                "name": "return",
                "value": "The sum of all numbers in the array"
              }
            ]
          },
          "comments": [
            "Inner class for demonstration purposes",
            "This is a helper method in an inner class"
          ]
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.test"
    },
    "src/main/java/io/joshuasalcedo/model/markdown/MarkdownLink.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/markdown/MarkdownLink.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "internal",
          "methodName": "link",
          "parameters": [
            {
              "type": "within",
              "name": "the"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The title attribute of the link, if any.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "MarkdownLink",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    "src/main/java/io/joshuasalcedo/model/maven/PomStructure.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/maven/PomStructure.java",
      "methods": [],
      "className": "PomStructure",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    "src/test/java/io/joshuasalcedo/parsers/HtmlParserTest.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/java/io/joshuasalcedo/parsers/HtmlParserTest.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "setUp",
          "parameters": [],
          "body": "{\r\n        // Set up the test HTML file location\r\n        testHtmlFile \u003d new File(\"src/test/resources/test/html/test.html\");\r\n        assertTrue(testHtmlFile.exists(), \"Test HTML file does not exist\");\r\n\r\n        // Set up output file\r\n        outputFile \u003d new File(\"src/test/resources/test/html/test-output.txt\");\r\n    }",
          "comments": [
            "Set up the test HTML file location"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        // Create output file writer\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            // Parse the HTML file\r\n            Document document \u003d HtmlParser.parse(testHtmlFile, \"UTF-8\", \"\");\r\n\r\n            // Test basic HTML parsing\r\n            assertNotNull(document, \"Document should not be null\");\r\n            String title \u003d document.title();\r\n            assertEquals(\"Test HTML Document\", title, \"Document title should match\");\r\n\r\n            // Print document title\r\n            System.out.println(\"Document Title: \" + title);\r\n            writer.println(\"Document Title: \" + title);\r\n\r\n            // Test extracting headings\r\n            Elements headings \u003d HtmlParser.getHeadings(document);\r\n            assertFalse(headings.isEmpty(), \"There should be at least one heading\");\r\n\r\n            // Print headings\r\n            System.out.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            for (Element heading : headings) {\r\n                System.out.println(heading.tagName() + \": \" + heading.text());\r\n                writer.println(heading.tagName() + \": \" + heading.text());\r\n            }\r\n\r\n            // Test extracting links\r\n            Elements links \u003d HtmlParser.getLinks(document);\r\n            assertFalse(links.isEmpty(), \"There should be at least one link\");\r\n\r\n            // Print links\r\n            System.out.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            for (Element link : links) {\r\n                System.out.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n                writer.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n            }\r\n\r\n            // Test metadata extraction\r\n            Map\u003cString, String\u003e metadata \u003d HtmlParser.getMetadata(document);\r\n            assertNotNull(metadata, \"Metadata should not be null\");\r\n            assertTrue(metadata.containsKey(\"title\"), \"Metadata should contain title\");\r\n\r\n            // Print metadata\r\n            System.out.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, String\u003e entry : metadata.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                writer.println(entry.getKey() + \": \" + entry.getValue());\r\n            }\r\n\r\n            // Test tables\r\n            Elements tables \u003d HtmlParser.getTables(document);\r\n\r\n            // Print tables\r\n            System.out.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            for (Element table : tables) {\r\n                System.out.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n                writer.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n\r\n                // Extract table data as array\r\n                String[][] tableData \u003d HtmlParser.tableToArray(table);\r\n                for (String[] row : tableData) {\r\n                    for (String cell : row) {\r\n                        System.out.print(cell + \"\\t| \");\r\n                        writer.print(cell + \"\\t| \");\r\n                    }\r\n                    System.out.println();\r\n                    writer.println();\r\n                }\r\n\r\n                // Extract table as maps\r\n                Map\u003cString, String\u003e[] tableMaps \u003d HtmlParser.tableToMaps(table);\r\n                System.out.println(\"\\nTable as Maps:\");\r\n                writer.println(\"\\nTable as Maps:\");\r\n                for (Map\u003cString, String\u003e row : tableMaps) {\r\n                    System.out.println(row);\r\n                    writer.println(row);\r\n                }\r\n            }\r\n\r\n            // Test images\r\n            Elements images \u003d HtmlParser.getImages(document);\r\n\r\n            // Print images\r\n            System.out.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            for (Element image : images) {\r\n                System.out.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n                writer.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n            }\r\n\r\n            // Test lists\r\n            Elements lists \u003d HtmlParser.getLists(document);\r\n\r\n            // Print lists\r\n            System.out.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            for (Element list : lists) {\r\n                System.out.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                writer.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                for (Element item : list.select(\"li\")) {\r\n                    System.out.println(\"- \" + item.text());\r\n                    writer.println(\"- \" + item.text());\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nHTML parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }\r\n    }",
          "comments": [
            "Set up the test HTML file location"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        // Create output file writer\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            // Parse the HTML file\r\n            Document document \u003d HtmlParser.parse(testHtmlFile, \"UTF-8\", \"\");\r\n\r\n            // Test basic HTML parsing\r\n            assertNotNull(document, \"Document should not be null\");\r\n            String title \u003d document.title();\r\n            assertEquals(\"Test HTML Document\", title, \"Document title should match\");\r\n\r\n            // Print document title\r\n            System.out.println(\"Document Title: \" + title);\r\n            writer.println(\"Document Title: \" + title);\r\n\r\n            // Test extracting headings\r\n            Elements headings \u003d HtmlParser.getHeadings(document);\r\n            assertFalse(headings.isEmpty(), \"There should be at least one heading\");\r\n\r\n            // Print headings\r\n            System.out.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            for (Element heading : headings) {\r\n                System.out.println(heading.tagName() + \": \" + heading.text());\r\n                writer.println(heading.tagName() + \": \" + heading.text());\r\n            }\r\n\r\n            // Test extracting links\r\n            Elements links \u003d HtmlParser.getLinks(document);\r\n            assertFalse(links.isEmpty(), \"There should be at least one link\");\r\n\r\n            // Print links\r\n            System.out.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            for (Element link : links) {\r\n                System.out.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n                writer.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n            }\r\n\r\n            // Test metadata extraction\r\n            Map\u003cString, String\u003e metadata \u003d HtmlParser.getMetadata(document);\r\n            assertNotNull(metadata, \"Metadata should not be null\");\r\n            assertTrue(metadata.containsKey(\"title\"), \"Metadata should contain title\");\r\n\r\n            // Print metadata\r\n            System.out.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, String\u003e entry : metadata.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                writer.println(entry.getKey() + \": \" + entry.getValue());\r\n            }\r\n\r\n            // Test tables\r\n            Elements tables \u003d HtmlParser.getTables(document);\r\n\r\n            // Print tables\r\n            System.out.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            for (Element table : tables) {\r\n                System.out.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n                writer.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n\r\n                // Extract table data as array\r\n                String[][] tableData \u003d HtmlParser.tableToArray(table);\r\n                for (String[] row : tableData) {\r\n                    for (String cell : row) {\r\n                        System.out.print(cell + \"\\t| \");\r\n                        writer.print(cell + \"\\t| \");\r\n                    }\r\n                    System.out.println();\r\n                    writer.println();\r\n                }\r\n\r\n                // Extract table as maps\r\n                Map\u003cString, String\u003e[] tableMaps \u003d HtmlParser.tableToMaps(table);\r\n                System.out.println(\"\\nTable as Maps:\");\r\n                writer.println(\"\\nTable as Maps:\");\r\n                for (Map\u003cString, String\u003e row : tableMaps) {\r\n                    System.out.println(row);\r\n                    writer.println(row);\r\n                }\r\n            }\r\n\r\n            // Test images\r\n            Elements images \u003d HtmlParser.getImages(document);\r\n\r\n            // Print images\r\n            System.out.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            for (Element image : images) {\r\n                System.out.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n                writer.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n            }\r\n\r\n            // Test lists\r\n            Elements lists \u003d HtmlParser.getLists(document);\r\n\r\n            // Print lists\r\n            System.out.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            for (Element list : lists) {\r\n                System.out.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                writer.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                for (Element item : list.select(\"li\")) {\r\n                    System.out.println(\"- \" + item.text());\r\n                    writer.println(\"- \" + item.text());\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nHTML parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }\r\n    }",
          "comments": [
            "Set up output file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseAndExtractElements",
          "parameters": [],
          "body": "{\r\n        // Create output file writer\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            // Parse the HTML file\r\n            Document document \u003d HtmlParser.parse(testHtmlFile, \"UTF-8\", \"\");\r\n\r\n            // Test basic HTML parsing\r\n            assertNotNull(document, \"Document should not be null\");\r\n            String title \u003d document.title();\r\n            assertEquals(\"Test HTML Document\", title, \"Document title should match\");\r\n\r\n            // Print document title\r\n            System.out.println(\"Document Title: \" + title);\r\n            writer.println(\"Document Title: \" + title);\r\n\r\n            // Test extracting headings\r\n            Elements headings \u003d HtmlParser.getHeadings(document);\r\n            assertFalse(headings.isEmpty(), \"There should be at least one heading\");\r\n\r\n            // Print headings\r\n            System.out.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            for (Element heading : headings) {\r\n                System.out.println(heading.tagName() + \": \" + heading.text());\r\n                writer.println(heading.tagName() + \": \" + heading.text());\r\n            }\r\n\r\n            // Test extracting links\r\n            Elements links \u003d HtmlParser.getLinks(document);\r\n            assertFalse(links.isEmpty(), \"There should be at least one link\");\r\n\r\n            // Print links\r\n            System.out.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            for (Element link : links) {\r\n                System.out.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n                writer.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n            }\r\n\r\n            // Test metadata extraction\r\n            Map\u003cString, String\u003e metadata \u003d HtmlParser.getMetadata(document);\r\n            assertNotNull(metadata, \"Metadata should not be null\");\r\n            assertTrue(metadata.containsKey(\"title\"), \"Metadata should contain title\");\r\n\r\n            // Print metadata\r\n            System.out.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, String\u003e entry : metadata.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                writer.println(entry.getKey() + \": \" + entry.getValue());\r\n            }\r\n\r\n            // Test tables\r\n            Elements tables \u003d HtmlParser.getTables(document);\r\n\r\n            // Print tables\r\n            System.out.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            for (Element table : tables) {\r\n                System.out.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n                writer.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n\r\n                // Extract table data as array\r\n                String[][] tableData \u003d HtmlParser.tableToArray(table);\r\n                for (String[] row : tableData) {\r\n                    for (String cell : row) {\r\n                        System.out.print(cell + \"\\t| \");\r\n                        writer.print(cell + \"\\t| \");\r\n                    }\r\n                    System.out.println();\r\n                    writer.println();\r\n                }\r\n\r\n                // Extract table as maps\r\n                Map\u003cString, String\u003e[] tableMaps \u003d HtmlParser.tableToMaps(table);\r\n                System.out.println(\"\\nTable as Maps:\");\r\n                writer.println(\"\\nTable as Maps:\");\r\n                for (Map\u003cString, String\u003e row : tableMaps) {\r\n                    System.out.println(row);\r\n                    writer.println(row);\r\n                }\r\n            }\r\n\r\n            // Test images\r\n            Elements images \u003d HtmlParser.getImages(document);\r\n\r\n            // Print images\r\n            System.out.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            for (Element image : images) {\r\n                System.out.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n                writer.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n            }\r\n\r\n            // Test lists\r\n            Elements lists \u003d HtmlParser.getLists(document);\r\n\r\n            // Print lists\r\n            System.out.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            for (Element list : lists) {\r\n                System.out.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                writer.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                for (Element item : list.select(\"li\")) {\r\n                    System.out.println(\"- \" + item.text());\r\n                    writer.println(\"- \" + item.text());\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nHTML parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }\r\n    }",
          "comments": [
            "Set up output file",
            "Create output file writer"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "writer",
          "methodName": "try",
          "parameters": [
            {
              "type": "PrintWriter",
              "name": "writer"
            }
          ],
          "body": "{\r\n            // Parse the HTML file\r\n            Document document \u003d HtmlParser.parse(testHtmlFile, \"UTF-8\", \"\");\r\n\r\n            // Test basic HTML parsing\r\n            assertNotNull(document, \"Document should not be null\");\r\n            String title \u003d document.title();\r\n            assertEquals(\"Test HTML Document\", title, \"Document title should match\");\r\n\r\n            // Print document title\r\n            System.out.println(\"Document Title: \" + title);\r\n            writer.println(\"Document Title: \" + title);\r\n\r\n            // Test extracting headings\r\n            Elements headings \u003d HtmlParser.getHeadings(document);\r\n            assertFalse(headings.isEmpty(), \"There should be at least one heading\");\r\n\r\n            // Print headings\r\n            System.out.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            for (Element heading : headings) {\r\n                System.out.println(heading.tagName() + \": \" + heading.text());\r\n                writer.println(heading.tagName() + \": \" + heading.text());\r\n            }\r\n\r\n            // Test extracting links\r\n            Elements links \u003d HtmlParser.getLinks(document);\r\n            assertFalse(links.isEmpty(), \"There should be at least one link\");\r\n\r\n            // Print links\r\n            System.out.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            for (Element link : links) {\r\n                System.out.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n                writer.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n            }\r\n\r\n            // Test metadata extraction\r\n            Map\u003cString, String\u003e metadata \u003d HtmlParser.getMetadata(document);\r\n            assertNotNull(metadata, \"Metadata should not be null\");\r\n            assertTrue(metadata.containsKey(\"title\"), \"Metadata should contain title\");\r\n\r\n            // Print metadata\r\n            System.out.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, String\u003e entry : metadata.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                writer.println(entry.getKey() + \": \" + entry.getValue());\r\n            }\r\n\r\n            // Test tables\r\n            Elements tables \u003d HtmlParser.getTables(document);\r\n\r\n            // Print tables\r\n            System.out.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            for (Element table : tables) {\r\n                System.out.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n                writer.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n\r\n                // Extract table data as array\r\n                String[][] tableData \u003d HtmlParser.tableToArray(table);\r\n                for (String[] row : tableData) {\r\n                    for (String cell : row) {\r\n                        System.out.print(cell + \"\\t| \");\r\n                        writer.print(cell + \"\\t| \");\r\n                    }\r\n                    System.out.println();\r\n                    writer.println();\r\n                }\r\n\r\n                // Extract table as maps\r\n                Map\u003cString, String\u003e[] tableMaps \u003d HtmlParser.tableToMaps(table);\r\n                System.out.println(\"\\nTable as Maps:\");\r\n                writer.println(\"\\nTable as Maps:\");\r\n                for (Map\u003cString, String\u003e row : tableMaps) {\r\n                    System.out.println(row);\r\n                    writer.println(row);\r\n                }\r\n            }\r\n\r\n            // Test images\r\n            Elements images \u003d HtmlParser.getImages(document);\r\n\r\n            // Print images\r\n            System.out.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            for (Element image : images) {\r\n                System.out.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n                writer.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n            }\r\n\r\n            // Test lists\r\n            Elements lists \u003d HtmlParser.getLists(document);\r\n\r\n            // Print lists\r\n            System.out.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            for (Element list : lists) {\r\n                System.out.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                writer.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                for (Element item : list.select(\"li\")) {\r\n                    System.out.println(\"- \" + item.text());\r\n                    writer.println(\"- \" + item.text());\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nHTML parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }",
          "comments": [
            "Create output file writer"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parsing",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Document",
              "name": "should"
            }
          ],
          "body": "{\r\n                System.out.println(heading.tagName() + \": \" + heading.text());\r\n                writer.println(heading.tagName() + \": \" + heading.text());\r\n            }",
          "comments": [
            "Parse the HTML file",
            "Test basic HTML parsing"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testExtractingTextContent",
          "parameters": [],
          "body": "{\r\n        // Parse the HTML file\r\n        Document document \u003d HtmlParser.parse(testHtmlFile, \"UTF-8\", \"\");\r\n\r\n        // Test extracting text content\r\n        String textContent \u003d HtmlParser.getTextContent(document);\r\n        assertNotNull(textContent, \"Text content should not be null\");\r\n        assertFalse(textContent.isEmpty(), \"Text content should not be empty\");\r\n\r\n        // Print text content\r\n        System.out.println(\"\\n\u003d\u003d\u003d FULL TEXT CONTENT \u003d\u003d\u003d\");\r\n        System.out.println(textContent);\r\n\r\n        // Write to file\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            writer.println(\"\\n\u003d\u003d\u003d FULL TEXT CONTENT \u003d\u003d\u003d\");\r\n            writer.println(textContent);\r\n        }\r\n    }",
          "comments": [
            "Parse the HTML file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "file",
          "methodName": "try",
          "parameters": [
            {
              "type": "PrintWriter",
              "name": "writer"
            }
          ],
          "body": "{\r\n            writer.println(\"\\n\u003d\u003d\u003d FULL TEXT CONTENT \u003d\u003d\u003d\");\r\n            writer.println(textContent);\r\n        }",
          "comments": [
            "Print text content",
            "Write to file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testCssSelectors",
          "parameters": [],
          "body": "{\r\n        // Parse the HTML file\r\n        Document document \u003d HtmlParser.parse(testHtmlFile, \"UTF-8\", \"\");\r\n\r\n        // Write to file\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            // Test using CSS selectors\r\n            Elements paragraphs \u003d HtmlParser.select(document, \"p\");\r\n            assertFalse(paragraphs.isEmpty(), \"There should be at least one paragraph\");\r\n\r\n            // Print paragraphs\r\n            System.out.println(\"\\n\u003d\u003d\u003d PARAGRAPHS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d PARAGRAPHS \u003d\u003d\u003d\");\r\n            for (Element p : paragraphs) {\r\n                System.out.println(p.text());\r\n                writer.println(p.text());\r\n            }\r\n\r\n            // Test custom selectors\r\n            Elements containerDiv \u003d HtmlParser.select(document, \"div.container\");\r\n\r\n            // Print container info\r\n            System.out.println(\"\\n\u003d\u003d\u003d CONTAINER DIV \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CONTAINER DIV \u003d\u003d\u003d\");\r\n            if (!containerDiv.isEmpty()) {\r\n                System.out.println(\"Container found with \" + containerDiv.first().children().size() + \" child elements\");\r\n                writer.println(\"Container found with \" + containerDiv.first().children().size() + \" child elements\");\r\n            }\r\n\r\n            // Test checking if elements exist\r\n            boolean hasDivs \u003d HtmlParser.exists(document, \"div\");\r\n            boolean hasForm \u003d HtmlParser.exists(document, \"form\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d ELEMENT EXISTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d ELEMENT EXISTS \u003d\u003d\u003d\");\r\n            System.out.println(\"Has divs: \" + hasDivs);\r\n            writer.println(\"Has divs: \" + hasDivs);\r\n            System.out.println(\"Has forms: \" + hasForm);\r\n            writer.println(\"Has forms: \" + hasForm);\r\n        }\r\n    }",
          "comments": [
            "Parse the HTML file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "file",
          "methodName": "try",
          "parameters": [
            {
              "type": "PrintWriter",
              "name": "writer"
            }
          ],
          "body": "{\r\n            writer.println(\"\\n\u003d\u003d\u003d FULL TEXT CONTENT \u003d\u003d\u003d\");\r\n            writer.println(textContent);\r\n        }",
          "comments": [
            "Parse the HTML file",
            "Write to file"
          ]
        }
      ],
      "className": "HtmlParserTest",
      "packageName": "io.joshuasalcedo.parsers"
    },
    "target/test-classes/repo/src/main/java/App.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/target/test-classes/repo/src/main/java/App.java",
      "methods": [],
      "className": "App",
      "packageName": "com.test"
    },
    "src/main/java/io/joshuasalcedo/model/maven/Property.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/maven/Property.java",
      "methods": [],
      "className": "Property",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    "src/test/resources/repo/Main.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/resources/repo/Main.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "main",
          "parameters": [
            {
              "type": "String[]",
              "name": "args"
            }
          ],
          "body": "{ System.out.println(\"Hello World\"); }",
          "comments": []
        }
      ],
      "className": "Main",
      "packageName": "default"
    },
    "src/main/java/io/joshuasalcedo/model/javafile/JavadocTag.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/javafile/JavadocTag.java",
      "methods": [],
      "className": "JavadocTag",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    "target/test-classes/test/java/TestSample.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/target/test-classes/test/java/TestSample.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "public",
          "methodName": "TestSample",
          "parameters": [],
          "body": "{\r\n        this.name \u003d \"default\";\r\n        this.count \u003d 0;\r\n    }",
          "javadoc": {
            "description": "Default constructor.",
            "tags": []
          },
          "comments": [
            "Class-level fields"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "public",
          "methodName": "TestSample",
          "parameters": [
            {
              "type": "String",
              "name": "name"
            },
            {
              "type": "int",
              "name": "count"
            }
          ],
          "body": "{\r\n        this.name \u003d name;\r\n        this.count \u003d count;\r\n    }",
          "javadoc": {
            "description": "Parameterized constructor.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "name The name to set"
              },
              {
                "name": "param",
                "value": "count The count to set"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "String",
          "methodName": "getName",
          "parameters": [],
          "body": "{\r\n        return this.name;\r\n    }",
          "javadoc": {
            "description": "Returns the name field.\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The name field"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "setName",
          "parameters": [
            {
              "type": "String",
              "name": "name"
            }
          ],
          "body": "{\r\n        this.name \u003d name;\r\n    }",
          "javadoc": {
            "description": "Sets the name field.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "name The new name value"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "int",
          "methodName": "getCount",
          "parameters": [],
          "body": "{\r\n        return this.count;\r\n    }",
          "javadoc": {
            "description": "Returns the count field.\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The count field"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "setCount",
          "parameters": [
            {
              "type": "int",
              "name": "count"
            }
          ],
          "body": "{\r\n        this.count \u003d count;\r\n    }",
          "javadoc": {
            "description": "Sets the count field.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "count The new count value"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "List\u003cString\u003e",
          "methodName": "processItems",
          "parameters": [
            {
              "type": "List\u003cString\u003e",
              "name": "items"
            },
            {
              "type": "String",
              "name": "filter"
            }
          ],
          "body": "{\r\n        if (items \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Items list cannot be null\");\r\n        }\r\n\r\n        List\u003cString\u003e result \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Filter items based on the provided filter\r\n        for (String item : items) {\r\n            if (filter \u003d\u003d null || item.contains(filter)) {\r\n                result.add(item);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }",
          "javadoc": {
            "description": "Processes a list of strings and returns a filtered list.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "items The list of strings to process"
              },
              {
                "name": "param",
                "value": "filter The filter string to apply"
              },
              {
                "name": "return",
                "value": "A filtered list of strings"
              },
              {
                "name": "throws",
                "value": "IllegalArgumentException If items is null"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "IllegalArgumentException",
          "parameters": [
            {
              "type": "\"Items",
              "name": "list"
            }
          ],
          "body": "{\r\n            if (filter \u003d\u003d null || item.contains(filter)) {\r\n                result.add(item);\r\n            }\r\n        }",
          "javadoc": {
            "description": "Processes a list of strings and returns a filtered list.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "items The list of strings to process"
              },
              {
                "name": "param",
                "value": "filter The filter string to apply"
              },
              {
                "name": "return",
                "value": "A filtered list of strings"
              },
              {
                "name": "throws",
                "value": "IllegalArgumentException If items is null"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "filter",
          "methodName": "for",
          "parameters": [
            {
              "type": "String",
              "name": "item"
            }
          ],
          "body": "{\r\n            if (filter \u003d\u003d null || item.contains(filter)) {\r\n                result.add(item);\r\n            }\r\n        }",
          "comments": [
            "Filter items based on the provided filter"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "int",
          "methodName": "calculateSum",
          "parameters": [
            {
              "type": "int[]",
              "name": "numbers"
            }
          ],
          "body": "{\r\n        int sum \u003d 0;\r\n\r\n        // Simple summation\r\n        for (int num : numbers) {\r\n            sum +\u003d num;\r\n        }\r\n\r\n        return sum;\r\n    }",
          "javadoc": {
            "description": "Static utility method to calculate the sum of an array of integers.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "numbers The array of integers to sum"
              },
              {
                "name": "return",
                "value": "The sum of all numbers in the array"
              }
            ]
          },
          "comments": [
            "Simple summation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "summation",
          "methodName": "for",
          "parameters": [
            {
              "type": "int",
              "name": "num"
            }
          ],
          "body": "{\r\n            sum +\u003d num;\r\n        }",
          "javadoc": {
            "description": "Static utility method to calculate the sum of an array of integers.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "numbers The array of integers to sum"
              },
              {
                "name": "return",
                "value": "The sum of all numbers in the array"
              }
            ]
          },
          "comments": [
            "Simple summation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "helperMethod",
          "parameters": [],
          "body": "{\r\n            // This is a helper method in an inner class\r\n            System.out.println(\"Helper method called\");\r\n        }",
          "javadoc": {
            "description": "Static utility method to calculate the sum of an array of integers.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "numbers The array of integers to sum"
              },
              {
                "name": "return",
                "value": "The sum of all numbers in the array"
              }
            ]
          },
          "comments": [
            "Inner class for demonstration purposes",
            "This is a helper method in an inner class"
          ]
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.test"
    },
    "src/main/java/io/joshuasalcedo/model/git/FileChange.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/git/FileChange.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "change",
          "methodName": "type",
          "parameters": [],
          "body": "{\r\n        /**\r\n         * File was added.\r\n         */\r\n        ADD,\r\n        \r\n        /**\r\n         * File was modified.\r\n         */\r\n        MODIFY,\r\n        \r\n        /**\r\n         * File was deleted.\r\n         */\r\n        DELETE,\r\n        \r\n        /**\r\n         * File was renamed.\r\n         */\r\n        RENAME,\r\n        \r\n        /**\r\n         * File was copied.\r\n         */\r\n        COPY\r\n    }",
          "javadoc": {
            "description": "Represents information about a file change in a Git commit.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "file",
          "parameters": [
            {
              "type": "for",
              "name": "renames"
            }
          ],
          "body": "{\r\n        /**\r\n         * File was added.\r\n         */\r\n        ADD,\r\n        \r\n        /**\r\n         * File was modified.\r\n         */\r\n        MODIFY,\r\n        \r\n        /**\r\n         * File was deleted.\r\n         */\r\n        DELETE,\r\n        \r\n        /**\r\n         * File was renamed.\r\n         */\r\n        RENAME,\r\n        \r\n        /**\r\n         * File was copied.\r\n         */\r\n        COPY\r\n    }",
          "javadoc": {
            "description": "The path of the file.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "FileChange",
      "packageName": "io.joshuasalcedo.model.git"
    },
    "src/test/java/io/joshuasalcedo/parsers/ParserTest.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/java/io/joshuasalcedo/parsers/ParserTest.java",
      "methods": [
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "boolean",
          "methodName": "isCurrentDirGitRepo",
          "parameters": [],
          "body": "{\r\n        File gitDir \u003d new File(\".git\");\r\n        return gitDir.exists() \u0026\u0026 gitDir.isDirectory();\r\n    }",
          "javadoc": {
            "description": "Check if the current directory is a Git repository.\r\nThis is used to conditionally enable tests that require a Git repository.\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "true if the current directory is a Git repository"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the Git repository\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains the expected Git repository information\r\n        assertTrue(resultMap.containsKey(\"gitRepository\"), \"Result should contain gitRepository key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Git Repository Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Check if the current directory is a Git repository.\r\nThis is used to conditionally enable tests that require a Git repository.\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "true if the current directory is a Git repository"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseGit",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the Git repository\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains the expected Git repository information\r\n        assertTrue(resultMap.containsKey(\"gitRepository\"), \"Result should contain gitRepository key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Git Repository Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.git method with the current directory.\r\nThis test is only enabled if the current directory is a Git repository.",
            "tags": []
          },
          "comments": [
            "Get the current directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Result",
              "name": "map"
            }
          ],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.git method with the current directory.\r\nThis test is only enabled if the current directory is a Git repository.",
            "tags": []
          },
          "comments": [
            "Parse the Git repository",
            "Verify the result is not null"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "information",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "comments": [
            "Verify the map contains the expected Git repository information"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseGitNonExistentDirectory",
          "parameters": [],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.git method with a non-existent directory.",
            "tags": []
          },
          "comments": [
            "Parse a non-existent directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Result",
              "name": "map"
            }
          ],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.git method with a non-existent directory.",
            "tags": []
          },
          "comments": [
            "Parse a non-existent directory",
            "Verify the result is not null"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "message",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        // Create a temporary directory\r\n        File tempDir \u003d File.createTempFile(\"temp\", \"dir\");\r\n        tempDir.delete();\r\n        tempDir.mkdir();\r\n        tempDir.deleteOnExit();\r\n\r\n        // Parse the non-Git directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(tempDir.getAbsolutePath());\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Not a valid Git repository\"), \r\n                \"Error message should indicate not a valid Git repository\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-Git Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "comments": [
            "Verify the map contains an error message"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseGitNonGitDirectory",
          "parameters": [],
          "body": "{\r\n        // Create a temporary directory\r\n        File tempDir \u003d File.createTempFile(\"temp\", \"dir\");\r\n        tempDir.delete();\r\n        tempDir.mkdir();\r\n        tempDir.deleteOnExit();\r\n\r\n        // Parse the non-Git directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(tempDir.getAbsolutePath());\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Not a valid Git repository\"), \r\n                \"Error message should indicate not a valid Git repository\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-Git Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.git method with a directory that is not a Git repository.",
            "tags": []
          },
          "comments": [
            "Create a temporary directo"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Result",
              "name": "map"
            }
          ],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "comments": [
            "Parse the non-Git directory",
            "Verify the result is not null"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "message",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        // Create a temporary directory\r\n        File tempDir \u003d File.createTempFile(\"temp\", \"dir\");\r\n        tempDir.delete();\r\n        tempDir.mkdir();\r\n        tempDir.deleteOnExit();\r\n\r\n        // Parse the non-Git directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(tempDir.getAbsolutePath());\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Not a valid Git repository\"), \r\n                \"Error message should indicate not a valid Git repository\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-Git Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "comments": [
            "Verify the map contains an error message"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseAll",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the directory using all parsers\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.all(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains file statistics\r\n        assertTrue(resultMap.containsKey(\"fileStatistics\"), \"Result should contain fileStatistics key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"All Parsers Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.all method with the current directory.\r\nThis test parses the current directory using all available parsers.",
            "tags": []
          },
          "comments": [
            "Get the current directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Result",
              "name": "map"
            }
          ],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.all method with the current directory.\r\nThis test parses the current directory using all available parsers.",
            "tags": []
          },
          "comments": [
            "Parse the directory using all parsers",
            "Verify the result is not null"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "statistics",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the Java files in the directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.java(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains Java files information\r\n        assertTrue(resultMap.containsKey(\"javaFiles\"), \"Result should contain javaFiles key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Java Parser Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "comments": [
            "Verify the map contains file statistics"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseJava",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the Java files in the directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.java(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains Java files information\r\n        assertTrue(resultMap.containsKey(\"javaFiles\"), \"Result should contain javaFiles key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Java Parser Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.java method with the current directory.",
            "tags": []
          },
          "comments": [
            "Get the current directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Result",
              "name": "map"
            }
          ],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.java method with the current directory.",
            "tags": []
          },
          "comments": [
            "Parse the Java files in the directory",
            "Verify the result is not null"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "information",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the POM files in the directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.pom(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains POM files information\r\n        assertTrue(resultMap.containsKey(\"pomFiles\"), \"Result should contain pomFiles key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"POM Parser Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "comments": [
            "Verify the map contains Java files information"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParsePom",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the POM files in the directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.pom(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains POM files information\r\n        assertTrue(resultMap.containsKey(\"pomFiles\"), \"Result should contain pomFiles key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"POM Parser Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.pom method with the current directory.",
            "tags": []
          },
          "comments": [
            "Get the current directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Result",
              "name": "map"
            }
          ],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.pom method with the current directory.",
            "tags": []
          },
          "comments": [
            "Parse the POM files in the directory",
            "Verify the result is not null"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "information",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the HTML files in the directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.html(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains HTML files information\r\n        assertTrue(resultMap.containsKey(\"htmlFiles\"), \"Result should contain htmlFiles key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"HTML Parser Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "comments": [
            "Verify the map contains POM files information"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseHtml",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the HTML files in the directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.html(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains HTML files information\r\n        assertTrue(resultMap.containsKey(\"htmlFiles\"), \"Result should contain htmlFiles key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"HTML Parser Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.html method with the current directory.",
            "tags": []
          },
          "comments": [
            "Get the current directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Result",
              "name": "map"
            }
          ],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.html method with the current directory.",
            "tags": []
          },
          "comments": [
            "Parse the HTML files in the directory",
            "Verify the result is not null"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "information",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "",
          "comments": [
            "Verify the map contains HTML files information"
          ]
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    "src/main/java/io/joshuasalcedo/model/markdown/MarkdownHeading.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/markdown/MarkdownHeading.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "heading",
          "parameters": [],
          "body": "",
          "javadoc": {
            "description": "Represents a heading in a Markdown document.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "heading",
          "parameters": [
            {
              "type": "for",
              "name": "anchor"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The text content of the heading.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "MarkdownHeading",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    "target/test-classes/repo/Main.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/target/test-classes/repo/Main.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "main",
          "parameters": [
            {
              "type": "String[]",
              "name": "args"
            }
          ],
          "body": "{ System.out.println(\"Hello World\"); }",
          "comments": []
        }
      ],
      "className": "Main",
      "packageName": "default"
    },
    "src/main/java/io/joshuasalcedo/model/maven/ParentInfo.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/maven/ParentInfo.java",
      "methods": [],
      "className": "ParentInfo",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    "src/test/java/io/joshuasalcedo/parsers/JavaParserTest.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/java/io/joshuasalcedo/parsers/JavaParserTest.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "setUp",
          "parameters": [],
          "body": "{\r\n        // Set up the test Java file location\r\n        testJavaFile \u003d new File(\"src/test/resources/test/java/TestSample.java\");\r\n        assertTrue(testJavaFile.exists(), \"Test Java file does not exist\");\r\n\r\n        // Set up output file\r\n        outputFile \u003d new File(\"src/test/resources/test/java/java-parser-output.txt\");\r\n    }",
          "comments": [
            "Set up the test Java file location"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            // Read the Java file content\r\n            String content \u003d new String(Files.readAllBytes(testJavaFile.toPath()));\r\n\r\n            // Extract package name\r\n            String packageName \u003d JavaParser.extractPackageName(content);\r\n            System.out.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            System.out.println(packageName);\r\n            writer.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            writer.println(packageName);\r\n\r\n            // Extract class JavaDoc\r\n            JavadocStructure classJavadoc \u003d JavaParser.extractClassJavadoc(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            if (classJavadoc !\u003d null) {\r\n                System.out.println(\"Description: \" + classJavadoc.getDescription());\r\n                writer.println(\"Description: \" + classJavadoc.getDescription());\r\n\r\n                System.out.println(\"\\nJavaDoc Tags:\");\r\n                writer.println(\"\\nJavaDoc Tags:\");\r\n                for (JavadocTag tag : classJavadoc.getTags()) {\r\n                    System.out.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                    writer.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                }\r\n            } else {\r\n                System.out.println(\"No class JavaDoc found\");\r\n                writer.println(\"No class JavaDoc found\");\r\n            }\r\n\r\n            // Extract class comments\r\n            List\u003cString\u003e classComments \u003d JavaParser.extractClassComments(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            if (!classComments.isEmpty()) {\r\n                for (String comment : classComments) {\r\n                    System.out.println(comment);\r\n                    writer.println(comment);\r\n                }\r\n            } else {\r\n                System.out.println(\"No class comments found\");\r\n                writer.println(\"No class comments found\");\r\n            }\r\n\r\n            // Extract class structure\r\n            ClassStructure classStructure \u003d JavaParser.extractClassStructure(testJavaFile.getName(), content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            System.out.println(\"File Name: \" + classStructure.getFileName());\r\n            System.out.println(\"Package Name: \" + classStructure.getPackageName());\r\n            System.out.println(\"Class Name: \" + classStructure.getClassName());\r\n            System.out.println(\"Class Type: \" + classStructure.getClassType());\r\n            writer.println(\"File Name: \" + classStructure.getFileName());\r\n            writer.println(\"Package Name: \" + classStructure.getPackageName());\r\n            writer.println(\"Class Name: \" + classStructure.getClassName());\r\n            writer.println(\"Class Type: \" + classStructure.getClassType());\r\n\r\n            // Extract methods\r\n            List\u003cMethodStructure\u003e methods \u003d JavaParser.extractMethods(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + methods.size() + \" methods:\");\r\n            writer.println(\"Found \" + methods.size() + \" methods:\");\r\n\r\n            for (MethodStructure method : methods) {\r\n                System.out.println(\"\\nMethod: \" + method.getMethodName());\r\n                System.out.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                System.out.println(\"Static: \" + method.isStatic());\r\n                System.out.println(\"Return Type: \" + method.getReturnType());\r\n                System.out.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                writer.println(\"\\nMethod: \" + method.getMethodName());\r\n                writer.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                writer.println(\"Static: \" + method.isStatic());\r\n                writer.println(\"Return Type: \" + method.getReturnType());\r\n                writer.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                // Print parameters\r\n                if (!method.getParameters().isEmpty()) {\r\n                    System.out.println(\"Parameter list:\");\r\n                    writer.println(\"Parameter list:\");\r\n                    method.getParameters().forEach(param -\u003e {\r\n                        System.out.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                        writer.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                    });\r\n                }\r\n\r\n                // Print method JavaDoc if available\r\n                if (method.getJavadoc() !\u003d null) {\r\n                    System.out.println(\"Method JavaDoc:\");\r\n                    writer.println(\"Method JavaDoc:\");\r\n                    System.out.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n                    writer.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n\r\n                    if (!method.getJavadoc().getTags().isEmpty()) {\r\n                        System.out.println(\"  Tags:\");\r\n                        writer.println(\"  Tags:\");\r\n                        method.getJavadoc().getTags().forEach(tag -\u003e {\r\n                            System.out.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                            writer.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // Print method body (truncated for readability)\r\n                if (method.getBody() !\u003d null \u0026\u0026 !method.getBody().isEmpty()) {\r\n                    String bodyPreview \u003d method.getBody().length() \u003e 100\r\n                            ? method.getBody().substring(0, 100) + \"...\"\r\n                            : method.getBody();\r\n                    System.out.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                    writer.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nJava parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }\r\n    }",
          "comments": [
            "Set up the test Java file location"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            // Read the Java file content\r\n            String content \u003d new String(Files.readAllBytes(testJavaFile.toPath()));\r\n\r\n            // Extract package name\r\n            String packageName \u003d JavaParser.extractPackageName(content);\r\n            System.out.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            System.out.println(packageName);\r\n            writer.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            writer.println(packageName);\r\n\r\n            // Extract class JavaDoc\r\n            JavadocStructure classJavadoc \u003d JavaParser.extractClassJavadoc(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            if (classJavadoc !\u003d null) {\r\n                System.out.println(\"Description: \" + classJavadoc.getDescription());\r\n                writer.println(\"Description: \" + classJavadoc.getDescription());\r\n\r\n                System.out.println(\"\\nJavaDoc Tags:\");\r\n                writer.println(\"\\nJavaDoc Tags:\");\r\n                for (JavadocTag tag : classJavadoc.getTags()) {\r\n                    System.out.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                    writer.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                }\r\n            } else {\r\n                System.out.println(\"No class JavaDoc found\");\r\n                writer.println(\"No class JavaDoc found\");\r\n            }\r\n\r\n            // Extract class comments\r\n            List\u003cString\u003e classComments \u003d JavaParser.extractClassComments(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            if (!classComments.isEmpty()) {\r\n                for (String comment : classComments) {\r\n                    System.out.println(comment);\r\n                    writer.println(comment);\r\n                }\r\n            } else {\r\n                System.out.println(\"No class comments found\");\r\n                writer.println(\"No class comments found\");\r\n            }\r\n\r\n            // Extract class structure\r\n            ClassStructure classStructure \u003d JavaParser.extractClassStructure(testJavaFile.getName(), content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            System.out.println(\"File Name: \" + classStructure.getFileName());\r\n            System.out.println(\"Package Name: \" + classStructure.getPackageName());\r\n            System.out.println(\"Class Name: \" + classStructure.getClassName());\r\n            System.out.println(\"Class Type: \" + classStructure.getClassType());\r\n            writer.println(\"File Name: \" + classStructure.getFileName());\r\n            writer.println(\"Package Name: \" + classStructure.getPackageName());\r\n            writer.println(\"Class Name: \" + classStructure.getClassName());\r\n            writer.println(\"Class Type: \" + classStructure.getClassType());\r\n\r\n            // Extract methods\r\n            List\u003cMethodStructure\u003e methods \u003d JavaParser.extractMethods(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + methods.size() + \" methods:\");\r\n            writer.println(\"Found \" + methods.size() + \" methods:\");\r\n\r\n            for (MethodStructure method : methods) {\r\n                System.out.println(\"\\nMethod: \" + method.getMethodName());\r\n                System.out.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                System.out.println(\"Static: \" + method.isStatic());\r\n                System.out.println(\"Return Type: \" + method.getReturnType());\r\n                System.out.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                writer.println(\"\\nMethod: \" + method.getMethodName());\r\n                writer.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                writer.println(\"Static: \" + method.isStatic());\r\n                writer.println(\"Return Type: \" + method.getReturnType());\r\n                writer.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                // Print parameters\r\n                if (!method.getParameters().isEmpty()) {\r\n                    System.out.println(\"Parameter list:\");\r\n                    writer.println(\"Parameter list:\");\r\n                    method.getParameters().forEach(param -\u003e {\r\n                        System.out.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                        writer.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                    });\r\n                }\r\n\r\n                // Print method JavaDoc if available\r\n                if (method.getJavadoc() !\u003d null) {\r\n                    System.out.println(\"Method JavaDoc:\");\r\n                    writer.println(\"Method JavaDoc:\");\r\n                    System.out.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n                    writer.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n\r\n                    if (!method.getJavadoc().getTags().isEmpty()) {\r\n                        System.out.println(\"  Tags:\");\r\n                        writer.println(\"  Tags:\");\r\n                        method.getJavadoc().getTags().forEach(tag -\u003e {\r\n                            System.out.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                            writer.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // Print method body (truncated for readability)\r\n                if (method.getBody() !\u003d null \u0026\u0026 !method.getBody().isEmpty()) {\r\n                    String bodyPreview \u003d method.getBody().length() \u003e 100\r\n                            ? method.getBody().substring(0, 100) + \"...\"\r\n                            : method.getBody();\r\n                    System.out.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                    writer.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nJava parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }\r\n    }",
          "comments": [
            "Set up output file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseJavaFile",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            // Read the Java file content\r\n            String content \u003d new String(Files.readAllBytes(testJavaFile.toPath()));\r\n\r\n            // Extract package name\r\n            String packageName \u003d JavaParser.extractPackageName(content);\r\n            System.out.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            System.out.println(packageName);\r\n            writer.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            writer.println(packageName);\r\n\r\n            // Extract class JavaDoc\r\n            JavadocStructure classJavadoc \u003d JavaParser.extractClassJavadoc(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            if (classJavadoc !\u003d null) {\r\n                System.out.println(\"Description: \" + classJavadoc.getDescription());\r\n                writer.println(\"Description: \" + classJavadoc.getDescription());\r\n\r\n                System.out.println(\"\\nJavaDoc Tags:\");\r\n                writer.println(\"\\nJavaDoc Tags:\");\r\n                for (JavadocTag tag : classJavadoc.getTags()) {\r\n                    System.out.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                    writer.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                }\r\n            } else {\r\n                System.out.println(\"No class JavaDoc found\");\r\n                writer.println(\"No class JavaDoc found\");\r\n            }\r\n\r\n            // Extract class comments\r\n            List\u003cString\u003e classComments \u003d JavaParser.extractClassComments(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            if (!classComments.isEmpty()) {\r\n                for (String comment : classComments) {\r\n                    System.out.println(comment);\r\n                    writer.println(comment);\r\n                }\r\n            } else {\r\n                System.out.println(\"No class comments found\");\r\n                writer.println(\"No class comments found\");\r\n            }\r\n\r\n            // Extract class structure\r\n            ClassStructure classStructure \u003d JavaParser.extractClassStructure(testJavaFile.getName(), content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            System.out.println(\"File Name: \" + classStructure.getFileName());\r\n            System.out.println(\"Package Name: \" + classStructure.getPackageName());\r\n            System.out.println(\"Class Name: \" + classStructure.getClassName());\r\n            System.out.println(\"Class Type: \" + classStructure.getClassType());\r\n            writer.println(\"File Name: \" + classStructure.getFileName());\r\n            writer.println(\"Package Name: \" + classStructure.getPackageName());\r\n            writer.println(\"Class Name: \" + classStructure.getClassName());\r\n            writer.println(\"Class Type: \" + classStructure.getClassType());\r\n\r\n            // Extract methods\r\n            List\u003cMethodStructure\u003e methods \u003d JavaParser.extractMethods(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + methods.size() + \" methods:\");\r\n            writer.println(\"Found \" + methods.size() + \" methods:\");\r\n\r\n            for (MethodStructure method : methods) {\r\n                System.out.println(\"\\nMethod: \" + method.getMethodName());\r\n                System.out.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                System.out.println(\"Static: \" + method.isStatic());\r\n                System.out.println(\"Return Type: \" + method.getReturnType());\r\n                System.out.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                writer.println(\"\\nMethod: \" + method.getMethodName());\r\n                writer.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                writer.println(\"Static: \" + method.isStatic());\r\n                writer.println(\"Return Type: \" + method.getReturnType());\r\n                writer.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                // Print parameters\r\n                if (!method.getParameters().isEmpty()) {\r\n                    System.out.println(\"Parameter list:\");\r\n                    writer.println(\"Parameter list:\");\r\n                    method.getParameters().forEach(param -\u003e {\r\n                        System.out.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                        writer.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                    });\r\n                }\r\n\r\n                // Print method JavaDoc if available\r\n                if (method.getJavadoc() !\u003d null) {\r\n                    System.out.println(\"Method JavaDoc:\");\r\n                    writer.println(\"Method JavaDoc:\");\r\n                    System.out.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n                    writer.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n\r\n                    if (!method.getJavadoc().getTags().isEmpty()) {\r\n                        System.out.println(\"  Tags:\");\r\n                        writer.println(\"  Tags:\");\r\n                        method.getJavadoc().getTags().forEach(tag -\u003e {\r\n                            System.out.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                            writer.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // Print method body (truncated for readability)\r\n                if (method.getBody() !\u003d null \u0026\u0026 !method.getBody().isEmpty()) {\r\n                    String bodyPreview \u003d method.getBody().length() \u003e 100\r\n                            ? method.getBody().substring(0, 100) + \"...\"\r\n                            : method.getBody();\r\n                    System.out.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                    writer.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nJava parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }\r\n    }",
          "comments": [
            "Set up output file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            // Read the Java file content\r\n            String content \u003d new String(Files.readAllBytes(testJavaFile.toPath()));\r\n\r\n            // Extract package name\r\n            String packageName \u003d JavaParser.extractPackageName(content);\r\n            System.out.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            System.out.println(packageName);\r\n            writer.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            writer.println(packageName);\r\n\r\n            // Extract class JavaDoc\r\n            JavadocStructure classJavadoc \u003d JavaParser.extractClassJavadoc(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            if (classJavadoc !\u003d null) {\r\n                System.out.println(\"Description: \" + classJavadoc.getDescription());\r\n                writer.println(\"Description: \" + classJavadoc.getDescription());\r\n\r\n                System.out.println(\"\\nJavaDoc Tags:\");\r\n                writer.println(\"\\nJavaDoc Tags:\");\r\n                for (JavadocTag tag : classJavadoc.getTags()) {\r\n                    System.out.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                    writer.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                }\r\n            } else {\r\n                System.out.println(\"No class JavaDoc found\");\r\n                writer.println(\"No class JavaDoc found\");\r\n            }\r\n\r\n            // Extract class comments\r\n            List\u003cString\u003e classComments \u003d JavaParser.extractClassComments(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            if (!classComments.isEmpty()) {\r\n                for (String comment : classComments) {\r\n                    System.out.println(comment);\r\n                    writer.println(comment);\r\n                }\r\n            } else {\r\n                System.out.println(\"No class comments found\");\r\n                writer.println(\"No class comments found\");\r\n            }\r\n\r\n            // Extract class structure\r\n            ClassStructure classStructure \u003d JavaParser.extractClassStructure(testJavaFile.getName(), content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            System.out.println(\"File Name: \" + classStructure.getFileName());\r\n            System.out.println(\"Package Name: \" + classStructure.getPackageName());\r\n            System.out.println(\"Class Name: \" + classStructure.getClassName());\r\n            System.out.println(\"Class Type: \" + classStructure.getClassType());\r\n            writer.println(\"File Name: \" + classStructure.getFileName());\r\n            writer.println(\"Package Name: \" + classStructure.getPackageName());\r\n            writer.println(\"Class Name: \" + classStructure.getClassName());\r\n            writer.println(\"Class Type: \" + classStructure.getClassType());\r\n\r\n            // Extract methods\r\n            List\u003cMethodStructure\u003e methods \u003d JavaParser.extractMethods(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + methods.size() + \" methods:\");\r\n            writer.println(\"Found \" + methods.size() + \" methods:\");\r\n\r\n            for (MethodStructure method : methods) {\r\n                System.out.println(\"\\nMethod: \" + method.getMethodName());\r\n                System.out.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                System.out.println(\"Static: \" + method.isStatic());\r\n                System.out.println(\"Return Type: \" + method.getReturnType());\r\n                System.out.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                writer.println(\"\\nMethod: \" + method.getMethodName());\r\n                writer.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                writer.println(\"Static: \" + method.isStatic());\r\n                writer.println(\"Return Type: \" + method.getReturnType());\r\n                writer.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                // Print parameters\r\n                if (!method.getParameters().isEmpty()) {\r\n                    System.out.println(\"Parameter list:\");\r\n                    writer.println(\"Parameter list:\");\r\n                    method.getParameters().forEach(param -\u003e {\r\n                        System.out.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                        writer.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                    });\r\n                }\r\n\r\n                // Print method JavaDoc if available\r\n                if (method.getJavadoc() !\u003d null) {\r\n                    System.out.println(\"Method JavaDoc:\");\r\n                    writer.println(\"Method JavaDoc:\");\r\n                    System.out.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n                    writer.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n\r\n                    if (!method.getJavadoc().getTags().isEmpty()) {\r\n                        System.out.println(\"  Tags:\");\r\n                        writer.println(\"  Tags:\");\r\n                        method.getJavadoc().getTags().forEach(tag -\u003e {\r\n                            System.out.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                            writer.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // Print method body (truncated for readability)\r\n                if (method.getBody() !\u003d null \u0026\u0026 !method.getBody().isEmpty()) {\r\n                    String bodyPreview \u003d method.getBody().length() \u003e 100\r\n                            ? method.getBody().substring(0, 100) + \"...\"\r\n                            : method.getBody();\r\n                    System.out.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                    writer.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nJava parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }",
          "comments": [
            "Read the Java file content"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "String",
          "parameters": [],
          "body": "{\r\n                System.out.println(\"Description: \" + classJavadoc.getDescription());\r\n                writer.println(\"Description: \" + classJavadoc.getDescription());\r\n\r\n                System.out.println(\"\\nJavaDoc Tags:\");\r\n                writer.println(\"\\nJavaDoc Tags:\");\r\n                for (JavadocTag tag : classJavadoc.getTags()) {\r\n                    System.out.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                    writer.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                }\r\n            }",
          "comments": [
            "Read the Java file content",
            "Extract package name"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parameters",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    System.out.println(\"Parameter list:\");\r\n                    writer.println(\"Parameter list:\");\r\n                    method.getParameters().forEach(param -\u003e {\r\n                        System.out.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                        writer.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                    });\r\n                }",
          "comments": [
            "Print parameters"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    System.out.println(\"Method JavaDoc:\");\r\n                    writer.println(\"Method JavaDoc:\");\r\n                    System.out.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n                    writer.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n\r\n                    if (!method.getJavadoc().getTags().isEmpty()) {\r\n                        System.out.println(\"  Tags:\");\r\n                        writer.println(\"  Tags:\");\r\n                        method.getJavadoc().getTags().forEach(tag -\u003e {\r\n                            System.out.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                            writer.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                        });\r\n                    }\r\n                }",
          "comments": [
            "Print method JavaDoc if available"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "method",
          "methodName": "body",
          "parameters": [
            {
              "type": "truncated",
              "name": "for"
            }
          ],
          "body": "{\r\n                    String bodyPreview \u003d method.getBody().length() \u003e 100\r\n                            ? method.getBody().substring(0, 100) + \"...\"\r\n                            : method.getBody();\r\n                    System.out.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                    writer.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                }",
          "comments": [
            "Print method body (truncated for readability)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testFindJavaFiles",
          "parameters": [],
          "body": "{\r\n        File testDir \u003d new File(\"src/test/resources/test/java\");\r\n        List\u003cFile\u003e javaFiles \u003d JavaParser.findJavaFiles(testDir);\r\n\r\n        System.out.println(\"\\n\u003d\u003d\u003d JAVA FILES IN DIRECTORY \u003d\u003d\u003d\");\r\n        System.out.println(\"Found \" + javaFiles.size() + \" Java files:\");\r\n\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            writer.println(\"\\n\u003d\u003d\u003d JAVA FILES IN DIRECTORY \u003d\u003d\u003d\");\r\n            writer.println(\"Found \" + javaFiles.size() + \" Java files:\");\r\n\r\n            for (File file : javaFiles) {\r\n                System.out.println(file.getName());\r\n                writer.println(file.getName());\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }",
          "comments": [
            "Optional: Add test for finding all Java files in a directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            writer.println(\"\\n\u003d\u003d\u003d JAVA FILES IN DIRECTORY \u003d\u003d\u003d\");\r\n            writer.println(\"Found \" + javaFiles.size() + \" Java files:\");\r\n\r\n            for (File file : javaFiles) {\r\n                System.out.println(file.getName());\r\n                writer.println(file.getName());\r\n            }\r\n        }",
          "comments": [
            "Optional: Add test for finding all Java files in a directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            writer.println(\"\\n\u003d\u003d\u003d JAVA FILES IN DIRECTORY \u003d\u003d\u003d\");\r\n            writer.println(\"Found \" + javaFiles.size() + \" Java files:\");\r\n\r\n            for (File file : javaFiles) {\r\n                System.out.println(file.getName());\r\n                writer.println(file.getName());\r\n            }\r\n        }",
          "comments": []
        }
      ],
      "className": "JavaParserTest",
      "packageName": "io.joshuasalcedo.parsers"
    },
    "src/main/java/io/joshuasalcedo/model/git/GitRepositoryInfo.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/git/GitRepositoryInfo.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "repository",
          "parameters": [
            {
              "type": "earliest",
              "name": "commit"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "List of top contributors.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "repository",
          "parameters": [
            {
              "type": "latest",
              "name": "commit"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Creation date of the repository (earliest commit).",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "GitRepositoryInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    "src/main/java/io/joshuasalcedo/ParserRunner.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/ParserRunner.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "main",
          "parameters": [
            {
              "type": "String[]",
              "name": "args"
            }
          ],
          "body": "{\r\n        if (args.length \u003d\u003d 0) {\r\n            printWarning(\"No arguments provided. Use \u0027help\u0027 for usage information.\");\r\n            help();\r\n            return;\r\n        }\r\n\r\n        String command \u003d args[0];\r\n\r\n        switch (command) {\r\n            case \"help\":\r\n                help();\r\n                break;\r\n            case \"version\":\r\n                showVersion();\r\n                break;\r\n            case \"all\":\r\n            case \"java\":\r\n            case \"git\":\r\n            case \"pom\":\r\n            case \"html\":\r\n            case \"markdown\":\r\n                handleParserCommand(command, args);\r\n                break;\r\n            default:\r\n                // Assume it\u0027s a file path and try to parse it based on extension\r\n                parseFile(command);\r\n                break;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "extension",
          "methodName": "parseFile",
          "parameters": [],
          "body": "{\r\n        // Handle special cases for paths\r\n        if (path.equals(\".\")) {\r\n            // Current directory\r\n            return System.getProperty(\"user.dir\");\r\n        } else if (path.startsWith(\"./\") || path.startsWith(\".\\\\\")) {\r\n            // Relative path starting with ./\r\n            return new File(System.getProperty(\"user.dir\"), path.substring(2)).getAbsolutePath();\r\n        } else if (!new File(path).isAbsolute()) {\r\n            // Any other relative path\r\n            return new File(System.getProperty(\"user.dir\"), path).getAbsolutePath();\r\n        }\r\n\r\n        // Already an absolute path\r\n        return path;\r\n    }",
          "comments": [
            "Assume it\u0027s a file path and try to parse it based on extension"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "String",
          "methodName": "resolvePath",
          "parameters": [
            {
              "type": "String",
              "name": "path"
            }
          ],
          "body": "{\r\n        // Handle special cases for paths\r\n        if (path.equals(\".\")) {\r\n            // Current directory\r\n            return System.getProperty(\"user.dir\");\r\n        } else if (path.startsWith(\"./\") || path.startsWith(\".\\\\\")) {\r\n            // Relative path starting with ./\r\n            return new File(System.getProperty(\"user.dir\"), path.substring(2)).getAbsolutePath();\r\n        } else if (!new File(path).isAbsolute()) {\r\n            // Any other relative path\r\n            return new File(System.getProperty(\"user.dir\"), path).getAbsolutePath();\r\n        }\r\n\r\n        // Already an absolute path\r\n        return path;\r\n    }",
          "javadoc": {
            "description": "Resolves a path to an absolute path, handling special cases\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to resolve"
              },
              {
                "name": "return",
                "value": "The resolved absolute path"
              }
            ]
          },
          "comments": [
            "Handle special cases for paths"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "paths",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            // Current directory\r\n            return System.getProperty(\"user.dir\");\r\n        }",
          "javadoc": {
            "description": "Resolves a path to an absolute path, handling special cases\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to resolve"
              },
              {
                "name": "return",
                "value": "The resolved absolute path"
              }
            ]
          },
          "comments": [
            "Handle special cases for paths",
            "Current directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            // Relative path starting with ./\r\n            return new File(System.getProperty(\"user.dir\"), path.substring(2)).getAbsolutePath();\r\n        }",
          "javadoc": {
            "description": "Resolves a path to an absolute path, handling special cases\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to resolve"
              },
              {
                "name": "return",
                "value": "The resolved absolute path"
              }
            ]
          },
          "comments": [
            "Handle special cases for paths",
            "Current directory",
            "Relative path starting"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            // Any other relative path\r\n            return new File(System.getProperty(\"user.dir\"), path).getAbsolutePath();\r\n        }",
          "comments": [
            "Relative path starting with ./"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [
            {
              "type": "!new",
              "name": "File(path"
            }
          ],
          "body": "{\r\n            // Any other relative path\r\n            return new File(System.getProperty(\"user.dir\"), path).getAbsolutePath();\r\n        }",
          "comments": [
            "Relative path starting with ./",
            "Any other relative path"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            // Any other relative path\r\n            return new File(System.getProperty(\"user.dir\"), path).getAbsolutePath();\r\n        }",
          "comments": [
            "Any other relative path",
            "Already"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "handleParserCommand",
          "parameters": [
            {
              "type": "String",
              "name": "command"
            },
            {
              "type": "String[]",
              "name": "args"
            }
          ],
          "body": "{\r\n        if (args.length \u003c 2) {\r\n            printError(\"Please provide a directory path.\");\r\n            return;\r\n        }\r\n\r\n        String directory \u003d resolvePath(args[1]);\r\n\r\n        // Log the resolved directory path for debugging\r\n        printInfo(\"Resolved directory path: \" + directory);\r\n\r\n        executeParser(command, directory);\r\n    }",
          "javadoc": {
            "description": "Handles parser commands that require a directory path\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "command The command to execute"
              },
              {
                "name": "param",
                "value": "args Command-line arguments"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "debugging",
          "methodName": "printInfo",
          "parameters": [
            {
              "type": "\"Resolved",
              "name": "directory"
            }
          ],
          "body": "{\r\n        String title \u003d COMMAND_TITLES.getOrDefault(command, \"PARSING \" + command.toUpperCase());\r\n        System.out.println(ConsoleFormatterFactory.createDivider(title));\r\n\r\n        printInfo(\"Parsing \" + (command.equals(\"git\") ? \"Git repository\" : command + \" files\") + \" in: \" + directory);\r\n\r\n        try {\r\n            File dir \u003d new File(directory);\r\n            if (!validateDirectory(dir)) {\r\n                return;\r\n            }\r\n\r\n            // Get the parser function from the map and execute it\r\n            Function\u003cString, Map\u003cString, Object\u003e\u003e parserFunction \u003d PARSER_FUNCTIONS.get(command);\r\n            if (parserFunction \u003d\u003d null) {\r\n                printError(\"Unknown parser command: \" + command);\r\n                return;\r\n            }\r\n\r\n            Map\u003cString, Object\u003e result \u003d parserFunction.apply(directory);\r\n            String outputPath \u003d saveResultToJsonFile(result, directory, command);\r\n            outputResult(result, outputPath);\r\n\r\n        } catch (Exception e) {\r\n            printError(\"Error executing parser: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Handles parser commands that require a directory path\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "command The command to execute"
              },
              {
                "name": "param",
                "value": "args Command-line arguments"
              }
            ]
          },
          "comments": [
            "Log the resolved directory path for debugging"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "executeParser",
          "parameters": [
            {
              "type": "String",
              "name": "command"
            },
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n        String title \u003d COMMAND_TITLES.getOrDefault(command, \"PARSING \" + command.toUpperCase());\r\n        System.out.println(ConsoleFormatterFactory.createDivider(title));\r\n\r\n        printInfo(\"Parsing \" + (command.equals(\"git\") ? \"Git repository\" : command + \" files\") + \" in: \" + directory);\r\n\r\n        try {\r\n            File dir \u003d new File(directory);\r\n            if (!validateDirectory(dir)) {\r\n                return;\r\n            }\r\n\r\n            // Get the parser function from the map and execute it\r\n            Function\u003cString, Map\u003cString, Object\u003e\u003e parserFunction \u003d PARSER_FUNCTIONS.get(command);\r\n            if (parserFunction \u003d\u003d null) {\r\n                printError(\"Unknown parser command: \" + command);\r\n                return;\r\n            }\r\n\r\n            Map\u003cString, Object\u003e result \u003d parserFunction.apply(directory);\r\n            String outputPath \u003d saveResultToJsonFile(result, directory, command);\r\n            outputResult(result, outputPath);\r\n\r\n        } catch (Exception e) {\r\n            printError(\"Error executing parser: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Execute a parser based on the command name and directory\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "command The command name"
              },
              {
                "name": "param",
                "value": "directory The directory to parse"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                return;\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "validateDirectory",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            }
          ],
          "body": "{\r\n        if (!directory.exists() || !directory.isDirectory() || !directory.canRead()) {\r\n            printError(\"Directory does not exist or is not readable: \" + directory);\r\n            return false;\r\n        }\r\n        return true;\r\n    }",
          "javadoc": {
            "description": "Validates if a directory exists and is a directory\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to validate"
              },
              {
                "name": "return",
                "value": "true if directory is valid, false otherwise"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "parseFile",
          "parameters": [
            {
              "type": "String",
              "name": "filePath"
            }
          ],
          "body": "{\r\n        // Resolve the file path\r\n        filePath \u003d resolvePath(filePath);\r\n\r\n        // Log the resolved file path for debugging\r\n        printInfo(\"Resolved file path: \" + filePath);\r\n\r\n        File file \u003d new File(filePath);\r\n        if (!FileUtils.isFileReadable(file)) {\r\n            printError(\"File does not exist or is not readable: \" + filePath);\r\n            return;\r\n        }\r\n\r\n        String fileName \u003d file.getName().toLowerCase();\r\n        String parserType \u003d determineParserType(fileName);\r\n\r\n        if (parserType \u003d\u003d null) {\r\n            printError(\"Unsupported file type: \" + fileName);\r\n            return;\r\n        }\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"PARSING \" + parserType.toUpperCase() + \" FILE\"));\r\n        printWarning(parserType + \" file parsing not implemented for single files yet.\");\r\n    }",
          "javadoc": {
            "description": "Parse a single file based on its extension\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "filePath Path to the file"
              }
            ]
          },
          "comments": [
            "Resolve the file path"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "debugging",
          "methodName": "printInfo",
          "parameters": [
            {
              "type": "\"Resolved",
              "name": "file"
            }
          ],
          "body": "{\r\n            printError(\"File does not exist or is not readable: \" + filePath);\r\n            return;\r\n        }",
          "javadoc": {
            "description": "Parse a single file based on its extension\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "filePath Path to the file"
              }
            ]
          },
          "comments": [
            "Resolve the file path",
            "Log the resolved file path for debugging"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            printError(\"File does not exist or is not readable: \" + filePath);\r\n            return;\r\n        }",
          "javadoc": {
            "description": "Parse a single file based on its extension\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "filePath Path to the file"
              }
            ]
          },
          "comments": [
            "Resolve the file path",
            "Log the resolved file path for debugging"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "String",
          "methodName": "determineParserType",
          "parameters": [
            {
              "type": "String",
              "name": "fileName"
            }
          ],
          "body": "{\r\n        if (fileName.endsWith(\".java\")) {\r\n            return \"java\";\r\n        } else if (fileName.endsWith(\".html\") || fileName.endsWith(\".htm\")) {\r\n            return \"html\";\r\n        } else if (fileName.equals(\"pom.xml\")) {\r\n            return \"pom\";\r\n        } else if (fileName.endsWith(\".md\") || fileName.endsWith(\".markdown\")) {\r\n            return \"markdown\";\r\n        }\r\n        return null;\r\n    }",
          "javadoc": {
            "description": "Determine the parser type based on file name\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "fileName The file name"
              },
              {
                "name": "return",
                "value": "The parser type or null if unsupported"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            return \"html\";\r\n        }",
          "javadoc": {
            "description": "Determine the parser type based on file name\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "fileName The file name"
              },
              {
                "name": "return",
                "value": "The parser type or null if unsupported"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            return \"pom\";\r\n        }",
          "javadoc": {
            "description": "Determine the parser type based on file name\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "fileName The file name"
              },
              {
                "name": "return",
                "value": "The parser type or null if unsupported"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            return \"markdown\";\r\n        }",
          "javadoc": {
            "description": "Determine the parser type based on file name\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "fileName The file name"
              },
              {
                "name": "return",
                "value": "The parser type or null if unsupported"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parser",
          "methodName": "used",
          "parameters": [],
          "body": "{\r\n        // Use JsonUtils to convert the result to pretty JSON\r\n        String json \u003d JsonUtils.toPrettyJson(result);\r\n\r\n        // Create output filename\r\n        String filename \u003d String.format(\"parser_%s.json\", parserType);\r\n\r\n        // Create .parsed directory where the command is executed\r\n        File parsedDir \u003d createOutputDirectory();\r\n\r\n        // Create the output file in the .parsed directory\r\n        return writeJsonToFile(json, parsedDir, filename);\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "String",
          "methodName": "saveResultToJsonFile",
          "parameters": [
            {
              "type": "Object\u003e",
              "name": "result"
            },
            {
              "type": "String",
              "name": "directory"
            },
            {
              "type": "String",
              "name": "parserType"
            }
          ],
          "body": "{\r\n        // Use JsonUtils to convert the result to pretty JSON\r\n        String json \u003d JsonUtils.toPrettyJson(result);\r\n\r\n        // Create output filename\r\n        String filename \u003d String.format(\"parser_%s.json\", parserType);\r\n\r\n        // Create .parsed directory where the command is executed\r\n        File parsedDir \u003d createOutputDirectory();\r\n\r\n        // Create the output file in the .parsed directory\r\n        return writeJsonToFile(json, parsedDir, filename);\r\n    }",
          "javadoc": {
            "description": "Save parsing results to a JSON file in the .parsed directory\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "result The parsing result map"
              },
              {
                "name": "param",
                "value": "directory The directory that was parsed"
              },
              {
                "name": "param",
                "value": "parserType The type of parser used (all, java, git, etc.)"
              },
              {
                "name": "return",
                "value": "The path to the saved JSON file"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "writeJsonToFile",
          "parameters": [],
          "body": "{\r\n        File currentDirectory \u003d new File(\".\");\r\n        File parsedDir \u003d new File(currentDirectory, \".parsed\");\r\n\r\n        // Create the directory if it doesn\u0027t exist\r\n        if (!parsedDir.exists()) {\r\n            if (!FileUtils.createDirectoriesForFile(new File(parsedDir, \"dummy.txt\"))) {\r\n                printWarning(\"Failed to create .parsed directory. Using current directory instead.\");\r\n                parsedDir \u003d currentDirectory;\r\n            }\r\n        }\r\n\r\n        return parsedDir;\r\n    }",
          "comments": [
            "Create .parsed directory where the command is executed",
            "Create the output file in the .parsed directory"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "File",
          "methodName": "createOutputDirectory",
          "parameters": [],
          "body": "{\r\n        File currentDirectory \u003d new File(\".\");\r\n        File parsedDir \u003d new File(currentDirectory, \".parsed\");\r\n\r\n        // Create the directory if it doesn\u0027t exist\r\n        if (!parsedDir.exists()) {\r\n            if (!FileUtils.createDirectoriesForFile(new File(parsedDir, \"dummy.txt\"))) {\r\n                printWarning(\"Failed to create .parsed directory. Using current directory instead.\");\r\n                parsedDir \u003d currentDirectory;\r\n            }\r\n        }\r\n\r\n        return parsedDir;\r\n    }",
          "javadoc": {
            "description": "Creates the output directory for storing results\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The created directory or current directory as fallback"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            if (!FileUtils.createDirectoriesForFile(new File(parsedDir, \"dummy.txt\"))) {\r\n                printWarning(\"Failed to create .parsed directory. Using current directory instead.\");\r\n                parsedDir \u003d currentDirectory;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Creates the output directory for storing results\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The created directory or current directory as fallback"
              }
            ]
          },
          "comments": [
            "Creat"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            if (!FileUtils.createDirectoriesForFile(new File(parsedDir, \"dummy.txt\"))) {\r\n                printWarning(\"Failed to create .parsed directory. Using current directory instead.\");\r\n                parsedDir \u003d currentDirectory;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Creates the output directory for storing results\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The created directory or current directory as fallback"
              }
            ]
          },
          "comments": [
            "Create the directory if it doesn\u0027t exist"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "exist",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            if (!FileUtils.createDirectoriesForFile(new File(parsedDir, \"dummy.txt\"))) {\r\n                printWarning(\"Failed to create .parsed directory. Using current directory instead.\");\r\n                parsedDir \u003d currentDirectory;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Creates the output directory for storing results\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The created directory or current directory as fallback"
              }
            ]
          },
          "comments": [
            "Create the directory if it doesn\u0027t exist"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                printWarning(\"Failed to create .parsed directory. Using current directory instead.\");\r\n                parsedDir \u003d currentDirectory;\r\n            }",
          "javadoc": {
            "description": "Creates the output directory for storing results\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The created directory or current directory as fallback"
              }
            ]
          },
          "comments": [
            "Create the directory if it doesn\u0027t exist"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "String",
          "methodName": "writeJsonToFile",
          "parameters": [
            {
              "type": "String",
              "name": "json"
            },
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "String",
              "name": "filename"
            }
          ],
          "body": "{\r\n        File outputFile \u003d new File(directory, filename);\r\n\r\n        try {\r\n            FileUtils.writeStringToFile(outputFile, json);\r\n            return outputFile.getAbsolutePath();\r\n        } catch (IOException e) {\r\n            printError(\"Error saving JSON to file: \" + e.getMessage());\r\n\r\n            // Fallback to saving in the current directory\r\n            try {\r\n                outputFile \u003d new File(filename);\r\n                FileUtils.writeStringToFile(outputFile, json);\r\n                return outputFile.getAbsolutePath();\r\n            } catch (IOException ex) {\r\n                printError(\"Failed to save JSON file in fallback location: \" + ex.getMessage());\r\n                return null;\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Write JSON content to a file\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "json The JSON content to write"
              },
              {
                "name": "param",
                "value": "directory The directory to write to"
              },
              {
                "name": "param",
                "value": "filename The filename to use"
              },
              {
                "name": "return",
                "value": "The path to the saved file or null if failed"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            FileUtils.writeStringToFile(outputFile, json);\r\n            return outputFile.getAbsolutePath();\r\n        }",
          "javadoc": {
            "description": "Write JSON content to a file\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "json The JSON content to write"
              },
              {
                "name": "param",
                "value": "directory The directory to write to"
              },
              {
                "name": "param",
                "value": "filename The filename to use"
              },
              {
                "name": "return",
                "value": "The path to the saved file or null if failed"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                printError(\"Failed to save JSON file in fallback location: \" + ex.getMessage());\r\n                return null;\r\n            }",
          "comments": [
            "Fallback to saving in the current directory"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "outputResult",
          "parameters": [
            {
              "type": "Object\u003e",
              "name": "result"
            },
            {
              "type": "String",
              "name": "outputPath"
            }
          ],
          "body": "{\r\n        // Use JsonUtils to convert the result to pretty JSON\r\n        String json \u003d JsonUtils.toPrettyJson(result);\r\n\r\n        // Print the results to console\r\n        printSuccess(\"Results:\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(json, MessageType.DOC_CODE));\r\n\r\n        // Print information about saved file\r\n        if (outputPath !\u003d null) {\r\n            System.out.println(ConsoleFormatterFactory.createDivider(\"OUTPUT FILE\"));\r\n            printSuccess(\"Results saved to: \" + outputPath);\r\n        }\r\n    }",
          "javadoc": {
            "description": "Output the parsing results to console and show file save location\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "result The parsing results"
              },
              {
                "name": "param",
                "value": "outputPath The path where results were saved"
              }
            ]
          },
          "comments": [
            "Use Js"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "console",
          "methodName": "printSuccess",
          "parameters": [],
          "body": "{\r\n            System.out.println(ConsoleFormatterFactory.createDivider(\"OUTPUT FILE\"));\r\n            printSuccess(\"Results saved to: \" + outputPath);\r\n        }",
          "javadoc": {
            "description": "Output the parsing results to console and show file save location\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "result The parsing results"
              },
              {
                "name": "param",
                "value": "outputPath The path where results were saved"
              }
            ]
          },
          "comments": [
            "Use JsonUtils to convert the result to pretty JSON",
            "Print the results to console"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "file",
          "methodName": "if",
          "parameters": [
            {
              "type": "outputPath",
              "name": "!\u003d"
            }
          ],
          "body": "{\r\n            System.out.println(ConsoleFormatterFactory.createDivider(\"OUTPUT FILE\"));\r\n            printSuccess(\"Results saved to: \" + outputPath);\r\n        }",
          "comments": [
            "Print information about saved file"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "showVersion",
          "parameters": [],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createBox(\"Java Structure Parser v1.0\", MessageType.UI_HEADER));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Copyright © 2024 Joshua Salcedo\", MessageType.UI_SUBHEADER));\r\n    }",
          "javadoc": {
            "description": "Print version information",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "help",
          "parameters": [],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createBox(\"JAVA STRUCTURE PARSER\", MessageType.UI_HEADER));\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"USAGE\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar [command] [arguments]\", MessageType.DOC_CODE));\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"COMMANDS\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"help\", MessageType.UI_LABEL) + \"        - Show this help message\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"version\", MessageType.UI_LABEL) + \"     - Show version information\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"all\", MessageType.UI_LABEL) + \" [dir]   - Parse all supported files in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java\", MessageType.UI_LABEL) + \" [dir]  - Parse Java files in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"git\", MessageType.UI_LABEL) + \" [dir]   - Parse Git repository in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"pom\", MessageType.UI_LABEL) + \" [dir]   - Parse POM files in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"html\", MessageType.UI_LABEL) + \" [dir]  - Parse HTML files in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"markdown\", MessageType.UI_LABEL) + \" [dir] - Parse Markdown files in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"[file]\", MessageType.UI_LABEL) + \"      - Parse the specified file based on its extension\");\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"EXAMPLES\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar help\", MessageType.DOC_CODE));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar all /path/to/project\", MessageType.DOC_CODE));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar java /path/to/project\", MessageType.DOC_CODE));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar pom.xml\", MessageType.DOC_CODE));\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"NOTES\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"The parser outputs results as JSON both in the console and saves to a file in the parsed directory.\", MessageType.DOC_NOTE));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Output files are named \u0027parser_[type].json\u0027\", MessageType.DOC_NOTE));\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"LICENSE\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Copyright © 2024 Joshua Salcedo\", MessageType.SUCCESS));\r\n    }",
          "javadoc": {
            "description": "Print help documentation",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "printInfo",
          "parameters": [
            {
              "type": "String",
              "name": "message"
            }
          ],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createMessage(message, MessageType.INFO));\r\n    }",
          "comments": [
            "Utility methods for consistent message formatting"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "printError",
          "parameters": [
            {
              "type": "String",
              "name": "message"
            }
          ],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createMessage(message, MessageType.ERROR));\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "printWarning",
          "parameters": [
            {
              "type": "String",
              "name": "message"
            }
          ],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createMessage(message, MessageType.WARNING));\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "printSuccess",
          "parameters": [
            {
              "type": "String",
              "name": "message"
            }
          ],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createMessage(message, MessageType.SUCCESS));\r\n    }",
          "comments": []
        }
      ],
      "className": "ParserRunner",
      "packageName": "io.joshuasalcedo"
    },
    "src/main/java/io/joshuasalcedo/model/git/BranchInfo.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/git/BranchInfo.java",
      "methods": [],
      "className": "BranchInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    "src/main/java/io/joshuasalcedo/parsers/Parser.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/parsers/Parser.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "all",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Check if directory exists\r\n                File dir \u003d new File(directory);\r\n                if (!validateDirectory(dir, result)) {\r\n                    return result;\r\n                }\r\n\r\n                // Parse Git repository if it\u0027s a valid Git repository\r\n                parseGitRepository(directory, result);\r\n\r\n                // List all files in the directory respecting .gitignore\r\n                List\u003cFile\u003e files \u003d listAllFiles(directory, dir);\r\n\r\n                // Parse different file types\r\n                Map\u003cString, List\u003cFile\u003e\u003e filesByType \u003d categorizeFiles(files);\r\n\r\n                List\u003cFile\u003e pomFiles \u003d filesByType.getOrDefault(\"pom\", new ArrayList\u003c\u003e());\r\n                List\u003cFile\u003e javaFiles \u003d filesByType.getOrDefault(\"java\", new ArrayList\u003c\u003e());\r\n                List\u003cFile\u003e htmlFiles \u003d filesByType.getOrDefault(\"html\", new ArrayList\u003c\u003e());\r\n                List\u003cFile\u003e markdownFiles \u003d filesByType.getOrDefault(\"markdown\", new ArrayList\u003c\u003e());\r\n\r\n                // Parse each file type\r\n                result.putAll(parsePomFiles(pomFiles, directory));\r\n                result.putAll(parseJavaFiles(javaFiles, directory));\r\n                result.putAll(parseHtmlFiles(htmlFiles));\r\n                result.putAll(parseMarkdownFiles(markdownFiles));\r\n\r\n                // Add file statistics\r\n                Map\u003cString, Object\u003e fileStats \u003d new HashMap\u003c\u003e();\r\n                fileStats.put(\"totalFiles\", files.size());\r\n                fileStats.put(\"pomFiles\", pomFiles.size());\r\n                fileStats.put(\"javaFiles\", javaFiles.size());\r\n                fileStats.put(\"htmlFiles\", htmlFiles.size());\r\n                fileStats.put(\"markdownFiles\", markdownFiles.size());\r\n                result.put(\"fileStatistics\", fileStats);\r\n\r\n                return result;\r\n            } catch (Exception e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse directory: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse a directory and extract all available information using all parsers.\r\nThis method respects .gitignore rules when listing files.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory to parse"
              },
              {
                "name": "return",
                "value": "Map containing all parsed information"
              }
            ]
          },
          "comments": [
            "Cre"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Check if directory exists"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "repository",
          "methodName": "parseGitRepository",
          "parameters": [],
          "body": "{\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse directory: \" + e.getMessage());\r\n                return error;\r\n            }",
          "comments": [
            "Parse Git repository if it\u0027s a valid Git repository",
            "List all f"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "git",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Parse Git repository\r\n                File dir \u003d new File(directory);\r\n                if (dir.exists() \u0026\u0026 dir.isDirectory()) {\r\n                    boolean isValidRepo \u003d parseGitRepository(directory, result);\r\n                    if (!isValidRepo) {\r\n                        result.put(\"error\", \"Not a valid Git repository: \" + directory);\r\n                    }\r\n                } else {\r\n                    result.put(\"error\", \"Directory does not exist: \" + directory);\r\n                }\r\n\r\n                return result;\r\n            } catch (IOException | GitAPIException e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse Git repository: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse a Git repository and return a Map containing the repository information.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory containing the Git repository"
              },
              {
                "name": "return",
                "value": "Map containing the parsed Git repository information"
              }
            ]
          },
          "comments": [
            "Cre"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Parse Git repository"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "java",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Find all Java files in the directory\r\n                File dir \u003d new File(directory);\r\n                if (!validateDirectory(dir, result)) {\r\n                    return result;\r\n                }\r\n\r\n                List\u003cFile\u003e javaFiles \u003d new ArrayList\u003c\u003e();\r\n                JavaParser.findJavaFiles(dir).forEach(javaFiles::add);\r\n\r\n                result.putAll(parseJavaFiles(javaFiles, directory));\r\n                return result;\r\n            } catch (Exception e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse Java files: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse Java files in a directory and return a Map containing the Java code structure.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory containing Java files"
              },
              {
                "name": "return",
                "value": "Map containing the parsed Java files information"
              }
            ]
          },
          "comments": [
            "Cr"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Find all Java files in the directory"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "pom",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Find all POM files in the directory\r\n                File dir \u003d new File(directory);\r\n                if (!validateDirectory(dir, result)) {\r\n                    return result;\r\n                }\r\n\r\n                List\u003cFile\u003e pomFiles \u003d PomParser.findPomFiles(dir);\r\n                result.putAll(parsePomFiles(pomFiles, directory));\r\n                return result;\r\n            } catch (Exception e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse POM files: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse POM files in a directory and return a Map containing the Maven project information.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory containing POM files"
              },
              {
                "name": "return",
                "value": "Map containing the parsed POM files information"
              }
            ]
          },
          "comments": [
            "Cre"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Find all POM files in the directory"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "html",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Find all HTML files in the directory\r\n                File dir \u003d new File(directory);\r\n                if (!validateDirectory(dir, result)) {\r\n                    return result;\r\n                }\r\n\r\n                List\u003cFile\u003e htmlFiles \u003d new ArrayList\u003c\u003e();\r\n                listFilesRecursive(dir, htmlFiles, \".html\", \".htm\");\r\n\r\n                result.putAll(parseHtmlFiles(htmlFiles));\r\n                return result;\r\n            } catch (Exception e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse HTML files: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse HTML files in a directory and return a Map containing the HTML structure.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory containing HTML files"
              },
              {
                "name": "return",
                "value": "Map containing the parsed HTML files information"
              }
            ]
          },
          "comments": [
            "Cr"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Find all HTML files in the directory"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "markdown",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Find all Markdown files in the directory\r\n                File dir \u003d new File(directory);\r\n                if (!validateDirectory(dir, result)) {\r\n                    return result;\r\n                }\r\n\r\n                List\u003cFile\u003e markdownFiles \u003d new ArrayList\u003c\u003e();\r\n                listFilesRecursive(dir, markdownFiles, \".md\", \".markdown\");\r\n\r\n                result.putAll(parseMarkdownFiles(markdownFiles));\r\n                return result;\r\n            } catch (Exception e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse Markdown files: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse Markdown files in a directory and return a Map containing Markdown content information.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory containing Markdown files"
              },
              {
                "name": "return",
                "value": "Map containing the parsed Markdown files information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Find all Markdown files in the directory"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "validateDirectory",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "Object\u003e",
              "name": "result"
            }
          ],
          "body": "{\r\n        if (!directory.exists() || !directory.isDirectory()) {\r\n            result.put(\"error\", \"Directory does not exist or is not a directory: \" + directory);\r\n            return false;\r\n        }\r\n        return true;\r\n    }",
          "javadoc": {
            "description": "Validates if a directory exists and is actually a directory.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to validate"
              },
              {
                "name": "param",
                "value": "result The result map to store error if validation fails"
              },
              {
                "name": "return",
                "value": "boolean indicating whether the directory is valid"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "parseGitRepository",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            },
            {
              "type": "Object\u003e",
              "name": "result"
            }
          ],
          "body": "{\r\n        if (GitParser.isValidRepository(directory)) {\r\n            GitRepositoryInfo repoInfo \u003d GitParser.parseRepository(directory);\r\n            result.put(\"gitRepository\", repoInfo);\r\n            return true;\r\n        }\r\n        return false;\r\n    }",
          "javadoc": {
            "description": "Parse Git repository information and add it to the result map.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory path of the Git repository"
              },
              {
                "name": "param",
                "value": "result The result map to store the Git repository information"
              },
              {
                "name": "return",
                "value": "boolean indicating whether the repository was successfully parsed"
              },
              {
                "name": "throws",
                "value": "IOException If an I/O error occurs"
              },
              {
                "name": "throws",
                "value": "GitAPIException If a Git operation fails"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "listAllFiles",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            },
            {
              "type": "File",
              "name": "dir"
            }
          ],
          "body": "{\r\n        List\u003cFile\u003e files;\r\n        try {\r\n            files \u003d GitParser.listFilesRespectingGitignore(directory);\r\n        } catch (IOException e) {\r\n            // If there\u0027s an error listing files with .gitignore, fall back to listing all files\r\n            files \u003d new ArrayList\u003c\u003e();\r\n            listFilesRecursive(dir, files);\r\n        }\r\n        return files;\r\n    }",
          "javadoc": {
            "description": "List all files in a directory, respecting .gitignore rules if possible.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory path to search"
              },
              {
                "name": "param",
                "value": "dir The directory File object"
              },
              {
                "name": "return",
                "value": "List of files found"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, List\u003cFile\u003e\u003e",
          "methodName": "categorizeFiles",
          "parameters": [
            {
              "type": "List\u003cFile\u003e",
              "name": "files"
            }
          ],
          "body": "{\r\n        Map\u003cString, List\u003cFile\u003e\u003e filesByType \u003d new HashMap\u003c\u003e();\r\n        filesByType.put(\"pom\", new ArrayList\u003c\u003e());\r\n        filesByType.put(\"java\", new ArrayList\u003c\u003e());\r\n        filesByType.put(\"html\", new ArrayList\u003c\u003e());\r\n        filesByType.put(\"markdown\", new ArrayList\u003c\u003e());\r\n\r\n        for (File file : files) {\r\n            String name \u003d file.getName().toLowerCase();\r\n            if (file.getName().equals(\"pom.xml\")) {\r\n                filesByType.get(\"pom\").add(file);\r\n            } else if (name.endsWith(\".java\")) {\r\n                filesByType.get(\"java\").add(file);\r\n            } else if (name.endsWith(\".html\") || name.endsWith(\".htm\")) {\r\n                filesByType.get(\"html\").add(file);\r\n            } else if (name.endsWith(\".md\") || name.endsWith(\".markdown\")) {\r\n                filesByType.get(\"markdown\").add(file);\r\n            }\r\n        }\r\n        return filesByType;\r\n    }",
          "javadoc": {
            "description": "Categorize files by type for further processing.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "files List of files to categorize"
              },
              {
                "name": "return",
                "value": "Map of file lists by type"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                filesByType.get(\"java\").add(file);\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                filesByType.get(\"html\").add(file);\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                filesByType.get(\"markdown\").add(file);\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "parsePomFiles",
          "parameters": [
            {
              "type": "List\u003cFile\u003e",
              "name": "pomFiles"
            },
            {
              "type": "String",
              "name": "baseDirectory"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n        if (pomFiles.isEmpty()) {\r\n            return result;\r\n        }\r\n\r\n        Map\u003cString, Object\u003e pomFileMap \u003d new HashMap\u003c\u003e();\r\n        File baseDir \u003d new File(baseDirectory);\r\n\r\n        for (File pomFile : pomFiles) {\r\n            try {\r\n                // Get relative path from base directory\r\n                String relativePath \u003d baseDir.toURI().relativize(pomFile.toURI()).getPath();\r\n\r\n                Model model \u003d PomParser.parsePom(pomFile);\r\n                Map\u003cString, Object\u003e pomInfo \u003d new HashMap\u003c\u003e();\r\n                pomInfo.put(\"path\", pomFile.getAbsolutePath());\r\n                pomInfo.put(\"groupId\", model.getGroupId());\r\n                pomInfo.put(\"artifactId\", model.getArtifactId());\r\n                pomInfo.put(\"version\", model.getVersion());\r\n                pomInfo.put(\"name\", model.getName());\r\n                pomInfo.put(\"description\", model.getDescription());\r\n\r\n                // Add dependencies\r\n                List\u003cMap\u003cString, String\u003e\u003e dependencies \u003d new ArrayList\u003c\u003e();\r\n                for (org.apache.maven.api.model.Dependency dependency : model.getDependencies()) {\r\n                    Map\u003cString, String\u003e dep \u003d new HashMap\u003c\u003e();\r\n                    dep.put(\"groupId\", dependency.getGroupId());\r\n                    dep.put(\"artifactId\", dependency.getArtifactId());\r\n                    dep.put(\"version\", dependency.getVersion());\r\n                    dep.put(\"scope\", dependency.getScope());\r\n                    dependencies.add(dep);\r\n                }\r\n                pomInfo.put(\"dependencies\", dependencies);\r\n\r\n                // Use the relative path as the key\r\n                pomFileMap.put(relativePath, pomInfo);\r\n            } catch (Exception e) {\r\n                // Skip this POM file if there\u0027s an error\r\n                Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n                errorInfo.put(\"path\", pomFile.getAbsolutePath());\r\n                errorInfo.put(\"error\", \"Failed to parse POM file: \" + e.getMessage());\r\n                pomFileMap.put(\"error_\" + pomFile.getName(), errorInfo);\r\n            }\r\n        }\r\n\r\n        if (!pomFileMap.isEmpty()) {\r\n            result.put(\"pomFiles\", pomFileMap);\r\n        }\r\n        return result;\r\n    }",
          "javadoc": {
            "description": "Parse POM files and create a map of results.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFiles List of POM files to parse"
              },
              {
                "name": "return",
                "value": "Map containing parsed POM files information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            try {\r\n                // Get relative path from base directory\r\n                String relativePath \u003d baseDir.toURI().relativize(pomFile.toURI()).getPath();\r\n\r\n                Model model \u003d PomParser.parsePom(pomFile);\r\n                Map\u003cString, Object\u003e pomInfo \u003d new HashMap\u003c\u003e();\r\n                pomInfo.put(\"path\", pomFile.getAbsolutePath());\r\n                pomInfo.put(\"groupId\", model.getGroupId());\r\n                pomInfo.put(\"artifactId\", model.getArtifactId());\r\n                pomInfo.put(\"version\", model.getVersion());\r\n                pomInfo.put(\"name\", model.getName());\r\n                pomInfo.put(\"description\", model.getDescription());\r\n\r\n                // Add dependencies\r\n                List\u003cMap\u003cString, String\u003e\u003e dependencies \u003d new ArrayList\u003c\u003e();\r\n                for (org.apache.maven.api.model.Dependency dependency : model.getDependencies()) {\r\n                    Map\u003cString, String\u003e dep \u003d new HashMap\u003c\u003e();\r\n                    dep.put(\"groupId\", dependency.getGroupId());\r\n                    dep.put(\"artifactId\", dependency.getArtifactId());\r\n                    dep.put(\"version\", dependency.getVersion());\r\n                    dep.put(\"scope\", dependency.getScope());\r\n                    dependencies.add(dep);\r\n                }\r\n                pomInfo.put(\"dependencies\", dependencies);\r\n\r\n                // Use the relative path as the key\r\n                pomFileMap.put(relativePath, pomInfo);\r\n            } catch (Exception e) {\r\n                // Skip this POM file if there\u0027s an error\r\n                Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n                errorInfo.put(\"path\", pomFile.getAbsolutePath());\r\n                errorInfo.put(\"error\", \"Failed to parse POM file: \" + e.getMessage());\r\n                pomFileMap.put(\"error_\" + pomFile.getName(), errorInfo);\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse POM files and create a map of results.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFiles List of POM files to parse"
              },
              {
                "name": "return",
                "value": "Map containing parsed POM files information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "parseJavaFiles",
          "parameters": [
            {
              "type": "List\u003cFile\u003e",
              "name": "javaFiles"
            },
            {
              "type": "String",
              "name": "baseDirectory"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n        if (javaFiles.isEmpty()) {\r\n            return result;\r\n        }\r\n\r\n        // Map to hold java file info by relative path\r\n        Map\u003cString, Object\u003e javaFileMap \u003d new HashMap\u003c\u003e();\r\n        File baseDir \u003d new File(baseDirectory);\r\n\r\n        for (File javaFile : javaFiles) {\r\n            try {\r\n                // Get relative path from base directory\r\n                String relativePath \u003d baseDir.toURI().relativize(javaFile.toURI()).getPath();\r\n\r\n                String content \u003d new String(Files.readAllBytes(javaFile.toPath()));\r\n                ClassStructure classStructure \u003d JavaParser.extractClassStructure(javaFile.getName(), content);\r\n\r\n                Map\u003cString, Object\u003e javaInfo \u003d new HashMap\u003c\u003e();\r\n                javaInfo.put(\"path\", javaFile.getAbsolutePath());\r\n                javaInfo.put(\"packageName\", classStructure.getPackageName());\r\n                javaInfo.put(\"className\", classStructure.getClassName());\r\n                javaInfo.put(\"methods\", classStructure.getMethods());\r\n\r\n                // Use the relative path as the key\r\n                javaFileMap.put(relativePath, javaInfo);\r\n            } catch (Exception e) {\r\n                // Skip this Java file if there\u0027s an error\r\n                Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n                errorInfo.put(\"path\", javaFile.getAbsolutePath());\r\n                errorInfo.put(\"error\", \"Failed to parse Java file: \" + e.getMessage());\r\n                javaFileMap.put(\"error_\" + javaFile.getName(), errorInfo);\r\n            }\r\n        }\r\n\r\n        // If we found Java files, add them to the result map\r\n        if (!javaFileMap.isEmpty()) {\r\n            result.put(\"javaFiles\", javaFileMap);\r\n        }\r\n\r\n        return result;\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            try {\r\n                // Get relative path from base directory\r\n                String relativePath \u003d baseDir.toURI().relativize(pomFile.toURI()).getPath();\r\n\r\n                Model model \u003d PomParser.parsePom(pomFile);\r\n                Map\u003cString, Object\u003e pomInfo \u003d new HashMap\u003c\u003e();\r\n                pomInfo.put(\"path\", pomFile.getAbsolutePath());\r\n                pomInfo.put(\"groupId\", model.getGroupId());\r\n                pomInfo.put(\"artifactId\", model.getArtifactId());\r\n                pomInfo.put(\"version\", model.getVersion());\r\n                pomInfo.put(\"name\", model.getName());\r\n                pomInfo.put(\"description\", model.getDescription());\r\n\r\n                // Add dependencies\r\n                List\u003cMap\u003cString, String\u003e\u003e dependencies \u003d new ArrayList\u003c\u003e();\r\n                for (org.apache.maven.api.model.Dependency dependency : model.getDependencies()) {\r\n                    Map\u003cString, String\u003e dep \u003d new HashMap\u003c\u003e();\r\n                    dep.put(\"groupId\", dependency.getGroupId());\r\n                    dep.put(\"artifactId\", dependency.getArtifactId());\r\n                    dep.put(\"version\", dependency.getVersion());\r\n                    dep.put(\"scope\", dependency.getScope());\r\n                    dependencies.add(dep);\r\n                }\r\n                pomInfo.put(\"dependencies\", dependencies);\r\n\r\n                // Use the relative path as the key\r\n                pomFileMap.put(relativePath, pomInfo);\r\n            } catch (Exception e) {\r\n                // Skip this POM file if there\u0027s an error\r\n                Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n                errorInfo.put(\"path\", pomFile.getAbsolutePath());\r\n                errorInfo.put(\"error\", \"Failed to parse POM file: \" + e.getMessage());\r\n                pomFileMap.put(\"error_\" + pomFile.getName(), errorInfo);\r\n            }\r\n        }",
          "comments": [
            "Map to hold java file info by relative path"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "String",
          "parameters": [],
          "body": "{\r\n                // Skip this Java file if there\u0027s an error\r\n                Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n                errorInfo.put(\"path\", javaFile.getAbsolutePath());\r\n                errorInfo.put(\"error\", \"Failed to parse Java file: \" + e.getMessage());\r\n                javaFileMap.put(\"error_\" + javaFile.getName(), errorInfo);\r\n            }",
          "comments": [
            "Get relative path from base directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "map",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            result.put(\"javaFiles\", javaFileMap);\r\n        }",
          "comments": [
            "If we found Java files, add them to the result map"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "parseHtmlFiles",
          "parameters": [
            {
              "type": "List\u003cFile\u003e",
              "name": "htmlFiles"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n        if (htmlFiles.isEmpty()) {\r\n            return result;\r\n        }\r\n\r\n        List\u003cMap\u003cString, Object\u003e\u003e htmlResults \u003d new ArrayList\u003c\u003e();\r\n\r\n        for (File htmlFile : htmlFiles) {\r\n            try {\r\n                Document document \u003d HtmlParser.parse(htmlFile, \"UTF-8\", \"\");\r\n\r\n                Map\u003cString, Object\u003e htmlInfo \u003d new HashMap\u003c\u003e();\r\n                htmlInfo.put(\"path\", htmlFile.getAbsolutePath());\r\n                htmlInfo.put(\"title\", document.title());\r\n                htmlInfo.put(\"headings\", HtmlParser.getHeadings(document).size());\r\n                htmlInfo.put(\"links\", HtmlParser.getLinks(document).size());\r\n                htmlInfo.put(\"images\", HtmlParser.getImages(document).size());\r\n                htmlInfo.put(\"metadata\", HtmlParser.getMetadata(document));\r\n\r\n                htmlResults.add(htmlInfo);\r\n            } catch (Exception e) {\r\n                // Skip this HTML file if there\u0027s an error\r\n                addErrorInfo(htmlResults, htmlFile, \"Failed to parse HTML file: \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        if (!htmlResults.isEmpty()) {\r\n            result.put(\"htmlFiles\", htmlResults);\r\n        }\r\n        return result;\r\n    }",
          "javadoc": {
            "description": "Parse HTML files and create a map of results.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "htmlFiles List of HTML files to parse"
              },
              {
                "name": "return",
                "value": "Map containing parsed HTML files information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "error",
          "methodName": "addErrorInfo",
          "parameters": [
            {
              "type": "\"Failed",
              "name": "to"
            }
          ],
          "body": "{\r\n            result.put(\"htmlFiles\", htmlResults);\r\n        }",
          "comments": [
            "Skip this HTML file if there\u0027s an error"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "parseMarkdownFiles",
          "parameters": [
            {
              "type": "List\u003cFile\u003e",
              "name": "markdownFiles"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n        if (markdownFiles.isEmpty()) {\r\n            return result;\r\n        }\r\n\r\n        List\u003cMap\u003cString, Object\u003e\u003e markdownResults \u003d new ArrayList\u003c\u003e();\r\n\r\n        for (File markdownFile : markdownFiles) {\r\n            try {\r\n                String content \u003d new String(Files.readAllBytes(markdownFile.toPath()));\r\n                MarkdownContent parsedContent \u003d MarkdownParser.parseMarkdown(content);\r\n\r\n                Map\u003cString, Object\u003e mdInfo \u003d createMarkdownInfo(markdownFile, parsedContent);\r\n                markdownResults.add(mdInfo);\r\n            } catch (Exception e) {\r\n                // Skip this Markdown file if there\u0027s an error\r\n                addErrorInfo(markdownResults, markdownFile, \"Failed to parse Markdown file: \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        if (!markdownResults.isEmpty()) {\r\n            result.put(\"markdownFiles\", markdownResults);\r\n        }\r\n        return result;\r\n    }",
          "javadoc": {
            "description": "Parse Markdown files and create a map of results.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdownFiles List of Markdown files to parse"
              },
              {
                "name": "return",
                "value": "Map containing parsed Markdown files information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "String",
          "parameters": [],
          "body": "{\r\n                // Skip this Markdown file if there\u0027s an error\r\n                addErrorInfo(markdownResults, markdownFile, \"Failed to parse Markdown file: \" + e.getMessage());\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "error",
          "methodName": "addErrorInfo",
          "parameters": [
            {
              "type": "\"Failed",
              "name": "to"
            }
          ],
          "body": "{\r\n            result.put(\"markdownFiles\", markdownResults);\r\n        }",
          "comments": [
            "Skip this Markdown file if there\u0027s an error"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "createMarkdownInfo",
          "parameters": [
            {
              "type": "File",
              "name": "markdownFile"
            },
            {
              "type": "MarkdownContent",
              "name": "parsedContent"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e mdInfo \u003d new HashMap\u003c\u003e();\r\n        mdInfo.put(\"path\", markdownFile.getAbsolutePath());\r\n        mdInfo.put(\"title\", parsedContent.getTitle());\r\n        mdInfo.put(\"wordCount\", parsedContent.getWordCount());\r\n        mdInfo.put(\"readingTimeMinutes\", parsedContent.getReadingTimeMinutes());\r\n\r\n        // Add headings\r\n        List\u003cMap\u003cString, Object\u003e\u003e headings \u003d new ArrayList\u003c\u003e();\r\n        for (MarkdownHeading heading : parsedContent.getHeadings()) {\r\n            Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\r\n            h.put(\"level\", heading.getLevel());\r\n            h.put(\"text\", heading.getText());\r\n            h.put(\"id\", heading.getId());\r\n            headings.add(h);\r\n        }\r\n        mdInfo.put(\"headings\", headings);\r\n\r\n        // Add links\r\n        List\u003cMap\u003cString, Object\u003e\u003e links \u003d new ArrayList\u003c\u003e();\r\n        for (MarkdownLink link : parsedContent.getLinks()) {\r\n            Map\u003cString, Object\u003e l \u003d new HashMap\u003c\u003e();\r\n            l.put(\"text\", link.getText());\r\n            l.put(\"url\", link.getUrl());\r\n            l.put(\"title\", link.getTitle());\r\n            l.put(\"internal\", link.isInternal());\r\n            links.add(l);\r\n        }\r\n        mdInfo.put(\"links\", links);\r\n\r\n        // Add images\r\n        List\u003cMap\u003cString, Object\u003e\u003e images \u003d new ArrayList\u003c\u003e();\r\n        for (MarkdownImage image : parsedContent.getImages()) {\r\n            Map\u003cString, Object\u003e img \u003d new HashMap\u003c\u003e();\r\n            img.put(\"altText\", image.getAltText());\r\n            img.put(\"url\", image.getUrl());\r\n            img.put(\"title\", image.getTitle());\r\n            img.put(\"local\", image.isLocal());\r\n            images.add(img);\r\n        }\r\n        mdInfo.put(\"images\", images);\r\n\r\n        // Add code blocks\r\n        List\u003cMap\u003cString, Object\u003e\u003e codeBlocks \u003d new ArrayList\u003c\u003e();\r\n        for (MarkdownCodeBlock codeBlock : parsedContent.getCodeBlocks()) {\r\n            Map\u003cString, Object\u003e cb \u003d new HashMap\u003c\u003e();\r\n            cb.put(\"language\", codeBlock.getLanguage());\r\n            cb.put(\"content\", codeBlock.getContent());\r\n            cb.put(\"fenced\", codeBlock.isFenced());\r\n            codeBlocks.add(cb);\r\n        }\r\n        mdInfo.put(\"codeBlocks\", codeBlocks);\r\n\r\n        // Add front matter if available\r\n        if (parsedContent.getFrontMatter() !\u003d null \u0026\u0026 !parsedContent.getFrontMatter().isEmpty()) {\r\n            mdInfo.put(\"frontMatter\", parsedContent.getFrontMatter());\r\n        }\r\n\r\n        return mdInfo;\r\n    }",
          "javadoc": {
            "description": "Create a map of Markdown file information from parsed content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdownFile The Markdown file"
              },
              {
                "name": "param",
                "value": "parsedContent The parsed Markdown content"
              },
              {
                "name": "return",
                "value": "Map containing the Markdown file information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            mdInfo.put(\"frontMatter\", parsedContent.getFrontMatter());\r\n        }",
          "comments": [
            "Add front matter if available"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "addErrorInfo",
          "parameters": [
            {
              "type": "Object\u003e\u003e",
              "name": "resultsList"
            },
            {
              "type": "File",
              "name": "file"
            },
            {
              "type": "String",
              "name": "errorMessage"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n        errorInfo.put(\"path\", file.getAbsolutePath());\r\n        errorInfo.put(\"error\", errorMessage);\r\n        resultsList.add(errorInfo);\r\n    }",
          "javadoc": {
            "description": "Add error information to a list of results.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "resultsList The list to add error information to"
              },
              {
                "name": "param",
                "value": "file The file that caused the error"
              },
              {
                "name": "param",
                "value": "errorMessage The error message"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "listFilesRecursive",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "List\u003cFile\u003e",
              "name": "files"
            }
          ],
          "body": "{\r\n        File[] fileList \u003d directory.listFiles();\r\n        if (fileList !\u003d null) {\r\n            for (File file : fileList) {\r\n                if (file.isDirectory()) {\r\n                    listFilesRecursive(file, files);\r\n                } else {\r\n                    files.add(file);\r\n                }\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to recursively list all files in a directory.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "param",
                "value": "files List to collect files"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "listFilesRecursive",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "List\u003cFile\u003e",
              "name": "files"
            },
            {
              "type": "String...",
              "name": "extensions"
            }
          ],
          "body": "{\r\n        File[] fileList \u003d directory.listFiles();\r\n        if (fileList !\u003d null) {\r\n            for (File file : fileList) {\r\n                if (file.isDirectory()) {\r\n                    listFilesRecursive(file, files, extensions);\r\n                } else {\r\n                    String name \u003d file.getName().toLowerCase();\r\n                    for (String extension : extensions) {\r\n                        if (name.endsWith(extension.toLowerCase())) {\r\n                            files.add(file);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to recursively list files with specific extensions in a directory.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "param",
                "value": "files List to collect files"
              },
              {
                "name": "param",
                "value": "extensions File extensions to include"
              }
            ]
          },
          "comments": []
        }
      ],
      "className": "that",
      "packageName": "io.joshuasalcedo.parsers"
    },
    "src/main/java/io/joshuasalcedo/utility/FileUtils.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/utility/FileUtils.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "listAllFiles",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            },
            {
              "type": "boolean",
              "name": "respectGitIgnore"
            }
          ],
          "body": "{\r\n        List\u003cFile\u003e files;\r\n        if (respectGitIgnore) {\r\n            files \u003d listFilesRespectingGitignore(directory);\r\n        } else {\r\n            files \u003d listAllFilesRecursively(directory);\r\n        }\r\n        return files;\r\n    }",
          "javadoc": {
            "description": "List all files in a directory and its subdirectories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory Directory to search"
              },
              {
                "name": "param",
                "value": "respectGitIgnore Whether to respect .gitignore rules"
              },
              {
                "name": "return",
                "value": "List of files found"
              },
              {
                "name": "throws",
                "value": "IOException If an I/O error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "listAllFilesRecursively",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n        Path dirPath \u003d Paths.get(directory);\r\n        try (Stream\u003cPath\u003e pathStream \u003d Files.walk(dirPath)) {\r\n            return pathStream\r\n                    .filter(Files::isRegularFile)\r\n                    .map(Path::toFile)\r\n                    .collect(Collectors.toList());\r\n        }\r\n    }",
          "javadoc": {
            "description": "List all files in a directory and its subdirectories without respecting .gitignore.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory Directory to search"
              },
              {
                "name": "return",
                "value": "List of files found"
              },
              {
                "name": "throws",
                "value": "IOException If an I/O error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "listFilesRespectingGitignore",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n        // Try to use JGit for respecting .gitignore if it\u0027s a git repository\r\n        try {\r\n            return io.joshuasalcedo.parsers.GitParser.listFilesRespectingGitignore(directory);\r\n        } catch (Exception e) {\r\n            // Fall back to regular file listing if JGit fails or it\u0027s not a git repo\r\n            return listAllFilesRecursively(directory);\r\n        }\r\n    }",
          "javadoc": {
            "description": "List all files in a directory, respecting .gitignore rules if present.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to list files from"
              },
              {
                "name": "return",
                "value": "List of files, excluding those matched by .gitignore rules"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "listAllFilesRecursively",
          "parameters": [],
          "body": "{\r\n        Path dirPath \u003d Paths.get(directory);\r\n        List\u003cString\u003e normalizedExtensions \u003d new ArrayList\u003c\u003e();\r\n        \r\n        // Normalize extensions to start with a dot\r\n        for (String ext : extensions) {\r\n            normalizedExtensions.add(ext.startsWith(\".\") ? ext.toLowerCase() : \".\" + ext.toLowerCase());\r\n        }\r\n        \r\n        try (Stream\u003cPath\u003e pathStream \u003d Files.walk(dirPath)) {\r\n            return pathStream\r\n                    .filter(Files::isRegularFile)\r\n                    .map(Path::toFile)\r\n                    .filter(file -\u003e {\r\n                        String name \u003d file.getName().toLowerCase();\r\n                        for (String ext : normalizedExtensions) {\r\n                            if (name.endsWith(ext)) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        return false;\r\n                    })\r\n                    .collect(Collectors.toList());\r\n        }\r\n    }",
          "comments": [
            "Fall back to regular file listing if JGit fails or it\u0027s not a git repo"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "to",
          "methodName": "include",
          "parameters": [
            {
              "type": "with",
              "name": "or"
            }
          ],
          "body": "{\r\n        Path dirPath \u003d Paths.get(directory);\r\n        List\u003cString\u003e normalizedExtensions \u003d new ArrayList\u003c\u003e();\r\n        \r\n        // Normalize extensions to start with a dot\r\n        for (String ext : extensions) {\r\n            normalizedExtensions.add(ext.startsWith(\".\") ? ext.toLowerCase() : \".\" + ext.toLowerCase());\r\n        }\r\n        \r\n        try (Stream\u003cPath\u003e pathStream \u003d Files.walk(dirPath)) {\r\n            return pathStream\r\n                    .filter(Files::isRegularFile)\r\n                    .map(Path::toFile)\r\n                    .filter(file -\u003e {\r\n                        String name \u003d file.getName().toLowerCase();\r\n                        for (String ext : normalizedExtensions) {\r\n                            if (name.endsWith(ext)) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        return false;\r\n                    })\r\n                    .collect(Collectors.toList());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "listFilesByExtension",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            },
            {
              "type": "String...",
              "name": "extensions"
            }
          ],
          "body": "{\r\n        Path dirPath \u003d Paths.get(directory);\r\n        List\u003cString\u003e normalizedExtensions \u003d new ArrayList\u003c\u003e();\r\n        \r\n        // Normalize extensions to start with a dot\r\n        for (String ext : extensions) {\r\n            normalizedExtensions.add(ext.startsWith(\".\") ? ext.toLowerCase() : \".\" + ext.toLowerCase());\r\n        }\r\n        \r\n        try (Stream\u003cPath\u003e pathStream \u003d Files.walk(dirPath)) {\r\n            return pathStream\r\n                    .filter(Files::isRegularFile)\r\n                    .map(Path::toFile)\r\n                    .filter(file -\u003e {\r\n                        String name \u003d file.getName().toLowerCase();\r\n                        for (String ext : normalizedExtensions) {\r\n                            if (name.endsWith(ext)) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        return false;\r\n                    })\r\n                    .collect(Collectors.toList());\r\n        }\r\n    }",
          "javadoc": {
            "description": "List files with specific extensions in a directory and its subdirectories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory Directory to search"
              },
              {
                "name": "param",
                "value": "extensions File extensions to include (with or without leading dot)"
              },
              {
                "name": "return",
                "value": "List of files with the specified extensions"
              },
              {
                "name": "throws",
                "value": "IOException If an I/O error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "dot",
          "methodName": "for",
          "parameters": [
            {
              "type": "String",
              "name": "ext"
            }
          ],
          "body": "{\r\n            normalizedExtensions.add(ext.startsWith(\".\") ? ext.toLowerCase() : \".\" + ext.toLowerCase());\r\n        }",
          "comments": [
            "Normalize extensions to start with a dot"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "listTextFiles",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            },
            {
              "type": "boolean",
              "name": "respectGitIgnore"
            }
          ],
          "body": "{\r\n        List\u003cFile\u003e allFiles \u003d listAllFiles(directory, respectGitIgnore);\r\n        return allFiles.stream()\r\n                .filter(FileUtils::isTextFile)\r\n                .collect(Collectors.toList());\r\n    }",
          "javadoc": {
            "description": "List all text files in a directory and its subdirectories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory Directory to search"
              },
              {
                "name": "param",
                "value": "respectGitIgnore Whether to respect .gitignore rules"
              },
              {
                "name": "return",
                "value": "List of text files"
              },
              {
                "name": "throws",
                "value": "IOException If an I/O error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "listFilesMatching",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            },
            {
              "type": "boolean",
              "name": "respectGitIgnore"
            },
            {
              "type": "Predicate\u003cFile\u003e",
              "name": "predicate"
            }
          ],
          "body": "{\r\n        List\u003cFile\u003e allFiles \u003d listAllFiles(directory, respectGitIgnore);\r\n        return allFiles.stream()\r\n                .filter(predicate)\r\n                .collect(Collectors.toList());\r\n    }",
          "javadoc": {
            "description": "List files matching a custom predicate.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory Directory to search"
              },
              {
                "name": "param",
                "value": "respectGitIgnore Whether to respect .gitignore rules"
              },
              {
                "name": "param",
                "value": "predicate Custom filter to apply to files"
              },
              {
                "name": "return",
                "value": "List of files matching the predicate"
              },
              {
                "name": "throws",
                "value": "IOException If an I/O error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getRelativePath",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            },
            {
              "type": "File",
              "name": "baseDir"
            }
          ],
          "body": "{\r\n        return baseDir.toURI().relativize(file.toURI()).getPath();\r\n    }",
          "javadoc": {
            "description": "Get the relative path of a file from a base directory.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The file"
              },
              {
                "name": "param",
                "value": "baseDir The base directory"
              },
              {
                "name": "return",
                "value": "The relative path as a string"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "isTextFile",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            }
          ],
          "body": "{\r\n        // Don\u0027t bother with empty files\r\n        if (file.length() \u003d\u003d 0) return true;\r\n        \r\n        // Don\u0027t bother with very large files - likely not text\r\n        if (file.length() \u003e 50 * 1024 * 1024) return false; // 50MB limit\r\n        \r\n        Path path \u003d file.toPath();\r\n        \r\n        try {\r\n            // Sample the file if it\u0027s large\r\n            byte[] data;\r\n            if (file.length() \u003e 8192) {\r\n                // For large files, sample the beginning, middle, and end\r\n                data \u003d sampleFileContent(path);\r\n            } else {\r\n                // For small files, read it all\r\n                data \u003d Files.readAllBytes(path);\r\n            }\r\n            \r\n            // Quick test: check for null bytes (common in binary files)\r\n            for (byte b : data) {\r\n                if (b \u003d\u003d 0) return false;\r\n            }\r\n            \r\n            // Try to decode the file as text with common encodings\r\n            return canDecodeAsText(data);\r\n            \r\n        } catch (IOException e) {\r\n            return false;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Determine if a file is a text file using character decoding capabilities.\r\nNo hard-coded extensions or MIME types are used.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The file to check"
              },
              {
                "name": "return",
                "value": "true if the file appears to be readable as text"
              }
            ]
          },
          "comments": [
            "Don\u0027t bother with empty files"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "files",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            // Sample the file if it\u0027s large\r\n            byte[] data;\r\n            if (file.length() \u003e 8192) {\r\n                // For large files, sample the beginning, middle, and end\r\n                data \u003d sampleFileContent(path);\r\n            } else {\r\n                // For small files, read it all\r\n                data \u003d Files.readAllBytes(path);\r\n            }\r\n            \r\n            // Quick test: check for null bytes (common in binary files)\r\n            for (byte b : data) {\r\n                if (b \u003d\u003d 0) return false;\r\n            }\r\n            \r\n            // Try to decode the file as text with common encodings\r\n            return canDecodeAsText(data);\r\n            \r\n        }",
          "javadoc": {
            "description": "Determine if a file is a text file using character decoding capabilities.\r\nNo hard-coded extensions or MIME types are used.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The file to check"
              },
              {
                "name": "return",
                "value": "true if the file appears to be readable as text"
              }
            ]
          },
          "comments": [
            "Don\u0027t bother with empty files",
            "Don\u0027t bother with very la"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "text",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            // Sample the file if it\u0027s large\r\n            byte[] data;\r\n            if (file.length() \u003e 8192) {\r\n                // For large files, sample the beginning, middle, and end\r\n                data \u003d sampleFileContent(path);\r\n            } else {\r\n                // For small files, read it all\r\n                data \u003d Files.readAllBytes(path);\r\n            }\r\n            \r\n            // Quick test: check for null bytes (common in binary files)\r\n            for (byte b : data) {\r\n                if (b \u003d\u003d 0) return false;\r\n            }\r\n            \r\n            // Try to decode the file as text with common encodings\r\n            return canDecodeAsText(data);\r\n            \r\n        }",
          "javadoc": {
            "description": "Determine if a file is a text file using character decoding capabilities.\r\nNo hard-coded extensions or MIME types are used.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The file to check"
              },
              {
                "name": "return",
                "value": "true if the file appears to be readable as text"
              }
            ]
          },
          "comments": [
            "Don\u0027t bother with empty files",
            "Don\u0027t bother with very large files - likely not text",
            "50MB limit"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "bytes",
          "parameters": [
            {
              "type": "common",
              "name": "in"
            }
          ],
          "body": "{\r\n                if (b \u003d\u003d 0) return false;\r\n            }",
          "comments": [
            "For small files, read it all",
            "Quick test: check for null bytes (common in binary files)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "canDecodeAsText",
          "parameters": [],
          "body": "{\r\n            return false;\r\n        }",
          "comments": [
            "Try to decode the file as text with common encodings"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "sample",
          "methodName": "try",
          "parameters": [
            {
              "type": "var",
              "name": "channel"
            }
          ],
          "body": "{\r\n            ByteBuffer buffer \u003d ByteBuffer.wrap(sample);\r\n            \r\n            // Read beginning (first 3KB)\r\n            buffer.limit(3072);\r\n            channel.read(buffer);\r\n            \r\n            // Read from middle (2KB)\r\n            buffer.limit(5120);\r\n            buffer.position(3072);\r\n            channel.position(fileSize / 2 - 1024);\r\n            channel.read(buffer);\r\n            \r\n            // Read from end (3KB)\r\n            buffer.limit(8192);\r\n            buffer.position(5120);\r\n            channel.position(Math.max(0, fileSize - 3072));\r\n            channel.read(buffer);\r\n        }",
          "javadoc": {
            "description": "Sample content from beginning, middle and end of a file.",
            "tags": []
          },
          "comments": [
            "8KB sample"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Read",
          "methodName": "beginning",
          "parameters": [
            {
              "type": "first",
              "name": "3KB"
            }
          ],
          "body": "{\r\n        // Try with common encodings\r\n        String[] encodings \u003d {\"UTF-8\", \"UTF-16\", \"ISO-8859-1\", \"US-ASCII\"};\r\n        \r\n        for (String encoding : encodings) {\r\n            Charset charset \u003d Charset.forName(encoding);\r\n            CharsetDecoder decoder \u003d charset.newDecoder()\r\n                    .onMalformedInput(CodingErrorAction.REPORT)\r\n                    .onUnmappableCharacter(CodingErrorAction.REPORT);\r\n            \r\n            ByteBuffer buffer \u003d ByteBuffer.wrap(data);\r\n            try {\r\n                CharBuffer charBuffer \u003d decoder.decode(buffer);\r\n                \r\n                // Additional check - if over 5% of the content is control characters,\r\n                // it\u0027s probably binary despite being decodable\r\n                return !hasTooManyControlCharacters(charBuffer);\r\n            } catch (CharacterCodingException e) {\r\n                // Decoding failed with this charset, try another one\r\n                continue;\r\n            }\r\n        }\r\n        \r\n        // If we couldn\u0027t decode with any charset, it\u0027s likely binary\r\n        return false;\r\n    }",
          "javadoc": {
            "description": "Sample content from beginning, middle and end of a file.",
            "tags": []
          },
          "comments": [
            "8KB sample",
            "Read beginning (first 3KB)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "from",
          "methodName": "middle",
          "parameters": [],
          "body": "{\r\n        // Try with common encodings\r\n        String[] encodings \u003d {\"UTF-8\", \"UTF-16\", \"ISO-8859-1\", \"US-ASCII\"};\r\n        \r\n        for (String encoding : encodings) {\r\n            Charset charset \u003d Charset.forName(encoding);\r\n            CharsetDecoder decoder \u003d charset.newDecoder()\r\n                    .onMalformedInput(CodingErrorAction.REPORT)\r\n                    .onUnmappableCharacter(CodingErrorAction.REPORT);\r\n            \r\n            ByteBuffer buffer \u003d ByteBuffer.wrap(data);\r\n            try {\r\n                CharBuffer charBuffer \u003d decoder.decode(buffer);\r\n                \r\n                // Additional check - if over 5% of the content is control characters,\r\n                // it\u0027s probably binary despite being decodable\r\n                return !hasTooManyControlCharacters(charBuffer);\r\n            } catch (CharacterCodingException e) {\r\n                // Decoding failed with this charset, try another one\r\n                continue;\r\n            }\r\n        }\r\n        \r\n        // If we couldn\u0027t decode with any charset, it\u0027s likely binary\r\n        return false;\r\n    }",
          "comments": [
            "Read beginning (first 3KB)",
            "Read from middle (2KB)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "from",
          "methodName": "end",
          "parameters": [],
          "body": "{\r\n        // Try with common encodings\r\n        String[] encodings \u003d {\"UTF-8\", \"UTF-16\", \"ISO-8859-1\", \"US-ASCII\"};\r\n        \r\n        for (String encoding : encodings) {\r\n            Charset charset \u003d Charset.forName(encoding);\r\n            CharsetDecoder decoder \u003d charset.newDecoder()\r\n                    .onMalformedInput(CodingErrorAction.REPORT)\r\n                    .onUnmappableCharacter(CodingErrorAction.REPORT);\r\n            \r\n            ByteBuffer buffer \u003d ByteBuffer.wrap(data);\r\n            try {\r\n                CharBuffer charBuffer \u003d decoder.decode(buffer);\r\n                \r\n                // Additional check - if over 5% of the content is control characters,\r\n                // it\u0027s probably binary despite being decodable\r\n                return !hasTooManyControlCharacters(charBuffer);\r\n            } catch (CharacterCodingException e) {\r\n                // Decoding failed with this charset, try another one\r\n                continue;\r\n            }\r\n        }\r\n        \r\n        // If we couldn\u0027t decode with any charset, it\u0027s likely binary\r\n        return false;\r\n    }",
          "comments": [
            "Read from end (3KB)"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "canDecodeAsText",
          "parameters": [
            {
              "type": "byte[]",
              "name": "data"
            }
          ],
          "body": "{\r\n        // Try with common encodings\r\n        String[] encodings \u003d {\"UTF-8\", \"UTF-16\", \"ISO-8859-1\", \"US-ASCII\"};\r\n        \r\n        for (String encoding : encodings) {\r\n            Charset charset \u003d Charset.forName(encoding);\r\n            CharsetDecoder decoder \u003d charset.newDecoder()\r\n                    .onMalformedInput(CodingErrorAction.REPORT)\r\n                    .onUnmappableCharacter(CodingErrorAction.REPORT);\r\n            \r\n            ByteBuffer buffer \u003d ByteBuffer.wrap(data);\r\n            try {\r\n                CharBuffer charBuffer \u003d decoder.decode(buffer);\r\n                \r\n                // Additional check - if over 5% of the content is control characters,\r\n                // it\u0027s probably binary despite being decodable\r\n                return !hasTooManyControlCharacters(charBuffer);\r\n            } catch (CharacterCodingException e) {\r\n                // Decoding failed with this charset, try another one\r\n                continue;\r\n            }\r\n        }\r\n        \r\n        // If we couldn\u0027t decode with any charset, it\u0027s likely binary\r\n        return false;\r\n    }",
          "javadoc": {
            "description": "Try to decode the data as text with various encodings.\r\nReturns true if the content can be successfully decoded.",
            "tags": []
          },
          "comments": [
            "Try with common encodings"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "hasTooManyControlCharacters",
          "parameters": [
            {
              "type": "CharBuffer",
              "name": "buffer"
            }
          ],
          "body": "{\r\n        int controlCount \u003d 0;\r\n        int totalChars \u003d buffer.length();\r\n        \r\n        // Reset buffer to beginning\r\n        buffer.rewind();\r\n        \r\n        while (buffer.hasRemaining()) {\r\n            char c \u003d buffer.get();\r\n            // Count control chars except common whitespace\r\n            if (c \u003c 32 \u0026\u0026 c !\u003d \u0027\\t\u0027 \u0026\u0026 c !\u003d \u0027\\n\u0027 \u0026\u0026 c !\u003d \u0027\\r\u0027) {\r\n                controlCount++;\r\n            }\r\n        }\r\n        \r\n        // If more than 5% are control characters, likely binary\r\n        return ((double) controlCount / totalChars) \u003e 0.05;\r\n    }",
          "javadoc": {
            "description": "Check if the text contains too many control characters.",
            "tags": []
          },
          "comments": [
            "If we couldn\u0027t decode with any charset, it\u0027s likely binary"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "whitespace",
          "methodName": "if",
          "parameters": [
            {
              "type": "c",
              "name": "\u003c"
            }
          ],
          "body": "{\r\n                controlCount++;\r\n            }",
          "javadoc": {
            "description": "Check if the text contains too many control characters.",
            "tags": []
          },
          "comments": [
            "Reset buffer to beginning",
            "Count control chars except common whitespace"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "binary",
          "methodName": "return",
          "parameters": [],
          "body": "{\r\n        return Files.readString(file.toPath());\r\n    }",
          "comments": [
            "If more than 5% are control characters, likely binary"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "readFileAsString",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            }
          ],
          "body": "{\r\n        return Files.readString(file.toPath());\r\n    }",
          "javadoc": {
            "description": "Get file content as string.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The file to read"
              },
              {
                "name": "return",
                "value": "The file content as string"
              },
              {
                "name": "throws",
                "value": "IOException If an I/O error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "writeStringToFile",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            },
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n        Files.writeString(file.toPath(), content);\r\n    }",
          "javadoc": {
            "description": "Write string content to a file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The file to write"
              },
              {
                "name": "param",
                "value": "content The content to write"
              },
              {
                "name": "throws",
                "value": "IOException If an I/O error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "createDirectoriesForFile",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            }
          ],
          "body": "{\r\n        File dir \u003d file.getParentFile();\r\n        if (dir !\u003d null \u0026\u0026 !dir.exists()) {\r\n            return dir.mkdirs();\r\n        }\r\n        return true;\r\n    }",
          "javadoc": {
            "description": "Create directories for a file if they don\u0027t exist.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The file whose directory structure should be created"
              },
              {
                "name": "return",
                "value": "true if directories were created or already existed"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "isFileReadable",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            }
          ],
          "body": "{\r\n        return file.exists() \u0026\u0026 file.isFile() \u0026\u0026 file.canRead();\r\n    }",
          "javadoc": {
            "description": "Check if a file exists and is readable.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The file to check"
              },
              {
                "name": "return",
                "value": "true if the file exists and is readable"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "isFileWritable",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            }
          ],
          "body": "{\r\n        return file.exists() \u0026\u0026 file.isFile() \u0026\u0026 file.canWrite();\r\n    }",
          "javadoc": {
            "description": "Check if a file exists and is writable.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The file to check"
              },
              {
                "name": "return",
                "value": "true if the file exists and is writable"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "file",
          "methodName": "extension",
          "parameters": [
            {
              "type": "without",
              "name": "the"
            }
          ],
          "body": "{\r\n        String name \u003d file.getName();\r\n        int lastDotIndex \u003d name.lastIndexOf(\u0027.\u0027);\r\n        return lastDotIndex \u003e 0 ? name.substring(lastDotIndex + 1) : \"\";\r\n    }",
          "javadoc": {
            "description": "Check if a file exists and is writable.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The file to check"
              },
              {
                "name": "return",
                "value": "true if the file exists and is writable"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getFileExtension",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            }
          ],
          "body": "{\r\n        String name \u003d file.getName();\r\n        int lastDotIndex \u003d name.lastIndexOf(\u0027.\u0027);\r\n        return lastDotIndex \u003e 0 ? name.substring(lastDotIndex + 1) : \"\";\r\n    }",
          "javadoc": {
            "description": "Get the file extension.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The file"
              },
              {
                "name": "return",
                "value": "The file extension (without the dot) or empty string if none"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getFileBaseName",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            }
          ],
          "body": "{\r\n        String name \u003d file.getName();\r\n        int lastDotIndex \u003d name.lastIndexOf(\u0027.\u0027);\r\n        return lastDotIndex \u003e 0 ? name.substring(0, lastDotIndex) : name;\r\n    }",
          "javadoc": {
            "description": "Get the filename without extension.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The file"
              },
              {
                "name": "return",
                "value": "The filename without extension"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "readable",
          "methodName": "string",
          "parameters": [
            {
              "type": "\"1.2",
              "name": "MB\""
            }
          ],
          "body": "{\r\n        long size \u003d file.length();\r\n        if (size \u003c\u003d 0) return \"0 B\";\r\n        \r\n        final String[] units \u003d new String[] { \"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\" };\r\n        int digitGroups \u003d (int) (Math.log10(size) / Math.log10(1024));\r\n        \r\n        return String.format(\"%.1f %s\", size / Math.pow(1024, digitGroups), units[digitGroups]);\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getHumanReadableSize",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            }
          ],
          "body": "{\r\n        long size \u003d file.length();\r\n        if (size \u003c\u003d 0) return \"0 B\";\r\n        \r\n        final String[] units \u003d new String[] { \"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\" };\r\n        int digitGroups \u003d (int) (Math.log10(size) / Math.log10(1024));\r\n        \r\n        return String.format(\"%.1f %s\", size / Math.pow(1024, digitGroups), units[digitGroups]);\r\n    }",
          "javadoc": {
            "description": "Get a file\u0027s size in a human-readable format.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The file"
              },
              {
                "name": "return",
                "value": "The file size as a human-readable string (e.g., \"1.2 MB\")"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "main",
          "parameters": [
            {
              "type": "String[]",
              "name": "args"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get the current directory properly\r\n            String testDir \u003d System.getProperty(\"user.dir\");\r\n            System.out.println(\"Testing with directory: \" + testDir);\r\n\r\n            System.out.println(\"\u003d\u003d\u003d FileUtils Test \u003d\u003d\u003d\\n\");\r\n\r\n            // Test 1: List all files\r\n            System.out.println(\"Test 1: Listing all files (not respecting .gitignore)\");\r\n            List\u003cFile\u003e allFiles \u003d listAllFiles(testDir, false);\r\n            System.out.println(\"Found \" + allFiles.size() + \" files\");\r\n            printFileSample(allFiles, 5);\r\n\r\n            // Rest of the test method remains the same...\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error during test: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }\r\n    }",
          "comments": [
            "Get the current directory pr"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "all",
          "methodName": "files",
          "parameters": [
            {
              "type": "not",
              "name": "respecting"
            }
          ],
          "body": "{\r\n            System.err.println(\"Error during test: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }",
          "comments": [
            "Test 1: List all files"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "printFileSample",
          "parameters": [
            {
              "type": "List\u003cFile\u003e",
              "name": "files"
            },
            {
              "type": "int",
              "name": "maxFiles"
            }
          ],
          "body": "{\r\n        System.out.println(\"Sample files:\");\r\n        int count \u003d 0;\r\n        for (File file : files) {\r\n            if (count++ \u003e\u003d maxFiles) {\r\n                System.out.println(\"  ... and \" + (files.size() - maxFiles) + \" more\");\r\n                break;\r\n            }\r\n            System.out.println(\"  \" + file.getName() + \" (\" + getHumanReadableSize(file) + \")\");\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to print a sample of files for the tests",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.utility"
    },
    "src/test/resources/repo/Utils.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/resources/repo/Utils.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "helper",
          "parameters": [],
          "body": "{ }",
          "comments": []
        }
      ],
      "className": "Utils",
      "packageName": "default"
    },
    "target/test-classes/repo/src/main/java/com/test/feature/FeatureClass.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/target/test-classes/repo/src/main/java/com/test/feature/FeatureClass.java",
      "methods": [],
      "className": "FeatureClass",
      "packageName": "com.test.feature"
    },
    "src/main/java/io/joshuasalcedo/model/git/CommitInfo.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/git/CommitInfo.java",
      "methods": [],
      "className": "CommitInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    "src/main/java/io/joshuasalcedo/model/javafile/Parameter.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/javafile/Parameter.java",
      "methods": [],
      "className": "Parameter",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    "src/test/resources/repo/Feature.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/resources/repo/Feature.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "doSomething",
          "parameters": [],
          "body": "{ }",
          "comments": []
        }
      ],
      "className": "Feature",
      "packageName": "default"
    },
    "src/main/java/io/joshuasalcedo/parsers/HtmlParser.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/parsers/HtmlParser.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "HtmlParser",
          "parameters": [],
          "body": "{\r\n        // Utility class, prevent instantiation\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing HTML documents using JSoup.",
            "tags": []
          },
          "comments": [
            "Utility class, prevent instantiation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parse",
          "parameters": [
            {
              "type": "String",
              "name": "html"
            },
            {
              "type": "String",
              "name": "baseUri"
            }
          ],
          "body": "{\r\n        return Jsoup.parse(html, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from a string.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "html    The HTML content"
              },
              {
                "name": "param",
                "value": "baseUri The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parse",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            },
            {
              "type": "String",
              "name": "charset"
            },
            {
              "type": "String",
              "name": "baseUri"
            }
          ],
          "body": "{\r\n        String content \u003d FileUtils.readFileAsString(file);\r\n        return Jsoup.parse(content, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from a file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file    The HTML file"
              },
              {
                "name": "param",
                "value": "charset The character set of the file"
              },
              {
                "name": "param",
                "value": "baseUri The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parse",
          "parameters": [
            {
              "type": "Path",
              "name": "path"
            },
            {
              "type": "String",
              "name": "baseUri"
            }
          ],
          "body": "{\r\n        String html \u003d FileUtils.readFileAsString(path.toFile());\r\n        return parse(html, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from a Path.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path    The path to the HTML file"
              },
              {
                "name": "param",
                "value": "baseUri The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "parse",
          "parameters": [],
          "body": "{\r\n        return Jsoup.parse(inputStream, charset, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from a Path.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path    The path to the HTML file"
              },
              {
                "name": "param",
                "value": "baseUri The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parse",
          "parameters": [
            {
              "type": "InputStream",
              "name": "inputStream"
            },
            {
              "type": "String",
              "name": "charset"
            },
            {
              "type": "String",
              "name": "baseUri"
            }
          ],
          "body": "{\r\n        return Jsoup.parse(inputStream, charset, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from an InputStream.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "inputStream The input stream containing HTML content"
              },
              {
                "name": "param",
                "value": "charset     The character set of the stream"
              },
              {
                "name": "param",
                "value": "baseUri     The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parseUrl",
          "parameters": [
            {
              "type": "String",
              "name": "url"
            }
          ],
          "body": "{\r\n        return Jsoup.connect(url)\r\n                .userAgent(\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\")\r\n                .get();\r\n    }",
          "javadoc": {
            "description": "Connect to a URL and parse the returned HTML.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "url The URL to connect to"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "all",
          "methodName": "headings",
          "parameters": [],
          "body": "{\r\n        return document.select(\"h1, h2, h3, h4, h5, h6\");\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getHeadings",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"h1, h2, h3, h4, h5, h6\");\r\n    }",
          "javadoc": {
            "description": "Get all headings (h1-h6) from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all headings"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getLinks",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"a[href]\");\r\n    }",
          "javadoc": {
            "description": "Get all links from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all links"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getImages",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"img\");\r\n    }",
          "javadoc": {
            "description": "Get all images from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all images"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getTables",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"table\");\r\n    }",
          "javadoc": {
            "description": "Get all tables from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all tables"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getForms",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"form\");\r\n    }",
          "javadoc": {
            "description": "Get all forms from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all forms"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "list",
          "methodName": "elements",
          "parameters": [],
          "body": "{\r\n        return document.select(\"ul, ol\");\r\n    }",
          "javadoc": {
            "description": "Get all forms from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all forms"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getLists",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"ul, ol\");\r\n    }",
          "javadoc": {
            "description": "Get all list elements (ul, ol) from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all lists"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getElementsByClass",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "className"
            }
          ],
          "body": "{\r\n        return document.getElementsByClass(className);\r\n    }",
          "javadoc": {
            "description": "Get all elements with the specified class name.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document  The JSoup Document"
              },
              {
                "name": "param",
                "value": "className The class name to search for"
              },
              {
                "name": "return",
                "value": "Elements containing all matching elements"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Element",
          "methodName": "getElementById",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "id"
            }
          ],
          "body": "{\r\n        return document.getElementById(id);\r\n    }",
          "javadoc": {
            "description": "Get the element with the specified ID.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "param",
                "value": "id       The ID to search for"
              },
              {
                "name": "return",
                "value": "The element with the specified ID, or null if not found"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "select",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "cssSelector"
            }
          ],
          "body": "{\r\n        return document.select(cssSelector);\r\n    }",
          "javadoc": {
            "description": "Get all elements matching the specified CSS selector.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document    The JSoup Document"
              },
              {
                "name": "param",
                "value": "cssSelector The CSS selector to match"
              },
              {
                "name": "return",
                "value": "Elements containing all matching elements"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, String\u003e",
          "methodName": "getMetadata",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        Map\u003cString, String\u003e metadata \u003d new HashMap\u003c\u003e();\r\n\r\n        // Title\r\n        metadata.put(\"title\", document.title());\r\n\r\n        // Meta tags\r\n        Elements metaTags \u003d document.select(\"meta\");\r\n        for (Element metaTag : metaTags) {\r\n            if (metaTag.hasAttr(\"name\") \u0026\u0026 metaTag.hasAttr(\"content\")) {\r\n                metadata.put(metaTag.attr(\"name\"), metaTag.attr(\"content\"));\r\n            } else if (metaTag.hasAttr(\"property\") \u0026\u0026 metaTag.hasAttr(\"content\")) {\r\n                metadata.put(metaTag.attr(\"property\"), metaTag.attr(\"content\"));\r\n            }\r\n        }\r\n\r\n        return metadata;\r\n    }",
          "javadoc": {
            "description": "Extract all metadata from the document head.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Map of metadata key-value pairs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                metadata.put(metaTag.attr(\"property\"), metaTag.attr(\"content\"));\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getTextContent",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.text();\r\n    }",
          "javadoc": {
            "description": "Extract text content from a document, removing all HTML tags.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Plain text content"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    data[i][j] \u003d element.html();\r\n                }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    data[i][j] \u003d element.outerHtml();\r\n                }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "exists",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "selector"
            }
          ],
          "body": "{\r\n        return !document.select(selector).isEmpty();\r\n    }",
          "javadoc": {
            "description": "Check if elements matching a selector exist in the document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "param",
                "value": "selector CSS selector to check"
              },
              {
                "name": "return",
                "value": "true if at least one matching element exists"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getText",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "selector"
            }
          ],
          "body": "{\r\n        Element element \u003d document.select(selector).first();\r\n        return element !\u003d null ? element.text() : \"\";\r\n    }",
          "javadoc": {
            "description": "Get text content of an element, or empty string if the selector doesn\u0027t match any elements.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "param",
                "value": "selector CSS selector to find element"
              },
              {
                "name": "return",
                "value": "Text content of the first matching element, or empty string if none match"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getAttr",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "selector"
            },
            {
              "type": "String",
              "name": "attribute"
            }
          ],
          "body": "{\r\n        Element element \u003d document.select(selector).first();\r\n        return element !\u003d null ? element.attr(attribute) : \"\";\r\n    }",
          "javadoc": {
            "description": "Get attribute value of an element, or empty string if the selector doesn\u0027t match any elements.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document  The JSoup Document"
              },
              {
                "name": "param",
                "value": "selector  CSS selector to find element"
              },
              {
                "name": "param",
                "value": "attribute Attribute name to get"
              },
              {
                "name": "return",
                "value": "Attribute value of the first matching element, or empty string if none match"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "metadataToJson",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        Map\u003cString, String\u003e metadata \u003d getMetadata(document);\r\n        return JsonUtils.toPrettyJson(metadata);\r\n    }",
          "javadoc": {
            "description": "Convert metadata to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "JSON representation of the metadata"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "tableToJson",
          "parameters": [
            {
              "type": "Element",
              "name": "table"
            }
          ],
          "body": "{\r\n        String[][] tableArray \u003d tableToArray(table);\r\n        return JsonUtils.toPrettyJson(tableArray);\r\n    }",
          "javadoc": {
            "description": "Convert table to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "table The JSoup table Element"
              },
              {
                "name": "return",
                "value": "JSON representation of the table"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "tableToMapsJson",
          "parameters": [
            {
              "type": "Element",
              "name": "table"
            }
          ],
          "body": "{\r\n        Map\u003cString, String\u003e[] maps \u003d tableToMaps(table);\r\n        return JsonUtils.toPrettyJson(maps);\r\n    }",
          "javadoc": {
            "description": "Convert table to JSON as an array of maps.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "table The JSoup table Element"
              },
              {
                "name": "return",
                "value": "JSON representation of the table as an array of maps"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "structuredDataToJson",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "containerSelector"
            },
            {
              "type": "String\u003e",
              "name": "fieldSelectors"
            }
          ],
          "body": "{\r\n        Map\u003cString, String\u003e[] data \u003d extractStructuredData(document, containerSelector, fieldSelectors);\r\n        return JsonUtils.toPrettyJson(data);\r\n    }",
          "javadoc": {
            "description": "Convert structured data to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document          The JSoup Document"
              },
              {
                "name": "param",
                "value": "containerSelector CSS selector for the container elements"
              },
              {
                "name": "param",
                "value": "fieldSelectors    Map of field names to relative CSS selectors within each container"
              },
              {
                "name": "return",
                "value": "JSON representation of the structured data"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "extractDataToJson",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "selector"
            },
            {
              "type": "String...",
              "name": "attributes"
            }
          ],
          "body": "{\r\n        String[][] data \u003d extractData(document, selector, attributes);\r\n        return JsonUtils.toPrettyJson(data);\r\n    }",
          "javadoc": {
            "description": "Convert extracted data to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document   The JSoup Document"
              },
              {
                "name": "param",
                "value": "selector   CSS selector to find elements"
              },
              {
                "name": "param",
                "value": "attributes List of attributes to extract from each element"
              },
              {
                "name": "return",
                "value": "JSON representation of the extracted data"
              }
            ]
          },
          "comments": []
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    "src/test/java/io/joshuasalcedo/parsers/GitParserTest.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/java/io/joshuasalcedo/parsers/GitParserTest.java",
      "methods": [
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "boolean",
          "methodName": "isCurrentDirGitRepo",
          "parameters": [],
          "body": "{\r\n        File gitDir \u003d new File(\".git\");\r\n        return gitDir.exists() \u0026\u0026 gitDir.isDirectory();\r\n    }",
          "javadoc": {
            "description": "Helper method to check if the current directory is a Git repository",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Use the current directory as the repository to parse\r\n            GitRepositoryInfo repoInfo \u003d GitParser.parseRepository(\".\");\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-parser-output.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }\r\n\r\n            // Basic assertions to make sure the parser works\r\n            assertNotNull(repoInfo.getName(), \"Repository name should not be null\");\r\n            assertNotNull(repoInfo.getCurrentBranch(), \"Current branch should not be null\");\r\n\r\n            // Don\u0027t assert on latest commit - it might be null in a fresh repo\r\n            // Only check commit count instead\r\n            assertTrue(repoInfo.getCommitCount() \u003e\u003d 0, \"Commit count should be zero or positive\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while parsing repository: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to check if the current directory is a Git repository",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Git",
          "methodName": "repository",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Use the current directory as the repository to parse\r\n            GitRepositoryInfo repoInfo \u003d GitParser.parseRepository(\".\");\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-parser-output.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }\r\n\r\n            // Basic assertions to make sure the parser works\r\n            assertNotNull(repoInfo.getName(), \"Repository name should not be null\");\r\n            assertNotNull(repoInfo.getCurrentBranch(), \"Current branch should not be null\");\r\n\r\n            // Don\u0027t assert on latest commit - it might be null in a fresh repo\r\n            // Only check commit count instead\r\n            assertTrue(repoInfo.getCommitCount() \u003e\u003d 0, \"Commit count should be zero or positive\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while parsing repository: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to check if the current directory is a Git repository",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseCurrentRepository",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Use the current directory as the repository to parse\r\n            GitRepositoryInfo repoInfo \u003d GitParser.parseRepository(\".\");\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-parser-output.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }\r\n\r\n            // Basic assertions to make sure the parser works\r\n            assertNotNull(repoInfo.getName(), \"Repository name should not be null\");\r\n            assertNotNull(repoInfo.getCurrentBranch(), \"Current branch should not be null\");\r\n\r\n            // Don\u0027t assert on latest commit - it might be null in a fresh repo\r\n            // Only check commit count instead\r\n            assertTrue(repoInfo.getCommitCount() \u003e\u003d 0, \"Commit count should be zero or positive\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while parsing repository: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test parsing the current Git repository (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Use the cu"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }",
          "javadoc": {
            "description": "Test parsing the current Git repository (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Create an output file in the target directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }",
          "comments": [
            "Print basic repository informati"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }",
          "comments": [
            "Print file extension counts if available"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }",
          "comments": [
            "Print statistics if available"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }",
          "comments": [
            "Print top contributors if available"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "commit",
          "methodName": "information",
          "parameters": [
            {
              "type": "if",
              "name": "available"
            }
          ],
          "body": "{\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                }",
          "comments": [
            "Print latest commit information (if available)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "works",
          "methodName": "assertNotNull",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while parsing repository: \" + e.getMessage());\r\n        }",
          "comments": [
            "Basic assertions to make sure the parser works"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "instead",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while parsing repository: \" + e.getMessage());\r\n        }",
          "comments": [
            "Don\u0027t assert on latest commit - it might be null in a fresh repo",
            "Only check commit count instead"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "commit",
          "methodName": "log",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        // Create an output file in the target directory\r\n        File outputFile \u003d new File(\"target/git-commit-log.txt\");\r\n        outputFile.getParentFile().mkdirs();\r\n\r\n        try {\r\n            // Get formatted commit log\r\n            String commitLog \u003d GitParser.getFormattedCommitLog(\".\", 10);\r\n\r\n            // Save to file\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(commitLog);\r\n            }\r\n\r\n            System.out.println(\"Commit log written to: \" + outputFile.getAbsolutePath());\r\n\r\n            // Verify log is not empty\r\n            assertNotNull(commitLog, \"Commit log should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commit log: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testGetCommitLog",
          "parameters": [],
          "body": "{\r\n        // Create an output file in the target directory\r\n        File outputFile \u003d new File(\"target/git-commit-log.txt\");\r\n        outputFile.getParentFile().mkdirs();\r\n\r\n        try {\r\n            // Get formatted commit log\r\n            String commitLog \u003d GitParser.getFormattedCommitLog(\".\", 10);\r\n\r\n            // Save to file\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(commitLog);\r\n            }\r\n\r\n            System.out.println(\"Commit log written to: \" + outputFile.getAbsolutePath());\r\n\r\n            // Verify log is not empty\r\n            assertNotNull(commitLog, \"Commit log should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commit log: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting commit log (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Create an output file in the target dir"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            // Get formatted commit log\r\n            String commitLog \u003d GitParser.getFormattedCommitLog(\".\", 10);\r\n\r\n            // Save to file\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(commitLog);\r\n            }\r\n\r\n            System.out.println(\"Commit log written to: \" + outputFile.getAbsolutePath());\r\n\r\n            // Verify log is not empty\r\n            assertNotNull(commitLog, \"Commit log should not be null\");\r\n\r\n        }",
          "javadoc": {
            "description": "Test getting commit log (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Create an output file in the target directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "file",
          "methodName": "try",
          "parameters": [
            {
              "type": "PrintWriter",
              "name": "writer"
            }
          ],
          "body": "{\r\n                writer.println(commitLog);\r\n            }",
          "comments": [
            "Get formatted commit log",
            "Save to file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "empty",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Commit",
              "name": "log"
            }
          ],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commit log: \" + e.getMessage());\r\n        }",
          "comments": [
            "Verify log is not empty"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "of",
          "methodName": "week",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get contributions by day of week\r\n            Map\u003cString, Integer\u003e contributionsByDay \u003d GitParser.getContributionsByDayOfWeek(\".\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d CONTRIBUTIONS BY DAY OF WEEK \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, Integer\u003e entry : contributionsByDay.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n            }\r\n\r\n            // Verify map is not empty\r\n            assertFalse(contributionsByDay.isEmpty(), \"Contributions by day should not be empty\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contributions by day: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testContributionsByDayOfWeek",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Get contributions by day of week\r\n            Map\u003cString, Integer\u003e contributionsByDay \u003d GitParser.getContributionsByDayOfWeek(\".\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d CONTRIBUTIONS BY DAY OF WEEK \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, Integer\u003e entry : contributionsByDay.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n            }\r\n\r\n            // Verify map is not empty\r\n            assertFalse(contributionsByDay.isEmpty(), \"Contributions by day should not be empty\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contributions by day: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test contributions by day of week (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Get cont"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "empty",
          "methodName": "assertFalse",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contributions by day: \" + e.getMessage());\r\n        }",
          "comments": [
            "Verify map is not empty"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "active",
          "methodName": "files",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get most active files\r\n            Map\u003cString, Integer\u003e activeFiles \u003d GitParser.getMostActiveFiles(\".\", 10);\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d MOST ACTIVE FILES \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, Integer\u003e entry : activeFiles.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue() + \" changes\");\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting most active files: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testMostActiveFiles",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Get most active files\r\n            Map\u003cString, Integer\u003e activeFiles \u003d GitParser.getMostActiveFiles(\".\", 10);\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d MOST ACTIVE FILES \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, Integer\u003e entry : activeFiles.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue() + \" changes\");\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting most active files: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting most active files (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Get most active f"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "current",
          "methodName": "year",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get current year\r\n            int currentYear \u003d Calendar.getInstance().get(Calendar.YEAR);\r\n\r\n            // Get contribution heat map\r\n            Map\u003cString, Integer\u003e heatMap \u003d GitParser.getContributionHeatMap(\".\", currentYear);\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d CONTRIBUTION HEAT MAP FOR \" + currentYear + \" \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + heatMap.size() + \" days in the heat map\");\r\n\r\n            // Print a sample of the heat map (first 10 days with commits)\r\n            int count \u003d 0;\r\n            for (Map.Entry\u003cString, Integer\u003e entry : heatMap.entrySet()) {\r\n                if (entry.getValue() \u003e 0) {\r\n                    System.out.println(entry.getKey() + \": \" + entry.getValue() + \" commits\");\r\n                    count++;\r\n\r\n                    if (count \u003e\u003d 10) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contribution heat map: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testContributionHeatMap",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Get current year\r\n            int currentYear \u003d Calendar.getInstance().get(Calendar.YEAR);\r\n\r\n            // Get contribution heat map\r\n            Map\u003cString, Integer\u003e heatMap \u003d GitParser.getContributionHeatMap(\".\", currentYear);\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d CONTRIBUTION HEAT MAP FOR \" + currentYear + \" \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + heatMap.size() + \" days in the heat map\");\r\n\r\n            // Print a sample of the heat map (first 10 days with commits)\r\n            int count \u003d 0;\r\n            for (Map.Entry\u003cString, Integer\u003e entry : heatMap.entrySet()) {\r\n                if (entry.getValue() \u003e 0) {\r\n                    System.out.println(entry.getKey() + \": \" + entry.getValue() + \" commits\");\r\n                    count++;\r\n\r\n                    if (count \u003e\u003d 10) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contribution heat map: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test contribution heat map for current year (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Get current y"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "heat",
          "methodName": "map",
          "parameters": [
            {
              "type": "first",
              "name": "10"
            }
          ],
          "body": "{\r\n                if (entry.getValue() \u003e 0) {\r\n                    System.out.println(entry.getKey() + \": \" + entry.getValue() + \" commits\");\r\n                    count++;\r\n\r\n                    if (count \u003e\u003d 10) {\r\n                        break;\r\n                    }\r\n                }\r\n            }",
          "comments": [
            "Print a sample of the heat map (first 10 days with commits)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testIsValidRepository",
          "parameters": [],
          "body": "{\r\n        // The current directory should be a valid repository if .git exists\r\n        File gitDir \u003d new File(\".git\");\r\n        boolean expected \u003d gitDir.exists() \u0026\u0026 gitDir.isDirectory();\r\n        boolean actual \u003d GitParser.isValidRepository(\".\");\r\n\r\n        assertEquals(expected, actual, \"isValidRepository should correctly identify a valid repository\");\r\n\r\n        // A non-existent directory should not be a valid repository\r\n        assertFalse(GitParser.isValidRepository(\"/non/existent/directory\"),\r\n                \"Non-existent directory should not be a valid repository\");\r\n    }",
          "javadoc": {
            "description": "Test isValidRepository method",
            "tags": []
          },
          "comments": [
            "The current directory should be a valid repository"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Use the current directory as the repository to parse\r\n            GitRepositoryInfo repoInfo \u003d GitParser.parseRepository(\".\");\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-parser-output.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }\r\n\r\n            // Basic assertions to make sure the parser works\r\n            assertNotNull(repoInfo.getName(), \"Repository name should not be null\");\r\n            assertNotNull(repoInfo.getCurrentBranch(), \"Current branch should not be null\");\r\n\r\n            // Don\u0027t assert on latest commit - it might be null in a fresh repo\r\n            // Only check commit count instead\r\n            assertTrue(repoInfo.getCommitCount() \u003e\u003d 0, \"Commit count should be zero or positive\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while parsing repository: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test isValidRepository method",
            "tags": []
          },
          "comments": [
            "The current directory should be a valid repository if .git exists"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "repository",
          "methodName": "assertFalse",
          "parameters": [],
          "body": "{\r\n        // Testing the findGitRepositories method on src directory\r\n        File srcDir \u003d new File(\"src\");\r\n        List\u003cFile\u003e gitRepos \u003d GitParser.findGitRepositories(srcDir);\r\n\r\n        System.out.println(\"\\n\u003d\u003d\u003d GIT REPOSITORIES FOUND IN SRC \u003d\u003d\u003d\");\r\n        if (gitRepos.isEmpty()) {\r\n            System.out.println(\"No Git repositories found in src directory\");\r\n        } else {\r\n            for (File repo : gitRepos) {\r\n                System.out.println(repo.getAbsolutePath());\r\n            }\r\n        }\r\n\r\n        // Also try at project root level\r\n        File projectDir \u003d new File(\".\");\r\n        List\u003cFile\u003e rootGitRepos \u003d GitParser.findGitRepositories(projectDir);\r\n\r\n        System.out.println(\"\\n\u003d\u003d\u003d GIT REPOSITORIES FOUND AT ROOT \u003d\u003d\u003d\");\r\n        assertTrue(rootGitRepos.size() \u003e\u003d 0, \"Should be able to find repositories without error\");\r\n\r\n        for (File repo : rootGitRepos) {\r\n            System.out.println(repo.getAbsolutePath());\r\n            // Verify it\u0027s a valid repository\r\n            assertTrue(GitParser.isValidRepository(repo.getAbsolutePath()),\r\n                    \"Found repository should be valid: \" + repo.getAbsolutePath());\r\n        }\r\n    }",
          "comments": [
            "A non-existent directory should not be a valid repository"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testFindGitRepositories",
          "parameters": [],
          "body": "{\r\n        // Testing the findGitRepositories method on src directory\r\n        File srcDir \u003d new File(\"src\");\r\n        List\u003cFile\u003e gitRepos \u003d GitParser.findGitRepositories(srcDir);\r\n\r\n        System.out.println(\"\\n\u003d\u003d\u003d GIT REPOSITORIES FOUND IN SRC \u003d\u003d\u003d\");\r\n        if (gitRepos.isEmpty()) {\r\n            System.out.println(\"No Git repositories found in src directory\");\r\n        } else {\r\n            for (File repo : gitRepos) {\r\n                System.out.println(repo.getAbsolutePath());\r\n            }\r\n        }\r\n\r\n        // Also try at project root level\r\n        File projectDir \u003d new File(\".\");\r\n        List\u003cFile\u003e rootGitRepos \u003d GitParser.findGitRepositories(projectDir);\r\n\r\n        System.out.println(\"\\n\u003d\u003d\u003d GIT REPOSITORIES FOUND AT ROOT \u003d\u003d\u003d\");\r\n        assertTrue(rootGitRepos.size() \u003e\u003d 0, \"Should be able to find repositories without error\");\r\n\r\n        for (File repo : rootGitRepos) {\r\n            System.out.println(repo.getAbsolutePath());\r\n            // Verify it\u0027s a valid repository\r\n            assertTrue(GitParser.isValidRepository(repo.getAbsolutePath()),\r\n                    \"Found repository should be valid: \" + repo.getAbsolutePath());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test findGitRepositories method",
            "tags": []
          },
          "comments": [
            "Testing the findGitRepositories method on src dir"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            System.out.println(\"No Git repositories found in src directory\");\r\n        }",
          "javadoc": {
            "description": "Test findGitRepositories method",
            "tags": []
          },
          "comments": [
            "Testing the findGitRepositories method on src directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            System.out.println(repo.getAbsolutePath());\r\n            // Verify it\u0027s a valid repository\r\n            assertTrue(GitParser.isValidRepository(repo.getAbsolutePath()),\r\n                    \"Found repository should be valid: \" + repo.getAbsolutePath());\r\n        }",
          "comments": [
            "Also try at project root level"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "repository",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        // Create a temporary directory that\u0027s definitely not a Git repo\r\n        File tempDir \u003d new File(\"target/temp-non-git-dir\");\r\n        tempDir.mkdirs();\r\n\r\n        assertFalse(GitParser.isValidRepository(tempDir.getAbsolutePath()),\r\n                \"Non-Git directory should not be identified as a valid repository\");\r\n\r\n        // Cleanup\r\n        tempDir.delete();\r\n    }",
          "comments": [
            "Verify it\u0027s a valid repository"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testNonGitDirectory",
          "parameters": [],
          "body": "{\r\n        // Create a temporary directory that\u0027s definitely not a Git repo\r\n        File tempDir \u003d new File(\"target/temp-non-git-dir\");\r\n        tempDir.mkdirs();\r\n\r\n        assertFalse(GitParser.isValidRepository(tempDir.getAbsolutePath()),\r\n                \"Non-Git directory should not be identified as a valid repository\");\r\n\r\n        // Cleanup\r\n        tempDir.delete();\r\n    }",
          "javadoc": {
            "description": "Test that the GitParser can handle a non-Git directory",
            "tags": []
          },
          "comments": [
            "Create a temporary directory that\u0027s definitely not a"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Get the 5 most recent commits\r\n            List\u003cCommitInfo\u003e recentCommits \u003d GitParser.getRecentCommits(\".\", 5);\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-recent-commits.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(\"\u003d\u003d\u003d RECENT COMMITS \u003d\u003d\u003d\");\r\n                writer.println(\"Found \" + recentCommits.size() + \" recent commits:\");\r\n\r\n                SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n                for (CommitInfo commit : recentCommits) {\r\n                    writer.println(\"\\nCommit: \" + commit.getShortId());\r\n                    writer.println(\"Author: \" + commit.getAuthorName() + \" \u003c\" + commit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + dateFormat.format(commit.getAuthorDate()));\r\n                    writer.println(\"Message: \" + commit.getMessage());\r\n\r\n                    // Print changed files\r\n                    if (commit.getChangedFiles() !\u003d null \u0026\u0026 !commit.getChangedFiles().isEmpty()) {\r\n                        writer.println(\"Changed Files:\");\r\n\r\n                        for (FileChange change : commit.getChangedFiles()) {\r\n                            writer.println(\"  \" + change.getType() + \": \" + change.getPath());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            System.out.println(\"Recent commits written to: \" + outputFile.getAbsolutePath());\r\n\r\n            // Verify we got some commits (unless it\u0027s a brand new repo)\r\n            assertNotNull(recentCommits, \"Recent commits should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting recent commits: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test that the GitParser can handle a non-Git directory",
            "tags": []
          },
          "comments": [
            "Create a temporary directory that\u0027s definitely not a Git repo"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "recent",
          "methodName": "commits",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get the 5 most recent commits\r\n            List\u003cCommitInfo\u003e recentCommits \u003d GitParser.getRecentCommits(\".\", 5);\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-recent-commits.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(\"\u003d\u003d\u003d RECENT COMMITS \u003d\u003d\u003d\");\r\n                writer.println(\"Found \" + recentCommits.size() + \" recent commits:\");\r\n\r\n                SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n                for (CommitInfo commit : recentCommits) {\r\n                    writer.println(\"\\nCommit: \" + commit.getShortId());\r\n                    writer.println(\"Author: \" + commit.getAuthorName() + \" \u003c\" + commit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + dateFormat.format(commit.getAuthorDate()));\r\n                    writer.println(\"Message: \" + commit.getMessage());\r\n\r\n                    // Print changed files\r\n                    if (commit.getChangedFiles() !\u003d null \u0026\u0026 !commit.getChangedFiles().isEmpty()) {\r\n                        writer.println(\"Changed Files:\");\r\n\r\n                        for (FileChange change : commit.getChangedFiles()) {\r\n                            writer.println(\"  \" + change.getType() + \": \" + change.getPath());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            System.out.println(\"Recent commits written to: \" + outputFile.getAbsolutePath());\r\n\r\n            // Verify we got some commits (unless it\u0027s a brand new repo)\r\n            assertNotNull(recentCommits, \"Recent commits should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting recent commits: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": [
            "Cleanup"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "recent",
          "methodName": "commits",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get the 5 most recent commits\r\n            List\u003cCommitInfo\u003e recentCommits \u003d GitParser.getRecentCommits(\".\", 5);\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-recent-commits.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(\"\u003d\u003d\u003d RECENT COMMITS \u003d\u003d\u003d\");\r\n                writer.println(\"Found \" + recentCommits.size() + \" recent commits:\");\r\n\r\n                SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n                for (CommitInfo commit : recentCommits) {\r\n                    writer.println(\"\\nCommit: \" + commit.getShortId());\r\n                    writer.println(\"Author: \" + commit.getAuthorName() + \" \u003c\" + commit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + dateFormat.format(commit.getAuthorDate()));\r\n                    writer.println(\"Message: \" + commit.getMessage());\r\n\r\n                    // Print changed files\r\n                    if (commit.getChangedFiles() !\u003d null \u0026\u0026 !commit.getChangedFiles().isEmpty()) {\r\n                        writer.println(\"Changed Files:\");\r\n\r\n                        for (FileChange change : commit.getChangedFiles()) {\r\n                            writer.println(\"  \" + change.getType() + \": \" + change.getPath());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            System.out.println(\"Recent commits written to: \" + outputFile.getAbsolutePath());\r\n\r\n            // Verify we got some commits (unless it\u0027s a brand new repo)\r\n            assertNotNull(recentCommits, \"Recent commits should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting recent commits: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting recent commits (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Cleanup"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testGetRecentCommits",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Get the 5 most recent commits\r\n            List\u003cCommitInfo\u003e recentCommits \u003d GitParser.getRecentCommits(\".\", 5);\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-recent-commits.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(\"\u003d\u003d\u003d RECENT COMMITS \u003d\u003d\u003d\");\r\n                writer.println(\"Found \" + recentCommits.size() + \" recent commits:\");\r\n\r\n                SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n                for (CommitInfo commit : recentCommits) {\r\n                    writer.println(\"\\nCommit: \" + commit.getShortId());\r\n                    writer.println(\"Author: \" + commit.getAuthorName() + \" \u003c\" + commit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + dateFormat.format(commit.getAuthorDate()));\r\n                    writer.println(\"Message: \" + commit.getMessage());\r\n\r\n                    // Print changed files\r\n                    if (commit.getChangedFiles() !\u003d null \u0026\u0026 !commit.getChangedFiles().isEmpty()) {\r\n                        writer.println(\"Changed Files:\");\r\n\r\n                        for (FileChange change : commit.getChangedFiles()) {\r\n                            writer.println(\"  \" + change.getType() + \": \" + change.getPath());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            System.out.println(\"Recent commits written to: \" + outputFile.getAbsolutePath());\r\n\r\n            // Verify we got some commits (unless it\u0027s a brand new repo)\r\n            assertNotNull(recentCommits, \"Recent commits should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting recent commits: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting recent commits (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Get the 5 most r"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                writer.println(\"\u003d\u003d\u003d RECENT COMMITS \u003d\u003d\u003d\");\r\n                writer.println(\"Found \" + recentCommits.size() + \" recent commits:\");\r\n\r\n                SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n                for (CommitInfo commit : recentCommits) {\r\n                    writer.println(\"\\nCommit: \" + commit.getShortId());\r\n                    writer.println(\"Author: \" + commit.getAuthorName() + \" \u003c\" + commit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + dateFormat.format(commit.getAuthorDate()));\r\n                    writer.println(\"Message: \" + commit.getMessage());\r\n\r\n                    // Print changed files\r\n                    if (commit.getChangedFiles() !\u003d null \u0026\u0026 !commit.getChangedFiles().isEmpty()) {\r\n                        writer.println(\"Changed Files:\");\r\n\r\n                        for (FileChange change : commit.getChangedFiles()) {\r\n                            writer.println(\"  \" + change.getType() + \": \" + change.getPath());\r\n                        }\r\n                    }\r\n                }\r\n            }",
          "javadoc": {
            "description": "Test getting recent commits (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Create an output file in the target directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [
            {
              "type": "\"yyyy-MM-dd",
              "name": "HH:mm:ss\""
            }
          ],
          "body": "{\r\n                    writer.println(\"\\nCommit: \" + commit.getShortId());\r\n                    writer.println(\"Author: \" + commit.getAuthorName() + \" \u003c\" + commit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + dateFormat.format(commit.getAuthorDate()));\r\n                    writer.println(\"Message: \" + commit.getMessage());\r\n\r\n                    // Print changed files\r\n                    if (commit.getChangedFiles() !\u003d null \u0026\u0026 !commit.getChangedFiles().isEmpty()) {\r\n                        writer.println(\"Changed Files:\");\r\n\r\n                        for (FileChange change : commit.getChangedFiles()) {\r\n                            writer.println(\"  \" + change.getType() + \": \" + change.getPath());\r\n                        }\r\n                    }\r\n                }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "files",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                        writer.println(\"Changed Files:\");\r\n\r\n                        for (FileChange change : commit.getChangedFiles()) {\r\n                            writer.println(\"  \" + change.getType() + \": \" + change.getPath());\r\n                        }\r\n                    }",
          "comments": [
            "Print changed files"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "some",
          "methodName": "commits",
          "parameters": [
            {
              "type": "unless",
              "name": "it\u0027s"
            }
          ],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting recent commits: \" + e.getMessage());\r\n        }",
          "comments": [
            "Verify we got some commits (unless it\u0027s a brand new repo)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "by",
          "methodName": "author",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // First, get any commit to find an author\u0027s name\r\n            List\u003cCommitInfo\u003e commits \u003d GitParser.getRecentCommits(\".\", 1);\r\n\r\n            if (!commits.isEmpty()) {\r\n                String authorName \u003d commits.get(0).getAuthorName();\r\n\r\n                // Now use that author name to find their commits\r\n                List\u003cCommitInfo\u003e authorCommits \u003d GitParser.getCommitsByAuthor(\".\", authorName);\r\n\r\n                System.out.println(\"\\n\u003d\u003d\u003d COMMITS BY \" + authorName + \" \u003d\u003d\u003d\");\r\n                System.out.println(\"Found \" + authorCommits.size() + \" commits\");\r\n\r\n                for (int i \u003d 0; i \u003c Math.min(5, authorCommits.size()); i++) {\r\n                    CommitInfo commit \u003d authorCommits.get(i);\r\n                    System.out.println(commit.getShortId() + \": \" + commit.getMessage());\r\n                }\r\n\r\n                // Verify we found at least the one commit we know this author made\r\n                assertTrue(authorCommits.size() \u003e\u003d 1,\r\n                        \"Should find at least one commit by \" + authorName);\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by author: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testGetCommitsByAuthor",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // First, get any commit to find an author\u0027s name\r\n            List\u003cCommitInfo\u003e commits \u003d GitParser.getRecentCommits(\".\", 1);\r\n\r\n            if (!commits.isEmpty()) {\r\n                String authorName \u003d commits.get(0).getAuthorName();\r\n\r\n                // Now use that author name to find their commits\r\n                List\u003cCommitInfo\u003e authorCommits \u003d GitParser.getCommitsByAuthor(\".\", authorName);\r\n\r\n                System.out.println(\"\\n\u003d\u003d\u003d COMMITS BY \" + authorName + \" \u003d\u003d\u003d\");\r\n                System.out.println(\"Found \" + authorCommits.size() + \" commits\");\r\n\r\n                for (int i \u003d 0; i \u003c Math.min(5, authorCommits.size()); i++) {\r\n                    CommitInfo commit \u003d authorCommits.get(i);\r\n                    System.out.println(commit.getShortId() + \": \" + commit.getMessage());\r\n                }\r\n\r\n                // Verify we found at least the one commit we know this author made\r\n                assertTrue(authorCommits.size() \u003e\u003d 1,\r\n                        \"Should find at least one commit by \" + authorName);\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by author: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting commits by author (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "First, get any"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "made",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by author: \" + e.getMessage());\r\n        }",
          "comments": [
            "Verify we found at least the one commit we know this author made"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "date",
          "methodName": "range",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get current date\r\n            Calendar calendar \u003d Calendar.getInstance();\r\n            Date today \u003d calendar.getTime();\r\n\r\n            // Set date one year ago\r\n            calendar.add(Calendar.YEAR, -1);\r\n            Date oneYearAgo \u003d calendar.getTime();\r\n\r\n            // Get commits in the last year\r\n            List\u003cCommitInfo\u003e yearCommits \u003d GitParser.getCommitsByDateRange(\".\", oneYearAgo, today);\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d COMMITS IN THE LAST YEAR \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + yearCommits.size() + \" commits between \" +\r\n                    new SimpleDateFormat(\"yyyy-MM-dd\").format(oneYearAgo) + \" and \" +\r\n                    new SimpleDateFormat(\"yyyy-MM-dd\").format(today));\r\n\r\n            // Verify we got a result (might be empty for new repos)\r\n            assertNotNull(yearCommits, \"Year commits should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by date range: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testGetCommitsByDateRange",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Get current date\r\n            Calendar calendar \u003d Calendar.getInstance();\r\n            Date today \u003d calendar.getTime();\r\n\r\n            // Set date one year ago\r\n            calendar.add(Calendar.YEAR, -1);\r\n            Date oneYearAgo \u003d calendar.getTime();\r\n\r\n            // Get commits in the last year\r\n            List\u003cCommitInfo\u003e yearCommits \u003d GitParser.getCommitsByDateRange(\".\", oneYearAgo, today);\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d COMMITS IN THE LAST YEAR \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + yearCommits.size() + \" commits between \" +\r\n                    new SimpleDateFormat(\"yyyy-MM-dd\").format(oneYearAgo) + \" and \" +\r\n                    new SimpleDateFormat(\"yyyy-MM-dd\").format(today));\r\n\r\n            // Verify we got a result (might be empty for new repos)\r\n            assertNotNull(yearCommits, \"Year commits should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by date range: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting commits by date range (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Get current"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by date range: \" + e.getMessage());\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by date range: \" + e.getMessage());\r\n        }",
          "comments": [
            "Verify we"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "a",
          "methodName": "result",
          "parameters": [
            {
              "type": "might",
              "name": "be"
            }
          ],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by date range: \" + e.getMessage());\r\n        }",
          "comments": [
            "Verify we got a result (might be empty for new repos)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "specific",
          "methodName": "file",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // First, find a file in the repository\r\n            File gitParserFile \u003d new File(\"src/main/java/io/joshuasalcedo/parsers/GitParser.java\");\r\n\r\n            if (!gitParserFile.exists()) {\r\n                System.out.println(\"GitParser.java file not found, skipping file history test\");\r\n                return;\r\n            }\r\n\r\n            // Get history for the file\r\n            List\u003cCommitInfo\u003e fileHistory \u003d GitParser.getFileHistory(\".\",\r\n                    \"src/main/java/io/joshuasalcedo/parsers/GitParser.java\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d FILE HISTORY FOR GitParser.java \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + fileHistory.size() + \" commits that modified this file\");\r\n\r\n            for (int i \u003d 0; i \u003c Math.min(5, fileHistory.size()); i++) {\r\n                CommitInfo commit \u003d fileHistory.get(i);\r\n                System.out.println(commit.getShortId() + \" (\" +\r\n                        new SimpleDateFormat(\"yyyy-MM-dd\").format(commit.getAuthorDate()) +\r\n                        \"): \" + commit.getMessage());\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting file history: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testGetFileHistory",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // First, find a file in the repository\r\n            File gitParserFile \u003d new File(\"src/main/java/io/joshuasalcedo/parsers/GitParser.java\");\r\n\r\n            if (!gitParserFile.exists()) {\r\n                System.out.println(\"GitParser.java file not found, skipping file history test\");\r\n                return;\r\n            }\r\n\r\n            // Get history for the file\r\n            List\u003cCommitInfo\u003e fileHistory \u003d GitParser.getFileHistory(\".\",\r\n                    \"src/main/java/io/joshuasalcedo/parsers/GitParser.java\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d FILE HISTORY FOR GitParser.java \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + fileHistory.size() + \" commits that modified this file\");\r\n\r\n            for (int i \u003d 0; i \u003c Math.min(5, fileHistory.size()); i++) {\r\n                CommitInfo commit \u003d fileHistory.get(i);\r\n                System.out.println(commit.getShortId() + \" (\" +\r\n                        new SimpleDateFormat(\"yyyy-MM-dd\").format(commit.getAuthorDate()) +\r\n                        \"): \" + commit.getMessage());\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting file history: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting file history for a specific file (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "First, find a file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                System.out.println(\"GitParser.java file not found, skipping file history test\");\r\n                return;\r\n            }",
          "javadoc": {
            "description": "Test getting file history for a specific file (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "First, find a file in the repository"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting file history: \" + e.getMessage());\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "of",
          "methodName": "day",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get contributions by hour of day\r\n            Map\u003cInteger, Integer\u003e contributionsByHour \u003d GitParser.getContributionsByHourOfDay(\".\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d CONTRIBUTIONS BY HOUR OF DAY \u003d\u003d\u003d\");\r\n            for (int hour \u003d 0; hour \u003c 24; hour++) {\r\n                System.out.println(String.format(\"%02d:00\", hour) + \" - \" + contributionsByHour.get(hour) + \" commits\");\r\n            }\r\n\r\n            // Verify map is not empty and has 24 hours\r\n            assertFalse(contributionsByHour.isEmpty(), \"Contributions by hour should not be empty\");\r\n            assertEquals(24, contributionsByHour.size(), \"Contributions by hour should have 24 entries\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contributions by hour: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testContributionsByHourOfDay",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Get contributions by hour of day\r\n            Map\u003cInteger, Integer\u003e contributionsByHour \u003d GitParser.getContributionsByHourOfDay(\".\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d CONTRIBUTIONS BY HOUR OF DAY \u003d\u003d\u003d\");\r\n            for (int hour \u003d 0; hour \u003c 24; hour++) {\r\n                System.out.println(String.format(\"%02d:00\", hour) + \" - \" + contributionsByHour.get(hour) + \" commits\");\r\n            }\r\n\r\n            // Verify map is not empty and has 24 hours\r\n            assertFalse(contributionsByHour.isEmpty(), \"Contributions by hour should not be empty\");\r\n            assertEquals(24, contributionsByHour.size(), \"Contributions by hour should have 24 entries\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contributions by hour: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test contribution statistics by hour of day (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Get cont"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "hours",
          "methodName": "assertFalse",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contributions by hour: \" + e.getMessage());\r\n        }",
          "comments": [
            "Verify map is not empty and has 24 hours"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "specific",
          "methodName": "file",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // First, find a file in the repository\r\n            File gitParserFile \u003d new File(\"src/main/java/io/joshuasalcedo/parsers/GitParser.java\");\r\n\r\n            if (!gitParserFile.exists()) {\r\n                System.out.println(\"GitParser.java file not found, skipping file history test\");\r\n                return;\r\n            }\r\n\r\n            // Get history for the file\r\n            List\u003cCommitInfo\u003e fileHistory \u003d GitParser.getFileHistory(\".\",\r\n                    \"src/main/java/io/joshuasalcedo/parsers/GitParser.java\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d FILE HISTORY FOR GitParser.java \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + fileHistory.size() + \" commits that modified this file\");\r\n\r\n            for (int i \u003d 0; i \u003c Math.min(5, fileHistory.size()); i++) {\r\n                CommitInfo commit \u003d fileHistory.get(i);\r\n                System.out.println(commit.getShortId() + \" (\" +\r\n                        new SimpleDateFormat(\"yyyy-MM-dd\").format(commit.getAuthorDate()) +\r\n                        \"): \" + commit.getMessage());\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting file history: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testGetFileBlame",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Find a Java file that\u0027s likely to exist and have commits\r\n            String filePath \u003d null;\r\n\r\n            // Check if GitParser.java exists\r\n            File gitParserFile \u003d new File(\"src/main/java/io/joshuasalcedo/parsers/GitParser.java\");\r\n            if (gitParserFile.exists()) {\r\n                filePath \u003d \"src/main/java/io/joshuasalcedo/parsers/GitParser.java\";\r\n            } else {\r\n                // If not, try to find any Java file\r\n                File srcDir \u003d new File(\"src\");\r\n                if (srcDir.exists()) {\r\n                    List\u003cFile\u003e javaFiles \u003d findJavaFiles(srcDir);\r\n                    if (!javaFiles.isEmpty()) {\r\n                        filePath \u003d javaFiles.get(0).getPath();\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (filePath \u003d\u003d null) {\r\n                System.out.println(\"No suitable Java file found for blame test, skipping\");\r\n                return;\r\n            }\r\n\r\n            System.out.println(\"Running blame test on file: \" + filePath);\r\n\r\n            // Create a simple implementation to get blame info\r\n            String blameInfo \u003d getSimpleBlameInfo(filePath);\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-file-blame.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(\"\u003d\u003d\u003d BLAME INFO FOR \" + filePath + \" \u003d\u003d\u003d\");\r\n                writer.println(blameInfo);\r\n            }\r\n\r\n            System.out.println(\"Blame info written to: \" + outputFile.getAbsolutePath());\r\n\r\n        } catch (IOException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting file blame: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting file blame for a specific file (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Find a Java file tha"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                System.out.println(\"GitParser.java file not found, skipping file history test\");\r\n                return;\r\n            }",
          "javadoc": {
            "description": "Test getting file blame for a specific file (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Find a Java file that\u0027s likely to exist and have commits",
            "Check if GitParser.java exists"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            System.out.println(\"No Git repositories found in src directory\");\r\n        }",
          "comments": [
            "If not, try to find any Java file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                writer.println(\"\u003d\u003d\u003d BLAME INFO FOR \" + filePath + \" \u003d\u003d\u003d\");\r\n                writer.println(blameInfo);\r\n            }",
          "comments": [
            "Create an output file in the target directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "List\u003cFile\u003e",
          "methodName": "findJavaFiles",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            }
          ],
          "body": "{\r\n        List\u003cFile\u003e javaFiles \u003d new ArrayList\u003c\u003e();\r\n        File[] files \u003d directory.listFiles();\r\n        if (files !\u003d null) {\r\n            for (File file : files) {\r\n                if (file.isDirectory()) {\r\n                    javaFiles.addAll(findJavaFiles(file));\r\n                } else if (file.getName().endsWith(\".java\")) {\r\n                    javaFiles.add(file);\r\n                }\r\n            }\r\n        }\r\n        return javaFiles;\r\n    }",
          "javadoc": {
            "description": "Helper method to find Java files in a directory",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    javaFiles.add(file);\r\n                }",
          "javadoc": {
            "description": "Helper method to find Java files in a directory",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "String",
          "methodName": "getSimpleBlameInfo",
          "parameters": [
            {
              "type": "String",
              "name": "filePath"
            }
          ],
          "body": "{\r\n        // Use git command line instead of JGit to avoid potential null pointer issues\r\n        try {\r\n            ProcessBuilder pb \u003d new ProcessBuilder(\"git\", \"blame\", filePath);\r\n            pb.redirectErrorStream(true);\r\n            Process process \u003d pb.start();\r\n\r\n            // Read the output\r\n            StringBuilder output \u003d new StringBuilder();\r\n            try (BufferedReader reader \u003d new BufferedReader(\r\n                    new InputStreamReader(process.getInputStream()))) {\r\n                String line;\r\n                while ((line \u003d reader.readLine()) !\u003d null) {\r\n                    output.append(line).append(\"\\n\");\r\n                }\r\n            }\r\n\r\n            // Wait for the process to complete\r\n            int exitCode \u003d process.waitFor();\r\n\r\n            if (exitCode \u003d\u003d 0) {\r\n                return output.toString();\r\n            } else {\r\n                return \"Failed to get blame info. Exit code: \" + exitCode;\r\n            }\r\n        } catch (Exception e) {\r\n            return \"Error getting blame info: \" + e.getMessage();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Simple implementation to get blame info without using JGit directly",
            "tags": []
          },
          "comments": [
            "Use git command"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ProcessBuilder",
          "parameters": [],
          "body": "{\r\n                String line;\r\n                while ((line \u003d reader.readLine()) !\u003d null) {\r\n                    output.append(line).append(\"\\n\");\r\n                }\r\n            }",
          "javadoc": {
            "description": "Simple implementation to get blame info without using JGit directly",
            "tags": []
          },
          "comments": [
            "Use git command line instead of JGit to avoid potential null pointer issues"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StringBuilder",
          "parameters": [],
          "body": "{\r\n                String line;\r\n                while ((line \u003d reader.readLine()) !\u003d null) {\r\n                    output.append(line).append(\"\\n\");\r\n                }\r\n            }",
          "comments": [
            "Read the output"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "BufferedReader",
          "parameters": [
            {
              "type": "new",
              "name": "InputStreamReader(process.getInputStream("
            }
          ],
          "body": "{\r\n                String line;\r\n                while ((line \u003d reader.readLine()) !\u003d null) {\r\n                    output.append(line).append(\"\\n\");\r\n                }\r\n            }",
          "comments": [
            "Read the output"
          ]
        }
      ],
      "className": "GitParserTest",
      "packageName": "io.joshuasalcedo.parsers"
    },
    "src/main/java/io/joshuasalcedo/model/maven/PluginConfiguration.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/maven/PluginConfiguration.java",
      "methods": [],
      "className": "PluginConfiguration",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    "src/main/java/io/joshuasalcedo/model/maven/Plugin.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/maven/Plugin.java",
      "methods": [],
      "className": "Plugin",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    "src/main/java/io/joshuasalcedo/utility/UtilityTest.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/utility/UtilityTest.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "main",
          "parameters": [
            {
              "type": "String[]",
              "name": "args"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get the current directory\r\n            String testDir \u003d System.getProperty(\"user.dir\");\r\n            System.out.println(\"Testing with directory: \" + testDir);\r\n            \r\n            System.out.println(\"\\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d FileUtils Test \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\");\r\n            testFileUtils(testDir);\r\n            \r\n            System.out.println(\"\\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d JsonUtils Test \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\");\r\n            testJsonUtils();\r\n            \r\n            System.out.println(\"\\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d All Tests Completed Successfully \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\");\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error during test: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test class for utility tools.",
            "tags": []
          },
          "comments": [
            "Get the current directory"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "testFileUtils",
          "parameters": [
            {
              "type": "String",
              "name": "testDir"
            }
          ],
          "body": "{\r\n        // Test 1: List all files\r\n        System.out.println(\"Test 1: Listing all files (not respecting .gitignore)\");\r\n        List\u003cFile\u003e allFiles \u003d FileUtils.listAllFiles(testDir, false);\r\n        System.out.println(\"Found \" + allFiles.size() + \" files\");\r\n        printFileSample(allFiles, 5);\r\n        \r\n        // Test 2: List all files respecting .gitignore\r\n        System.out.println(\"\\nTest 2: Listing all files (respecting .gitignore)\");\r\n        List\u003cFile\u003e nonIgnoredFiles \u003d FileUtils.listAllFiles(testDir, true);\r\n        System.out.println(\"Found \" + nonIgnoredFiles.size() + \" files\");\r\n        printFileSample(nonIgnoredFiles, 5);\r\n        \r\n        // Test 3: List files by extension\r\n        System.out.println(\"\\nTest 3: Listing Java files\");\r\n        List\u003cFile\u003e javaFiles \u003d FileUtils.listFilesByExtension(testDir, \"java\");\r\n        System.out.println(\"Found \" + javaFiles.size() + \" Java files\");\r\n        printFileSample(javaFiles, 5);\r\n        \r\n        // Test 4: List text files\r\n        System.out.println(\"\\nTest 4: Listing text files\");\r\n        List\u003cFile\u003e textFiles \u003d FileUtils.listTextFiles(testDir, false);\r\n        System.out.println(\"Found \" + textFiles.size() + \" text files\");\r\n        printFileSample(textFiles, 5);\r\n        \r\n        // Test 5: List files matching a predicate (files larger than 10KB)\r\n        System.out.println(\"\\nTest 5: Listing files larger than 10KB\");\r\n        List\u003cFile\u003e largeFiles \u003d FileUtils.listFilesMatching(testDir, false, file -\u003e file.length() \u003e 10 * 1024);\r\n        System.out.println(\"Found \" + largeFiles.size() + \" files larger than 10KB\");\r\n        printFileSample(largeFiles, 5);\r\n        \r\n        // Test 6: Individual file operations\r\n        System.out.println(\"\\nTest 6: Individual file operations\");\r\n        if (!javaFiles.isEmpty()) {\r\n            File sampleFile \u003d javaFiles.get(0);\r\n            System.out.println(\"Sample file: \" + sampleFile.getAbsolutePath());\r\n            System.out.println(\"  Is text file: \" + FileUtils.isTextFile(sampleFile));\r\n            System.out.println(\"  Base name: \" + FileUtils.getFileBaseName(sampleFile));\r\n            System.out.println(\"  Extension: \" + FileUtils.getFileExtension(sampleFile));\r\n            System.out.println(\"  Size: \" + FileUtils.getHumanReadableSize(sampleFile));\r\n            System.out.println(\"  Is readable: \" + FileUtils.isFileReadable(sampleFile));\r\n            System.out.println(\"  Is writable: \" + FileUtils.isFileWritable(sampleFile));\r\n            \r\n            if (FileUtils.isTextFile(sampleFile) \u0026\u0026 sampleFile.length() \u003c 10_000) {\r\n                String content \u003d FileUtils.readFileAsString(sampleFile);\r\n                System.out.println(\"  First 100 chars: \" + content.substring(0, Math.min(100, content.length())) + \"...\");\r\n            }\r\n        }\r\n        \r\n        // Test 7: Find binary files\r\n        System.out.println(\"\\nTest 7: Finding binary files\");\r\n        List\u003cFile\u003e binaryFiles \u003d FileUtils.listFilesMatching(testDir, false, file -\u003e !FileUtils.isTextFile(file));\r\n        System.out.println(\"Found \" + binaryFiles.size() + \" binary files\");\r\n        printFileSample(binaryFiles, 5);\r\n        \r\n        // Test 8: Create and write to a test file\r\n        System.out.println(\"\\nTest 8: File writing\");\r\n        File tempFile \u003d new File(\"fileutils_test.txt\");\r\n        FileUtils.writeStringToFile(tempFile, \"This is a test file created by FileUtils\\nLine 2\\nLine 3\");\r\n        System.out.println(\"Created file: \" + tempFile.getAbsolutePath());\r\n        System.out.println(\"  Content: \" + FileUtils.readFileAsString(tempFile));\r\n        \r\n        // Clean up test file\r\n        if (tempFile.exists()) {\r\n            tempFile.delete();\r\n            System.out.println(\"  Test file deleted\");\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test FileUtils functionality",
            "tags": []
          },
          "comments": [
            "Test 1: List all"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "all",
          "methodName": "files",
          "parameters": [
            {
              "type": "not",
              "name": "respecting"
            }
          ],
          "body": "{\r\n            File sampleFile \u003d javaFiles.get(0);\r\n            System.out.println(\"Sample file: \" + sampleFile.getAbsolutePath());\r\n            System.out.println(\"  Is text file: \" + FileUtils.isTextFile(sampleFile));\r\n            System.out.println(\"  Base name: \" + FileUtils.getFileBaseName(sampleFile));\r\n            System.out.println(\"  Extension: \" + FileUtils.getFileExtension(sampleFile));\r\n            System.out.println(\"  Size: \" + FileUtils.getHumanReadableSize(sampleFile));\r\n            System.out.println(\"  Is readable: \" + FileUtils.isFileReadable(sampleFile));\r\n            System.out.println(\"  Is writable: \" + FileUtils.isFileWritable(sampleFile));\r\n            \r\n            if (FileUtils.isTextFile(sampleFile) \u0026\u0026 sampleFile.length() \u003c 10_000) {\r\n                String content \u003d FileUtils.readFileAsString(sampleFile);\r\n                System.out.println(\"  First 100 chars: \" + content.substring(0, Math.min(100, content.length())) + \"...\");\r\n            }\r\n        }",
          "javadoc": {
            "description": "Test FileUtils functionality",
            "tags": []
          },
          "comments": [
            "Test 1: List all files"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "all",
          "methodName": "files",
          "parameters": [
            {
              "type": "respecting",
              "name": ".gitignore"
            }
          ],
          "body": "{\r\n            File sampleFile \u003d javaFiles.get(0);\r\n            System.out.println(\"Sample file: \" + sampleFile.getAbsolutePath());\r\n            System.out.println(\"  Is text file: \" + FileUtils.isTextFile(sampleFile));\r\n            System.out.println(\"  Base name: \" + FileUtils.getFileBaseName(sampleFile));\r\n            System.out.println(\"  Extension: \" + FileUtils.getFileExtension(sampleFile));\r\n            System.out.println(\"  Size: \" + FileUtils.getHumanReadableSize(sampleFile));\r\n            System.out.println(\"  Is readable: \" + FileUtils.isFileReadable(sampleFile));\r\n            System.out.println(\"  Is writable: \" + FileUtils.isFileWritable(sampleFile));\r\n            \r\n            if (FileUtils.isTextFile(sampleFile) \u0026\u0026 sampleFile.length() \u003c 10_000) {\r\n                String content \u003d FileUtils.readFileAsString(sampleFile);\r\n                System.out.println(\"  First 100 chars: \" + content.substring(0, Math.min(100, content.length())) + \"...\");\r\n            }\r\n        }",
          "comments": [
            "Test 2: List all files respecting .gitignore"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "a",
          "methodName": "predicate",
          "parameters": [
            {
              "type": "files",
              "name": "larger"
            }
          ],
          "body": "{\r\n            File sampleFile \u003d javaFiles.get(0);\r\n            System.out.println(\"Sample file: \" + sampleFile.getAbsolutePath());\r\n            System.out.println(\"  Is text file: \" + FileUtils.isTextFile(sampleFile));\r\n            System.out.println(\"  Base name: \" + FileUtils.getFileBaseName(sampleFile));\r\n            System.out.println(\"  Extension: \" + FileUtils.getFileExtension(sampleFile));\r\n            System.out.println(\"  Size: \" + FileUtils.getHumanReadableSize(sampleFile));\r\n            System.out.println(\"  Is readable: \" + FileUtils.isFileReadable(sampleFile));\r\n            System.out.println(\"  Is writable: \" + FileUtils.isFileWritable(sampleFile));\r\n            \r\n            if (FileUtils.isTextFile(sampleFile) \u0026\u0026 sampleFile.length() \u003c 10_000) {\r\n                String content \u003d FileUtils.readFileAsString(sampleFile);\r\n                System.out.println(\"  First 100 chars: \" + content.substring(0, Math.min(100, content.length())) + \"...\");\r\n            }\r\n        }",
          "comments": [
            "Test 5: List files matching a predicate (files larger than 10KB)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            tempFile.delete();\r\n            System.out.println(\"  Test file deleted\");\r\n        }",
          "comments": [
            "Test 8: Create and write to a test file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "file",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            tempFile.delete();\r\n            System.out.println(\"  Test file deleted\");\r\n        }",
          "comments": [
            "Clean up test file"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "testJsonUtils",
          "parameters": [],
          "body": "{\r\n        System.out.println(\"Test 1: Converting object to JSON\");\r\n        \r\n        // Create a sample object\r\n        Map\u003cString, Object\u003e sampleObj \u003d new HashMap\u003c\u003e();\r\n        sampleObj.put(\"name\", \"Test Object\");\r\n        sampleObj.put(\"value\", 42);\r\n        sampleObj.put(\"active\", true);\r\n        \r\n        // Convert to JSON\r\n        String json \u003d JsonUtils.toJson(sampleObj);\r\n        System.out.println(\"JSON output:\");\r\n        System.out.println(json);\r\n        \r\n        // Test 2: Converting a more complex object\r\n        System.out.println(\"\\nTest 2: Converting complex object to JSON\");\r\n        ClassStructure classStructure \u003d createSampleClassStructure();\r\n        String classJson \u003d JsonUtils.toJson(classStructure);\r\n        System.out.println(\"Class structure JSON (preview):\");\r\n        System.out.println(classJson.substring(0, Math.min(300, classJson.length())) + \"...\");\r\n        \r\n        // Test 3: Converting to Map\r\n        System.out.println(\"\\nTest 3: Converting object to Map\");\r\n        Map\u003cString, Object\u003e jsonMap \u003d JsonUtils.toJsonMap(classStructure);\r\n        System.out.println(\"Map contains \" + jsonMap.size() + \" top-level keys:\");\r\n        for (String key : jsonMap.keySet()) {\r\n            Object value \u003d jsonMap.get(key);\r\n            System.out.println(\"  \" + key + \": \" + (value \u003d\u003d null ? \"null\" : value.getClass().getSimpleName()));\r\n        }\r\n        \r\n        // Test 4: Pretty printing\r\n        System.out.println(\"\\nTest 4: Pretty printing JSON\");\r\n        String prettyJson \u003d JsonUtils.toPrettyJson(classStructure);\r\n        String[] lines \u003d prettyJson.split(\"\\n\");\r\n        System.out.println(\"Pretty JSON has \" + lines.length + \" lines\");\r\n        System.out.println(\"First 5 lines:\");\r\n        for (int i \u003d 0; i \u003c Math.min(5, lines.length); i++) {\r\n            System.out.println(\"  \" + lines[i]);\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test JsonUtils functionality",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "structure",
          "methodName": "JSON",
          "parameters": [],
          "body": "{\r\n            Object value \u003d jsonMap.get(key);\r\n            System.out.println(\"  \" + key + \": \" + (value \u003d\u003d null ? \"null\" : value.getClass().getSimpleName()));\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "ClassStructure",
          "methodName": "createSampleClassStructure",
          "parameters": [],
          "body": "{\r\n        // Create a simple method\r\n        MethodStructure method \u003d MethodStructure.builder()\r\n                .methodName(\"testMethod\")\r\n                .accessModifier(\"public\")\r\n                .isStatic(false)\r\n                .returnType(\"void\")\r\n                .body(\"{\\n    System.out.println(\\\"Hello, world!\\\");\\n}\")\r\n                .build();\r\n        \r\n        List\u003cMethodStructure\u003e methods \u003d new ArrayList\u003c\u003e();\r\n        methods.add(method);\r\n        \r\n        // Create a class structure\r\n        return ClassStructure.builder()\r\n                .fileName(\"TestClass.java\")\r\n                .packageName(\"io.joshuasalcedo.test\")\r\n                .className(\"TestClass\")\r\n                .classType(\"class\")\r\n                .methods(methods)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Create a sample ClassStructure for testing",
            "tags": []
          },
          "comments": [
            "Create a simple method"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "printFileSample",
          "parameters": [
            {
              "type": "List\u003cFile\u003e",
              "name": "files"
            },
            {
              "type": "int",
              "name": "maxFiles"
            }
          ],
          "body": "{\r\n        System.out.println(\"Sample files:\");\r\n        int count \u003d 0;\r\n        for (File file : files) {\r\n            if (count++ \u003e\u003d maxFiles) {\r\n                System.out.println(\"  ... and \" + (files.size() - maxFiles) + \" more\");\r\n                break;\r\n            }\r\n            System.out.println(\"  \" + file.getName() + \" (\" + FileUtils.getHumanReadableSize(file) + \")\");\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to print a sample of files for the tests",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.utility"
    },
    "src/main/java/io/joshuasalcedo/model/git/ContributorInfo.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/git/ContributorInfo.java",
      "methods": [],
      "className": "ContributorInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    "src/main/java/io/joshuasalcedo/model/markdown/MarkdownCodeBlock.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/markdown/MarkdownCodeBlock.java",
      "methods": [],
      "className": "MarkdownCodeBlock",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    "src/main/java/io/joshuasalcedo/model/git/TagInfo.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/git/TagInfo.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "tag",
          "parameters": [
            {
              "type": "for",
              "name": "annotated"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Whether this is an annotated tag.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "tagger",
          "parameters": [
            {
              "type": "for",
              "name": "annotated"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The message of the tag (for annotated tags).",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "tagger",
          "parameters": [
            {
              "type": "for",
              "name": "annotated"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The name of the tagger (for annotated tags).",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "was",
          "methodName": "created",
          "parameters": [
            {
              "type": "for",
              "name": "annotated"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The email of the tagger (for annotated tags).",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "TagInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    "src/main/java/io/joshuasalcedo/parsers/GitParser.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/parsers/GitParser.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "GitParser",
          "parameters": [],
          "body": "{\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Git repositories using JGit.\r\nThis class provides static methods to analyze Git repositories and extract structural information.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AssertionError",
          "parameters": [
            {
              "type": "\"Utility",
              "name": "class"
            }
          ],
          "body": "{\r\n        File gitDir \u003d new File(repoPath);\r\n        try (Git git \u003d Git.open(gitDir)) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Git repositories using JGit.\r\nThis class provides static methods to analyze Git repositories and extract structural information.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "GitRepositoryInfo",
          "methodName": "parseRepository",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            }
          ],
          "body": "{\r\n        File gitDir \u003d new File(repoPath);\r\n        try (Git git \u003d Git.open(gitDir)) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Parse a Git repository and extract comprehensive information.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "GitRepositoryInfo object containing repository information"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Parse a Git repository and extract comprehensive information.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "GitRepositoryInfo object containing repository information"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "RevCommit",
          "methodName": "getLatestCommit",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Iterable\u003cRevCommit\u003e commits \u003d git.log().setMaxCount(1).call();\r\n        return commits.iterator().hasNext() ? commits.iterator().next() : null;\r\n    }",
          "javadoc": {
            "description": "Get the latest commit in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "The latest RevCommit or null if the repository is empty"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "CommitInfo",
          "methodName": "convertToCommitInfo",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            },
            {
              "type": "Repository",
              "name": "repository"
            }
          ],
          "body": "{\r\n        PersonIdent authorIdent \u003d commit.getAuthorIdent();\r\n        PersonIdent committerIdent \u003d commit.getCommitterIdent();\r\n\r\n        // Get parent commits\r\n        List\u003cString\u003e parentIds \u003d new ArrayList\u003c\u003e();\r\n        for (RevCommit parent : commit.getParents()) {\r\n            parentIds.add(parent.getName());\r\n        }\r\n\r\n        // Get file changes\r\n        List\u003cFileChange\u003e fileChanges \u003d getFileChanges(commit, repository);\r\n\r\n        return CommitInfo.builder()\r\n                .id(commit.getName())\r\n                .shortId(commit.getName().substring(0, 7))\r\n                .message(commit.getFullMessage())\r\n                .authorName(authorIdent.getName())\r\n                .authorEmail(authorIdent.getEmailAddress())\r\n                .authorDate(authorIdent.getWhen())\r\n                .committerName(committerIdent.getName())\r\n                .committerEmail(committerIdent.getEmailAddress())\r\n                .commitDate(committerIdent.getWhen())\r\n                .parentIds(parentIds)\r\n                .changedFiles(fileChanges)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Convert a RevCommit to a CommitInfo object.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "commit     The RevCommit to convert"
              },
              {
                "name": "param",
                "value": "repository The repository containing the commit"
              },
              {
                "name": "return",
                "value": "A CommitInfo object"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cFileChange\u003e",
          "methodName": "getFileChanges",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            },
            {
              "type": "Repository",
              "name": "repository"
            }
          ],
          "body": "{\r\n        List\u003cFileChange\u003e changes \u003d new ArrayList\u003c\u003e();\r\n\r\n        // If this is the first commit, there\u0027s nothing to compare with\r\n        if (commit.getParentCount() \u003d\u003d 0) {\r\n            return changes;\r\n        }\r\n\r\n        RevCommit parent \u003d commit.getParent(0);\r\n\r\n        try (ObjectReader reader \u003d repository.newObjectReader();\r\n             DiffFormatter formatter \u003d new DiffFormatter(DisabledOutputStream.INSTANCE)) {\r\n\r\n            formatter.setRepository(repository);\r\n            formatter.setDiffComparator(RawTextComparator.DEFAULT);\r\n\r\n            CanonicalTreeParser oldTreeParser \u003d new CanonicalTreeParser();\r\n            oldTreeParser.reset(reader, parent.getTree());\r\n\r\n            CanonicalTreeParser newTreeParser \u003d new CanonicalTreeParser();\r\n            newTreeParser.reset(reader, commit.getTree());\r\n\r\n            List\u003cDiffEntry\u003e diffs \u003d formatter.scan(oldTreeParser, newTreeParser);\r\n\r\n            for (DiffEntry diff : diffs) {\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }\r\n        }\r\n\r\n        return changes;\r\n    }",
          "javadoc": {
            "description": "Get file changes for a commit.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "commit     The commit to analyze"
              },
              {
                "name": "param",
                "value": "repository The repository containing the commit"
              },
              {
                "name": "return",
                "value": "List of FileChange objects"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "with",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            return changes;\r\n        }",
          "comments": [
            "If this is the first commit, there\u0027s nothing to compare with"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "DiffFormatter",
          "parameters": [],
          "body": "{\r\n\r\n            formatter.setRepository(repository);\r\n            formatter.setDiffComparator(RawTextComparator.DEFAULT);\r\n\r\n            CanonicalTreeParser oldTreeParser \u003d new CanonicalTreeParser();\r\n            oldTreeParser.reset(reader, parent.getTree());\r\n\r\n            CanonicalTreeParser newTreeParser \u003d new CanonicalTreeParser();\r\n            newTreeParser.reset(reader, commit.getTree());\r\n\r\n            List\u003cDiffEntry\u003e diffs \u003d formatter.scan(oldTreeParser, newTreeParser);\r\n\r\n            for (DiffEntry diff : diffs) {\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "CanonicalTreeParser",
          "parameters": [],
          "body": "{\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "CanonicalTreeParser",
          "parameters": [],
          "body": "{\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "ChangeType",
          "methodName": "convertChangeType",
          "parameters": [
            {
              "type": "DiffEntry.ChangeType",
              "name": "jgitChangeType"
            }
          ],
          "body": "{\r\n        switch (jgitChangeType) {\r\n            case ADD:\r\n                return FileChange.ChangeType.ADD;\r\n            case MODIFY:\r\n                return FileChange.ChangeType.MODIFY;\r\n            case DELETE:\r\n                return FileChange.ChangeType.DELETE;\r\n            case RENAME:\r\n                return FileChange.ChangeType.RENAME;\r\n            case COPY:\r\n                return FileChange.ChangeType.COPY;\r\n            default:\r\n                return FileChange.ChangeType.MODIFY;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Convert JGit change type to our own ChangeType enum.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "jgitChangeType The JGit DiffEntry.ChangeType"
              },
              {
                "name": "return",
                "value": "Our FileChange.ChangeType"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cBranchInfo\u003e",
          "methodName": "getAllBranches",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        List\u003cBranchInfo\u003e branches \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Get current branch name\r\n        String currentBranch \u003d git.getRepository().getBranch();\r\n\r\n        // Get local branches\r\n        List\u003cRef\u003e localBranches \u003d git.branchList().call();\r\n        for (Ref branch : localBranches) {\r\n            String branchName \u003d branch.getName().substring(branch.getName().lastIndexOf(\"/\") + 1);\r\n\r\n            // Check if branch is merged\r\n            boolean merged \u003d false;\r\n            try {\r\n                List\u003cRef\u003e mergedBranches \u003d git.branchList().setContains(currentBranch).call();\r\n                for (Ref mergedBranch : mergedBranches) {\r\n                    if (mergedBranch.getName().equals(branch.getName())) {\r\n                        merged \u003d true;\r\n                        break;\r\n                    }\r\n                }\r\n            } catch (Exception e) {\r\n                // Ignore errors checking merged status\r\n            }\r\n\r\n            // Get tracking branch\r\n            String trackingBranch \u003d null;\r\n            try {\r\n                trackingBranch \u003d git.getRepository().getConfig().getString(\"branch\", branchName, \"merge\");\r\n                if (trackingBranch !\u003d null \u0026\u0026 trackingBranch.startsWith(\"refs/heads/\")) {\r\n                    trackingBranch \u003d trackingBranch.substring(\"refs/heads/\".length());\r\n                }\r\n            } catch (Exception e) {\r\n                // Ignore errors getting tracking branch\r\n            }\r\n\r\n            branches.add(BranchInfo.builder()\r\n                    .name(branchName)\r\n                    .current(branchName.equals(currentBranch))\r\n                    .remote(false)\r\n                    .commitId(branch.getObjectId().getName())\r\n                    .merged(merged)\r\n                    .trackingBranch(trackingBranch)\r\n                    .build());\r\n        }\r\n\r\n        // Get remote branches\r\n        List\u003cRef\u003e remoteBranches \u003d git.branchList().setListMode(ListBranchCommand.ListMode.REMOTE).call();\r\n        for (Ref branch : remoteBranches) {\r\n            String fullName \u003d branch.getName();\r\n            String remoteName \u003d fullName.substring(fullName.indexOf(\"/\") + 1, fullName.lastIndexOf(\"/\"));\r\n            String branchName \u003d fullName.substring(fullName.lastIndexOf(\"/\") + 1);\r\n            branches.add(BranchInfo.builder()\r\n                    .name(branchName)\r\n                    .current(false)\r\n                    .remote(true)\r\n                    .remoteName(remoteName)\r\n                    .commitId(branch.getObjectId().getName())\r\n                    .build());\r\n        }\r\n\r\n        return branches;\r\n    }",
          "javadoc": {
            "description": "Get all branches in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "List of BranchInfo objects"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cTagInfo\u003e",
          "methodName": "getAllTags",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        List\u003cTagInfo\u003e tags \u003d new ArrayList\u003c\u003e();\r\n        List\u003cRef\u003e tagRefs \u003d git.tagList().call();\r\n\r\n        try (RevWalk revWalk \u003d new RevWalk(git.getRepository())) {\r\n            for (Ref tagRef : tagRefs) {\r\n                String tagName \u003d tagRef.getName().substring(tagRef.getName().lastIndexOf(\"/\") + 1);\r\n                ObjectId objectId \u003d tagRef.getObjectId();\r\n\r\n                boolean isAnnotated \u003d false;\r\n                RevTag revTag \u003d null;\r\n                RevCommit commit \u003d null;\r\n\r\n                try {\r\n                    revTag \u003d revWalk.parseTag(objectId);\r\n                    isAnnotated \u003d true;\r\n                    commit \u003d revWalk.parseCommit(revTag.getObject());\r\n                } catch (IOException e) {\r\n                    // Not an annotated tag\r\n                    commit \u003d revWalk.parseCommit(objectId);\r\n                }\r\n\r\n                TagInfo.TagInfoBuilder builder \u003d TagInfo.builder()\r\n                        .name(tagName)\r\n                        .commitId(commit.getName())\r\n                        .annotated(isAnnotated);\r\n\r\n                if (isAnnotated \u0026\u0026 revTag !\u003d null) {\r\n                    PersonIdent taggerIdent \u003d revTag.getTaggerIdent();\r\n                    builder.message(revTag.getFullMessage())\r\n                            .taggerName(taggerIdent.getName())\r\n                            .taggerEmail(taggerIdent.getEmailAddress())\r\n                            .taggerDate(taggerIdent.getWhen());\r\n                }\r\n\r\n                tags.add(builder.build());\r\n            }\r\n        }\r\n\r\n        return tags;\r\n    }",
          "javadoc": {
            "description": "Get all tags in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "List of TagInfo objects"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "RevWalk",
          "parameters": [],
          "body": "{\r\n            for (Ref tagRef : tagRefs) {\r\n                String tagName \u003d tagRef.getName().substring(tagRef.getName().lastIndexOf(\"/\") + 1);\r\n                ObjectId objectId \u003d tagRef.getObjectId();\r\n\r\n                boolean isAnnotated \u003d false;\r\n                RevTag revTag \u003d null;\r\n                RevCommit commit \u003d null;\r\n\r\n                try {\r\n                    revTag \u003d revWalk.parseTag(objectId);\r\n                    isAnnotated \u003d true;\r\n                    commit \u003d revWalk.parseCommit(revTag.getObject());\r\n                } catch (IOException e) {\r\n                    // Not an annotated tag\r\n                    commit \u003d revWalk.parseCommit(objectId);\r\n                }\r\n\r\n                TagInfo.TagInfoBuilder builder \u003d TagInfo.builder()\r\n                        .name(tagName)\r\n                        .commitId(commit.getName())\r\n                        .annotated(isAnnotated);\r\n\r\n                if (isAnnotated \u0026\u0026 revTag !\u003d null) {\r\n                    PersonIdent taggerIdent \u003d revTag.getTaggerIdent();\r\n                    builder.message(revTag.getFullMessage())\r\n                            .taggerName(taggerIdent.getName())\r\n                            .taggerEmail(taggerIdent.getEmailAddress())\r\n                            .taggerDate(taggerIdent.getWhen());\r\n                }\r\n\r\n                tags.add(builder.build());\r\n            }\r\n        }",
          "javadoc": {
            "description": "Get all tags in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "List of TagInfo objects"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "hasUncommittedChanges",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Status status \u003d git.status().call();\r\n        return !status.isClean();\r\n    }",
          "javadoc": {
            "description": "Check if the repository has uncommitted changes.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "true if there are uncommitted changes, false otherwise"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "int",
          "methodName": "countCommits",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        LogCommand logCommand \u003d git.log();\r\n        Iterable\u003cRevCommit\u003e commits \u003d logCommand.call();\r\n        return (int) StreamSupport.stream(commits.spliterator(), false).count();\r\n    }",
          "javadoc": {
            "description": "Count the number of commits in the current branch.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "The number of commits"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cContributorInfo\u003e",
          "methodName": "getTopContributors",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            },
            {
              "type": "int",
              "name": "maxCount"
            }
          ],
          "body": "{\r\n        // Maps to track contributor statistics\r\n        Map\u003cString, ContributorInfo.ContributorInfoBuilder\u003e contributors \u003d new HashMap\u003c\u003e();\r\n        Map\u003cString, Date\u003e firstCommitDates \u003d new HashMap\u003c\u003e();\r\n        Map\u003cString, Date\u003e lastCommitDates \u003d new HashMap\u003c\u003e();\r\n\r\n        // Get all commits\r\n        Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n        for (RevCommit commit : commits) {\r\n            PersonIdent author \u003d commit.getAuthorIdent();\r\n            String authorEmail \u003d author.getEmailAddress();\r\n\r\n            // Initialize contributor if not exists\r\n            if (!contributors.containsKey(authorEmail)) {\r\n                contributors.put(authorEmail, ContributorInfo.builder()\r\n                        .name(author.getName())\r\n                        .email(authorEmail)\r\n                        .commitCount(0)\r\n                        .linesAdded(0)\r\n                        .linesDeleted(0));\r\n\r\n                firstCommitDates.put(authorEmail, author.getWhen());\r\n                lastCommitDates.put(authorEmail, author.getWhen());\r\n            }\r\n\r\n            // Update commit count\r\n            ContributorInfo.ContributorInfoBuilder contributor \u003d contributors.get(authorEmail);\r\n            contributor.commitCount(contributor.build().getCommitCount() + 1);\r\n\r\n            // Update dates\r\n            Date commitDate \u003d author.getWhen();\r\n            if (commitDate.before(firstCommitDates.get(authorEmail))) {\r\n                firstCommitDates.put(authorEmail, commitDate);\r\n            }\r\n            if (commitDate.after(lastCommitDates.get(authorEmail))) {\r\n                lastCommitDates.put(authorEmail, commitDate);\r\n            }\r\n\r\n            // Update line changes\r\n            if (commit.getParentCount() \u003e 0) {\r\n                List\u003cFileChange\u003e changes \u003d getFileChanges(commit, git.getRepository());\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                for (FileChange change : changes) {\r\n                    linesAdded +\u003d change.getLinesAdded();\r\n                    linesDeleted +\u003d change.getLinesDeleted();\r\n                }\r\n\r\n                contributor.linesAdded(contributor.build().getLinesAdded() + linesAdded);\r\n                contributor.linesDeleted(contributor.build().getLinesDeleted() + linesDeleted);\r\n            }\r\n        }\r\n\r\n        // Build final contributor list\r\n        List\u003cContributorInfo\u003e result \u003d new ArrayList\u003c\u003e();\r\n        for (String email : contributors.keySet()) {\r\n            ContributorInfo.ContributorInfoBuilder builder \u003d contributors.get(email);\r\n            builder.firstCommitDate(firstCommitDates.get(email));\r\n            builder.lastCommitDate(lastCommitDates.get(email));\r\n            result.add(builder.build());\r\n        }\r\n\r\n        // Sort by commit count and limit to maxCount\r\n        result.sort((c1, c2) -\u003e Integer.compare(c2.getCommitCount(), c1.getCommitCount()));\r\n        return result.stream().limit(maxCount).collect(Collectors.toList());\r\n    }",
          "javadoc": {
            "description": "Get the top contributors to the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git      The Git instance"
              },
              {
                "name": "param",
                "value": "maxCount Maximum number of contributors to return"
              },
              {
                "name": "return",
                "value": "List of ContributorInfo objects"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "exists",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                contributors.put(authorEmail, ContributorInfo.builder()\r\n                        .name(author.getName())\r\n                        .email(authorEmail)\r\n                        .commitCount(0)\r\n                        .linesAdded(0)\r\n                        .linesDeleted(0));\r\n\r\n                firstCommitDates.put(authorEmail, author.getWhen());\r\n                lastCommitDates.put(authorEmail, author.getWhen());\r\n            }",
          "comments": [
            "Initialize contributor if not exists"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "changes",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                List\u003cFileChange\u003e changes \u003d getFileChanges(commit, git.getRepository());\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                for (FileChange change : changes) {\r\n                    linesAdded +\u003d change.getLinesAdded();\r\n                    linesDeleted +\u003d change.getLinesDeleted();\r\n                }\r\n\r\n                contributor.linesAdded(contributor.build().getLinesAdded() + linesAdded);\r\n                contributor.linesDeleted(contributor.build().getLinesDeleted() + linesDeleted);\r\n            }",
          "comments": [
            "Update line changes"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "getRepositoryStatistics",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e statistics \u003d new HashMap\u003c\u003e();\r\n\r\n        // Get all commits\r\n        Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n        List\u003cRevCommit\u003e commitList \u003d StreamSupport.stream(commits.spliterator(), false)\r\n                .collect(Collectors.toList());\r\n\r\n        // Calculate commits per day of week\r\n        Map\u003cString, Integer\u003e commitsPerDayOfWeek \u003d new HashMap\u003c\u003e();\r\n        String[] daysOfWeek \u003d {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\r\n        for (String day : daysOfWeek) {\r\n            commitsPerDayOfWeek.put(day, 0);\r\n        }\r\n\r\n        SimpleDateFormat dayFormat \u003d new SimpleDateFormat(\"EEEE\");\r\n        for (RevCommit commit : commitList) {\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String dayOfWeek \u003d dayFormat.format(commitDate);\r\n            commitsPerDayOfWeek.put(dayOfWeek, commitsPerDayOfWeek.get(dayOfWeek) + 1);\r\n        }\r\n\r\n        // Calculate commits per hour\r\n        Map\u003cInteger, Integer\u003e commitsPerHour \u003d new HashMap\u003c\u003e();\r\n        for (int i \u003d 0; i \u003c 24; i++) {\r\n            commitsPerHour.put(i, 0);\r\n        }\r\n\r\n        Calendar calendar \u003d Calendar.getInstance();\r\n        for (RevCommit commit : commitList) {\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            calendar.setTime(commitDate);\r\n            int hour \u003d calendar.get(Calendar.HOUR_OF_DAY);\r\n            commitsPerHour.put(hour, commitsPerHour.get(hour) + 1);\r\n        }\r\n\r\n        // Calculate commits per month\r\n        Map\u003cString, Integer\u003e commitsPerMonth \u003d new HashMap\u003c\u003e();\r\n        String[] months \u003d {\"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\r\n                \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\r\n        for (String month : months) {\r\n            commitsPerMonth.put(month, 0);\r\n        }\r\n\r\n        SimpleDateFormat monthFormat \u003d new SimpleDateFormat(\"MMMM\");\r\n        for (RevCommit commit : commitList) {\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String month \u003d monthFormat.format(commitDate);\r\n            commitsPerMonth.put(month, commitsPerMonth.get(month) + 1);\r\n        }\r\n\r\n        // Calculate average commit size (in changed files)\r\n        int totalChangedFiles \u003d 0;\r\n        for (RevCommit commit : commitList) {\r\n            if (commit.getParentCount() \u003e 0) {\r\n                List\u003cFileChange\u003e changes \u003d getFileChanges(commit, git.getRepository());\r\n                totalChangedFiles +\u003d changes.size();\r\n            }\r\n        }\r\n\r\n        double avgChangedFiles \u003d commitList.isEmpty() ? 0 : (double) totalChangedFiles / commitList.size();\r\n\r\n        // Add statistics to the map\r\n        statistics.put(\"totalCommits\", commitList.size());\r\n        statistics.put(\"commitsPerDayOfWeek\", commitsPerDayOfWeek);\r\n        statistics.put(\"commitsPerHour\", commitsPerHour);\r\n        statistics.put(\"commitsPerMonth\", commitsPerMonth);\r\n        statistics.put(\"averageChangedFilesPerCommit\", avgChangedFiles);\r\n\r\n        return statistics;\r\n    }",
          "javadoc": {
            "description": "Get various statistics about the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "Map of statistics"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String dayOfWeek \u003d dayFormat.format(commitDate);\r\n            commitsPerDayOfWeek.put(dayOfWeek, commitsPerDayOfWeek.get(dayOfWeek) + 1);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String month \u003d monthFormat.format(commitDate);\r\n            commitsPerMonth.put(month, commitsPerMonth.get(month) + 1);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "commit",
          "methodName": "size",
          "parameters": [
            {
              "type": "in",
              "name": "changed"
            }
          ],
          "body": "{\r\n            if (commit.getParentCount() \u003e 0) {\r\n                List\u003cFileChange\u003e changes \u003d getFileChanges(commit, git.getRepository());\r\n                totalChangedFiles +\u003d changes.size();\r\n            }\r\n        }",
          "comments": [
            "Calculate average commit size (in changed files)"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Integer\u003e",
          "methodName": "getFileExtensionCounts",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Map\u003cString, Integer\u003e extensionCounts \u003d new HashMap\u003c\u003e();\r\n\r\n        RevCommit headCommit \u003d getLatestCommit(git);\r\n        if (headCommit \u003d\u003d null) {\r\n            return extensionCounts;\r\n        }\r\n\r\n        Repository repository \u003d git.getRepository();\r\n        try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\r\n            treeWalk.addTree(headCommit.getTree());\r\n            treeWalk.setRecursive(true);\r\n\r\n            while (treeWalk.next()) {\r\n                String path \u003d treeWalk.getPathString();\r\n                int dotIndex \u003d path.lastIndexOf(\u0027.\u0027);\r\n                if (dotIndex \u003e 0) {\r\n                    String extension \u003d path.substring(dotIndex + 1).toLowerCase();\r\n                    extensionCounts.put(extension, extensionCounts.getOrDefault(extension, 0) + 1);\r\n                } else {\r\n                    extensionCounts.put(\"(no extension)\", extensionCounts.getOrDefault(\"(no extension)\", 0) + 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        return extensionCounts;\r\n    }",
          "javadoc": {
            "description": "Get counts of files by extension in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "Map of file extensions to counts"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "TreeWalk",
          "parameters": [],
          "body": "{\r\n            treeWalk.addTree(headCommit.getTree());\r\n            treeWalk.setRecursive(true);\r\n\r\n            while (treeWalk.next()) {\r\n                String path \u003d treeWalk.getPathString();\r\n                int dotIndex \u003d path.lastIndexOf(\u0027.\u0027);\r\n                if (dotIndex \u003e 0) {\r\n                    String extension \u003d path.substring(dotIndex + 1).toLowerCase();\r\n                    extensionCounts.put(extension, extensionCounts.getOrDefault(extension, 0) + 1);\r\n                } else {\r\n                    extensionCounts.put(\"(no extension)\", extensionCounts.getOrDefault(\"(no extension)\", 0) + 1);\r\n                }\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "repository",
          "parameters": [
            {
              "type": "date",
              "name": "of"
            }
          ],
          "body": "{\r\n        Repository repository \u003d git.getRepository();\r\n\r\n        try (RevWalk revWalk \u003d new RevWalk(repository)) {\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Date",
          "methodName": "getRepositoryCreationDate",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Repository repository \u003d git.getRepository();\r\n\r\n        try (RevWalk revWalk \u003d new RevWalk(repository)) {\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }",
          "javadoc": {
            "description": "Get the creation date of the repository (date of the first commit).\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "The creation date or null if no commits exist"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "RevWalk",
          "parameters": [],
          "body": "{\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }",
          "javadoc": {
            "description": "Get the creation date of the repository (date of the first commit).\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "The creation date or null if no commits exist"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "findGitRepositories",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            }
          ],
          "body": "{\r\n        List\u003cFile\u003e repositories \u003d new ArrayList\u003c\u003e();\r\n        findGitRepositoriesRecursive(directory, repositories);\r\n        return repositories;\r\n    }",
          "javadoc": {
            "description": "Find all Git repositories in a directory and its subdirectories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "return",
                "value": "List of Git repository directories"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "findGitRepositoriesRecursive",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "List\u003cFile\u003e",
              "name": "repositories"
            }
          ],
          "body": "{\r\n        File[] files \u003d directory.listFiles();\r\n        if (files !\u003d null) {\r\n            for (File file : files) {\r\n                if (file.isDirectory()) {\r\n                    if (file.getName().equals(\".git\")) {\r\n                        repositories.add(directory);\r\n                    } else if (!file.getName().equals(\".git\")) {\r\n                        findGitRepositoriesRecursive(file, repositories);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Recursive helper method to find all Git repositories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory    The directory to search"
              },
              {
                "name": "param",
                "value": "repositories List to collect Git repository directories"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                        findGitRepositoriesRecursive(file, repositories);\r\n                    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "CommitInfo",
          "methodName": "getCommitInfo",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "commitId"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            try (RevWalk revWalk \u003d new RevWalk(repository)) {\r\n                ObjectId objectId \u003d repository.resolve(commitId);\r\n                if (objectId \u003d\u003d null) {\r\n                    return null;\r\n                }\r\n\r\n                RevCommit commit \u003d revWalk.parseCommit(objectId);\r\n                return convertToCommitInfo(commit, repository);\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get specific information about a commit.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "commitId The commit ID"
              },
              {
                "name": "return",
                "value": "CommitInfo object containing commit information"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get specific information about a commit.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "commitId The commit ID"
              },
              {
                "name": "return",
                "value": "CommitInfo object containing commit information"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "RevWalk",
          "parameters": [],
          "body": "{\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "convertToCommitInfo",
          "parameters": [],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().setMaxCount(maxCount).call();\r\n            List\u003cCommitInfo\u003e commitInfos \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                commitInfos.add(convertToCommitInfo(commit, repository));\r\n            }\r\n\r\n            return commitInfos;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getRecentCommits",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "int",
              "name": "maxCount"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().setMaxCount(maxCount).call();\r\n            List\u003cCommitInfo\u003e commitInfos \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                commitInfos.add(convertToCommitInfo(commit, repository));\r\n            }\r\n\r\n            return commitInfos;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get a list of recent commits.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "maxCount The maximum number of commits to retrieve"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get a list of recent commits.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "maxCount The maximum number of commits to retrieve"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getAllCommits",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e commitInfos \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                commitInfos.add(convertToCommitInfo(commit, repository));\r\n            }\r\n\r\n            return commitInfos;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get a list of all commits in a repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for all commits"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get a list of all commits in a repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for all commits"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getCommitsByAuthor",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "authorName"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e authorCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n                if (author.getName().contains(authorName) || author.getEmailAddress().contains(authorName)) {\r\n                    authorCommits.add(convertToCommitInfo(commit, repository));\r\n                }\r\n            }\r\n\r\n            return authorCommits;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get commits by a specific author.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "authorName The name or email of the author"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for commits by the author"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Start",
          "methodName": "date",
          "parameters": [],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e dateRangeCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.equals(since) || commitDate.after(since)) \u0026\u0026\r\n                        (commitDate.equals(until) || commitDate.before(until))) {\r\n                    dateRangeCommits.add(convertToCommitInfo(commit, repository));\r\n                }\r\n            }\r\n\r\n            return dateRangeCommits;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "End",
          "methodName": "date",
          "parameters": [],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e dateRangeCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.equals(since) || commitDate.after(since)) \u0026\u0026\r\n                        (commitDate.equals(until) || commitDate.before(until))) {\r\n                    dateRangeCommits.add(convertToCommitInfo(commit, repository));\r\n                }\r\n            }\r\n\r\n            return dateRangeCommits;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getCommitsByDateRange",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "Date",
              "name": "since"
            },
            {
              "type": "Date",
              "name": "until"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e dateRangeCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.equals(since) || commitDate.after(since)) \u0026\u0026\r\n                        (commitDate.equals(until) || commitDate.before(until))) {\r\n                    dateRangeCommits.add(convertToCommitInfo(commit, repository));\r\n                }\r\n            }\r\n\r\n            return dateRangeCommits;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get commits within a date range.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "since Start date (inclusive)"
              },
              {
                "name": "param",
                "value": "until End date (inclusive)"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for commits within the date range"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getFileHistory",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "filePath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().addPath(filePath).call();\r\n            List\u003cCommitInfo\u003e fileCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                fileCommits.add(convertToCommitInfo(commit, repository));\r\n            }\r\n\r\n            return fileCommits;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get the history of a specific file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "filePath The path to the file within the repository"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for commits that changed the file"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getFileBlame",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "filePath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            BlameResult blameResult \u003d git.blame()\r\n                    .setFilePath(filePath)\r\n                    .call();\r\n\r\n            List\u003cMap\u003cString, Object\u003e\u003e blameLines \u003d new ArrayList\u003c\u003e();\r\n            SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd\");\r\n\r\n            int lineCount \u003d blameResult.getResultContents().size();\r\n            for (int i \u003d 0; i \u003c lineCount; i++) {\r\n                RevCommit commit \u003d blameResult.getSourceCommit(i);\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n                String shortCommitId \u003d commit.getName().substring(0, 7);\r\n                String line \u003d blameResult.getResultContents().getString(i);\r\n\r\n                Map\u003cString, Object\u003e blameLine \u003d new HashMap\u003c\u003e();\r\n                blameLine.put(\"lineNumber\", i + 1);\r\n                blameLine.put(\"commitId\", shortCommitId);\r\n                blameLine.put(\"fullCommitId\", commit.getName());\r\n                blameLine.put(\"author\", author.getName());\r\n                blameLine.put(\"email\", author.getEmailAddress());\r\n                blameLine.put(\"date\", dateFormat.format(author.getWhen()));\r\n                blameLine.put(\"content\", line);\r\n\r\n                blameLines.add(blameLine);\r\n            }\r\n\r\n            // Use JsonUtils to convert to pretty JSON\r\n            return io.joshuasalcedo.utility.JsonUtils.toPrettyJson(blameLines);\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get blame information for a specific file, showing who last modified each line.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "filePath The path to the file within the repository"
              },
              {
                "name": "return",
                "value": "String representing blame information in JSON format"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n                RevCommit commit \u003d blameResult.getSourceCommit(i);\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n                String shortCommitId \u003d commit.getName().substring(0, 7);\r\n                String line \u003d blameResult.getResultContents().getString(i);\r\n\r\n                Map\u003cString, Object\u003e blameLine \u003d new HashMap\u003c\u003e();\r\n                blameLine.put(\"lineNumber\", i + 1);\r\n                blameLine.put(\"commitId\", shortCommitId);\r\n                blameLine.put(\"fullCommitId\", commit.getName());\r\n                blameLine.put(\"author\", author.getName());\r\n                blameLine.put(\"email\", author.getEmailAddress());\r\n                blameLine.put(\"date\", dateFormat.format(author.getWhen()));\r\n                blameLine.put(\"content\", line);\r\n\r\n                blameLines.add(blameLine);\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getDiffBetweenCommits",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "oldCommitId"
            },
            {
              "type": "String",
              "name": "newCommitId"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            ObjectId oldId \u003d repository.resolve(oldCommitId);\r\n            ObjectId newId \u003d repository.resolve(newCommitId);\r\n\r\n            if (oldId \u003d\u003d null || newId \u003d\u003d null) {\r\n                return \"Invalid commit IDs\";\r\n            }\r\n\r\n            ByteArrayOutputStream outputStream \u003d new ByteArrayOutputStream();\r\n            try (DiffFormatter formatter \u003d new DiffFormatter(outputStream)) {\r\n                formatter.setRepository(repository);\r\n\r\n                RevCommit oldCommit \u003d repository.parseCommit(oldId);\r\n                RevCommit newCommit \u003d repository.parseCommit(newId);\r\n\r\n                AbstractTreeIterator oldTreeIterator \u003d getCanonicalTreeParser(repository, oldCommit);\r\n                AbstractTreeIterator newTreeIterator \u003d getCanonicalTreeParser(repository, newCommit);\r\n\r\n                List\u003cDiffEntry\u003e diffs \u003d git.diff()\r\n                        .setOldTree(oldTreeIterator)\r\n                        .setNewTree(newTreeIterator)\r\n                        .call();\r\n\r\n                for (DiffEntry diff : diffs) {\r\n                    formatter.format(diff);\r\n                    formatter.flush();\r\n                }\r\n\r\n                return new String(outputStream.toByteArray(), StandardCharsets.UTF_8);\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get diff between two commits.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "oldCommitId The ID of the old commit"
              },
              {
                "name": "param",
                "value": "newCommitId The ID of the new commit"
              },
              {
                "name": "return",
                "value": "String representing the diff"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ByteArrayOutputStream",
          "parameters": [],
          "body": "{\r\n                formatter.setRepository(repository);\r\n\r\n                RevCommit oldCommit \u003d repository.parseCommit(oldId);\r\n                RevCommit newCommit \u003d repository.parseCommit(newId);\r\n\r\n                AbstractTreeIterator oldTreeIterator \u003d getCanonicalTreeParser(repository, oldCommit);\r\n                AbstractTreeIterator newTreeIterator \u003d getCanonicalTreeParser(repository, newCommit);\r\n\r\n                List\u003cDiffEntry\u003e diffs \u003d git.diff()\r\n                        .setOldTree(oldTreeIterator)\r\n                        .setNewTree(newTreeIterator)\r\n                        .call();\r\n\r\n                for (DiffEntry diff : diffs) {\r\n                    formatter.format(diff);\r\n                    formatter.flush();\r\n                }\r\n\r\n                return new String(outputStream.toByteArray(), StandardCharsets.UTF_8);\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "DiffFormatter",
          "parameters": [],
          "body": "{\r\n                formatter.setRepository(repository);\r\n\r\n                RevCommit oldCommit \u003d repository.parseCommit(oldId);\r\n                RevCommit newCommit \u003d repository.parseCommit(newId);\r\n\r\n                AbstractTreeIterator oldTreeIterator \u003d getCanonicalTreeParser(repository, oldCommit);\r\n                AbstractTreeIterator newTreeIterator \u003d getCanonicalTreeParser(repository, newCommit);\r\n\r\n                List\u003cDiffEntry\u003e diffs \u003d git.diff()\r\n                        .setOldTree(oldTreeIterator)\r\n                        .setNewTree(newTreeIterator)\r\n                        .call();\r\n\r\n                for (DiffEntry diff : diffs) {\r\n                    formatter.format(diff);\r\n                    formatter.flush();\r\n                }\r\n\r\n                return new String(outputStream.toByteArray(), StandardCharsets.UTF_8);\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "String",
          "parameters": [],
          "body": "{\r\n        try (RevWalk walk \u003d new RevWalk(repository)) {\r\n            RevCommit commitTree \u003d walk.parseCommit(commit.getId());\r\n            try (ObjectReader reader \u003d repository.newObjectReader()) {\r\n                CanonicalTreeParser treeParser \u003d new CanonicalTreeParser();\r\n                treeParser.reset(reader, commitTree.getTree().getId());\r\n                return treeParser;\r\n            }\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "AbstractTreeIterator",
          "methodName": "getCanonicalTreeParser",
          "parameters": [
            {
              "type": "Repository",
              "name": "repository"
            },
            {
              "type": "RevCommit",
              "name": "commit"
            }
          ],
          "body": "{\r\n        try (RevWalk walk \u003d new RevWalk(repository)) {\r\n            RevCommit commitTree \u003d walk.parseCommit(commit.getId());\r\n            try (ObjectReader reader \u003d repository.newObjectReader()) {\r\n                CanonicalTreeParser treeParser \u003d new CanonicalTreeParser();\r\n                treeParser.reset(reader, commitTree.getTree().getId());\r\n                return treeParser;\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to get a tree parser for a commit.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "RevWalk",
          "parameters": [],
          "body": "{\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }",
          "javadoc": {
            "description": "Helper method to get a tree parser for a commit.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "CanonicalTreeParser",
          "parameters": [],
          "body": "{\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }",
          "javadoc": {
            "description": "Helper method to get a tree parser for a commit.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Integer\u003e",
          "methodName": "getContributionsByDayOfWeek",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            // Initialize days of week map\r\n            Map\u003cString, Integer\u003e daysOfWeek \u003d new LinkedHashMap\u003c\u003e();\r\n            daysOfWeek.put(\"Monday\", 0);\r\n            daysOfWeek.put(\"Tuesday\", 0);\r\n            daysOfWeek.put(\"Wednesday\", 0);\r\n            daysOfWeek.put(\"Thursday\", 0);\r\n            daysOfWeek.put(\"Friday\", 0);\r\n            daysOfWeek.put(\"Saturday\", 0);\r\n            daysOfWeek.put(\"Sunday\", 0);\r\n\r\n            // Get all commits\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            SimpleDateFormat dayFormat \u003d new SimpleDateFormat(\"EEEE\");\r\n\r\n            // Count commits by day of week\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                String dayOfWeek \u003d dayFormat.format(commitDate);\r\n                daysOfWeek.put(dayOfWeek, daysOfWeek.get(dayOfWeek) + 1);\r\n            }\r\n\r\n            return daysOfWeek;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get a summary of contributions by day of week.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "Map with days of week as keys and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get a summary of contributions by day of week.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "Map with days of week as keys and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": [
            "Initialize days of week map"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String dayOfWeek \u003d dayFormat.format(commitDate);\r\n            commitsPerDayOfWeek.put(dayOfWeek, commitsPerDayOfWeek.get(dayOfWeek) + 1);\r\n        }",
          "comments": [
            "Get all commits",
            "Count commits by day of week"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "week",
          "methodName": "for",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            }
          ],
          "body": "{\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                String dayOfWeek \u003d dayFormat.format(commitDate);\r\n                daysOfWeek.put(dayOfWeek, daysOfWeek.get(dayOfWeek) + 1);\r\n            }",
          "comments": [
            "Get all commits",
            "Count commits by day of week"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cInteger, Integer\u003e",
          "methodName": "getContributionsByHourOfDay",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            // Initialize hours map (0-23)\r\n            Map\u003cInteger, Integer\u003e hourMap \u003d new LinkedHashMap\u003c\u003e();\r\n            for (int i \u003d 0; i \u003c 24; i++) {\r\n                hourMap.put(i, 0);\r\n            }\r\n\r\n            // Get all commits\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            Calendar calendar \u003d Calendar.getInstance();\r\n\r\n            // Count commits by hour\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                calendar.setTime(commitDate);\r\n                int hour \u003d calendar.get(Calendar.HOUR_OF_DAY);\r\n                hourMap.put(hour, hourMap.get(hour) + 1);\r\n            }\r\n\r\n            return hourMap;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get a summary of contributions by hour of day.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "Map with hours as keys and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get a summary of contributions by hour of day.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "Map with hours as keys and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": [
            "Initialize hours map (0-23)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "hours",
          "methodName": "map",
          "parameters": [],
          "body": "{\r\n                hourMap.put(i, 0);\r\n            }",
          "comments": [
            "Initialize hours map (0-23)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "hour",
          "methodName": "for",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            }
          ],
          "body": "{\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                calendar.setTime(commitDate);\r\n                int hour \u003d calendar.get(Calendar.HOUR_OF_DAY);\r\n                hourMap.put(hour, hourMap.get(hour) + 1);\r\n            }",
          "comments": [
            "Get all commits",
            "Count commits by hour"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "as",
          "methodName": "keys",
          "parameters": [
            {
              "type": "format:",
              "name": "yyyy-MM-dd"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            // Create a calendar for the requested year\r\n            Calendar startCalendar \u003d Calendar.getInstance();\r\n            startCalendar.set(year, Calendar.JANUARY, 1, 0, 0, 0);\r\n            Date startDate \u003d startCalendar.getTime();\r\n\r\n            Calendar endCalendar \u003d Calendar.getInstance();\r\n            endCalendar.set(year, Calendar.DECEMBER, 31, 23, 59, 59);\r\n            Date endDate \u003d endCalendar.getTime();\r\n\r\n            // Initialize heat map\r\n            Map\u003cString, Integer\u003e heatMap \u003d new LinkedHashMap\u003c\u003e();\r\n            SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd\");\r\n\r\n            // Initialize all days of the year with zero counts\r\n            Calendar calendar \u003d Calendar.getInstance();\r\n            calendar.setTime(startDate);\r\n            while (calendar.getTime().before(endDate) || calendar.getTime().equals(endDate)) {\r\n                heatMap.put(dateFormat.format(calendar.getTime()), 0);\r\n                calendar.add(Calendar.DAY_OF_YEAR, 1);\r\n            }\r\n\r\n            // Get commits for the year\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n            // Count commits by day\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.after(startDate) || commitDate.equals(startDate)) \u0026\u0026\r\n                        (commitDate.before(endDate) || commitDate.equals(endDate))) {\r\n\r\n                    String dateStr \u003d dateFormat.format(commitDate);\r\n                    if (heatMap.containsKey(dateStr)) {\r\n                        heatMap.put(dateStr, heatMap.get(dateStr) + 1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return heatMap;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Integer\u003e",
          "methodName": "getContributionHeatMap",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "int",
              "name": "year"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            // Create a calendar for the requested year\r\n            Calendar startCalendar \u003d Calendar.getInstance();\r\n            startCalendar.set(year, Calendar.JANUARY, 1, 0, 0, 0);\r\n            Date startDate \u003d startCalendar.getTime();\r\n\r\n            Calendar endCalendar \u003d Calendar.getInstance();\r\n            endCalendar.set(year, Calendar.DECEMBER, 31, 23, 59, 59);\r\n            Date endDate \u003d endCalendar.getTime();\r\n\r\n            // Initialize heat map\r\n            Map\u003cString, Integer\u003e heatMap \u003d new LinkedHashMap\u003c\u003e();\r\n            SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd\");\r\n\r\n            // Initialize all days of the year with zero counts\r\n            Calendar calendar \u003d Calendar.getInstance();\r\n            calendar.setTime(startDate);\r\n            while (calendar.getTime().before(endDate) || calendar.getTime().equals(endDate)) {\r\n                heatMap.put(dateFormat.format(calendar.getTime()), 0);\r\n                calendar.add(Calendar.DAY_OF_YEAR, 1);\r\n            }\r\n\r\n            // Get commits for the year\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n            // Count commits by day\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.after(startDate) || commitDate.equals(startDate)) \u0026\u0026\r\n                        (commitDate.before(endDate) || commitDate.equals(endDate))) {\r\n\r\n                    String dateStr \u003d dateFormat.format(commitDate);\r\n                    if (heatMap.containsKey(dateStr)) {\r\n                        heatMap.put(dateStr, heatMap.get(dateStr) + 1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return heatMap;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Generate a monthly contribution heat map.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "year The year to analyze"
              },
              {
                "name": "return",
                "value": "Map with days as keys (format: yyyy-MM-dd) and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": [
            "Create a calendar for the requested year"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n                RevCommit commit \u003d blameResult.getSourceCommit(i);\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n                String shortCommitId \u003d commit.getName().substring(0, 7);\r\n                String line \u003d blameResult.getResultContents().getString(i);\r\n\r\n                Map\u003cString, Object\u003e blameLine \u003d new HashMap\u003c\u003e();\r\n                blameLine.put(\"lineNumber\", i + 1);\r\n                blameLine.put(\"commitId\", shortCommitId);\r\n                blameLine.put(\"fullCommitId\", commit.getName());\r\n                blameLine.put(\"author\", author.getName());\r\n                blameLine.put(\"email\", author.getEmailAddress());\r\n                blameLine.put(\"date\", dateFormat.format(author.getWhen()));\r\n                blameLine.put(\"content\", line);\r\n\r\n                blameLines.add(blameLine);\r\n            }",
          "comments": [
            "Initialize heat map",
            "Initialize all days of the year with zero cou"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "day",
          "methodName": "for",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            }
          ],
          "body": "{\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.after(startDate) || commitDate.equals(startDate)) \u0026\u0026\r\n                        (commitDate.before(endDate) || commitDate.equals(endDate))) {\r\n\r\n                    String dateStr \u003d dateFormat.format(commitDate);\r\n                    if (heatMap.containsKey(dateStr)) {\r\n                        heatMap.put(dateStr, heatMap.get(dateStr) + 1);\r\n                    }\r\n                }\r\n            }",
          "comments": [
            "Get commits for the year",
            "Count commits by day"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "repository",
          "parameters": [
            {
              "type": "most",
              "name": "frequently"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get all commits\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n            // Count changes by file path\r\n            Map\u003cString, Integer\u003e fileChangeCounts \u003d new HashMap\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                if (commit.getParentCount() \u003e 0) {\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n                    for (FileChange change : changes) {\r\n                        String path \u003d change.getPath();\r\n                        if (path !\u003d null \u0026\u0026 !path.equals(\"/dev/null\")) {\r\n                            fileChangeCounts.put(path, fileChangeCounts.getOrDefault(path, 0) + 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Sort files by change count and limit results\r\n            return fileChangeCounts.entrySet().stream()\r\n                    .sorted(Map.Entry.\u003cString, Integer\u003ecomparingByValue().reversed())\r\n                    .limit(limit)\r\n                    .collect(Collectors.toMap(\r\n                            Map.Entry::getKey,\r\n                            Map.Entry::getValue,\r\n                            (e1, e2) -\u003e e1,\r\n                            LinkedHashMap::new\r\n                    ));\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Integer\u003e",
          "methodName": "getMostActiveFiles",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "int",
              "name": "limit"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get all commits\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n            // Count changes by file path\r\n            Map\u003cString, Integer\u003e fileChangeCounts \u003d new HashMap\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                if (commit.getParentCount() \u003e 0) {\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n                    for (FileChange change : changes) {\r\n                        String path \u003d change.getPath();\r\n                        if (path !\u003d null \u0026\u0026 !path.equals(\"/dev/null\")) {\r\n                            fileChangeCounts.put(path, fileChangeCounts.getOrDefault(path, 0) + 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Sort files by change count and limit results\r\n            return fileChangeCounts.entrySet().stream()\r\n                    .sorted(Map.Entry.\u003cString, Integer\u003ecomparingByValue().reversed())\r\n                    .limit(limit)\r\n                    .collect(Collectors.toMap(\r\n                            Map.Entry::getKey,\r\n                            Map.Entry::getValue,\r\n                            (e1, e2) -\u003e e1,\r\n                            LinkedHashMap::new\r\n                    ));\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get the most active files in the repository (most frequently changed).\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "limit Maximum number of files to return"
              },
              {
                "name": "return",
                "value": "Map with file paths as keys and change counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": [
            "G"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getFormattedCommitLog",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "int",
              "name": "maxCount"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().setMaxCount(maxCount).call();\r\n            List\u003cMap\u003cString, Object\u003e\u003e commitLogs \u003d new ArrayList\u003c\u003e();\r\n            SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n            for (RevCommit commit : commits) {\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n                Map\u003cString, Object\u003e commitLog \u003d new HashMap\u003c\u003e();\r\n\r\n                commitLog.put(\"id\", commit.getName());\r\n                commitLog.put(\"author\", author.getName());\r\n                commitLog.put(\"email\", author.getEmailAddress());\r\n                commitLog.put(\"date\", dateFormat.format(author.getWhen()));\r\n                commitLog.put(\"message\", commit.getFullMessage());\r\n\r\n                // Add file changes if not the first commit\r\n                if (commit.getParentCount() \u003e 0) {\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n\r\n                    if (!changes.isEmpty()) {\r\n                        List\u003cMap\u003cString, String\u003e\u003e fileChanges \u003d new ArrayList\u003c\u003e();\r\n                        for (FileChange change : changes) {\r\n                            Map\u003cString, String\u003e fileChange \u003d new HashMap\u003c\u003e();\r\n                            fileChange.put(\"type\", change.getType().toString());\r\n                            fileChange.put(\"path\", change.getPath());\r\n                            fileChanges.add(fileChange);\r\n                        }\r\n                        commitLog.put(\"changes\", fileChanges);\r\n                    }\r\n                }\r\n\r\n                commitLogs.add(commitLog);\r\n            }\r\n\r\n            // Use JsonUtils to convert to pretty JSON with fully qualified class name\r\n            return io.joshuasalcedo.utility.JsonUtils.toPrettyJson(commitLogs);\r\n        }\r\n    }",
          "javadoc": {
            "description": "Generate a commit log in a readable format.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "maxCount Maximum number of commits to include"
              },
              {
                "name": "return",
                "value": "String representing the commit log"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [
            {
              "type": "\"yyyy-MM-dd",
              "name": "HH:mm:ss\""
            }
          ],
          "body": "{\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n                Map\u003cString, Object\u003e commitLog \u003d new HashMap\u003c\u003e();\r\n\r\n                commitLog.put(\"id\", commit.getName());\r\n                commitLog.put(\"author\", author.getName());\r\n                commitLog.put(\"email\", author.getEmailAddress());\r\n                commitLog.put(\"date\", dateFormat.format(author.getWhen()));\r\n                commitLog.put(\"message\", commit.getFullMessage());\r\n\r\n                // Add file changes if not the first commit\r\n                if (commit.getParentCount() \u003e 0) {\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n\r\n                    if (!changes.isEmpty()) {\r\n                        List\u003cMap\u003cString, String\u003e\u003e fileChanges \u003d new ArrayList\u003c\u003e();\r\n                        for (FileChange change : changes) {\r\n                            Map\u003cString, String\u003e fileChange \u003d new HashMap\u003c\u003e();\r\n                            fileChange.put(\"type\", change.getType().toString());\r\n                            fileChange.put(\"path\", change.getPath());\r\n                            fileChanges.add(fileChange);\r\n                        }\r\n                        commitLog.put(\"changes\", fileChanges);\r\n                    }\r\n                }\r\n\r\n                commitLogs.add(commitLog);\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "commit",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n\r\n                    if (!changes.isEmpty()) {\r\n                        List\u003cMap\u003cString, String\u003e\u003e fileChanges \u003d new ArrayList\u003c\u003e();\r\n                        for (FileChange change : changes) {\r\n                            Map\u003cString, String\u003e fileChange \u003d new HashMap\u003c\u003e();\r\n                            fileChange.put(\"type\", change.getType().toString());\r\n                            fileChange.put(\"path\", change.getPath());\r\n                            fileChanges.add(fileChange);\r\n                        }\r\n                        commitLog.put(\"changes\", fileChanges);\r\n                    }\r\n                }",
          "comments": [
            "Add file changes if not the first commit"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "isValidRepository",
          "parameters": [
            {
              "type": "String",
              "name": "path"
            }
          ],
          "body": "{\r\n        File gitDir \u003d new File(path);\r\n        try {\r\n            FileRepositoryBuilder builder \u003d new FileRepositoryBuilder()\r\n                    .setGitDir(new File(gitDir, \".git\"))\r\n                    .readEnvironment()\r\n                    .findGitDir();\r\n\r\n            if (builder.getGitDir() \u003d\u003d null) {\r\n                return false;\r\n            }\r\n\r\n            try (Repository repository \u003d builder.build()) {\r\n                return repository.getObjectDatabase().exists();\r\n            }\r\n        } catch (IOException e) {\r\n            return false;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Check if a path is a valid Git repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to check"
              },
              {
                "name": "return",
                "value": "true if the path is a valid Git repository, false otherwise"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            FileRepositoryBuilder builder \u003d new FileRepositoryBuilder()\r\n                    .setGitDir(new File(gitDir, \".git\"))\r\n                    .readEnvironment()\r\n                    .findGitDir();\r\n\r\n            if (builder.getGitDir() \u003d\u003d null) {\r\n                return false;\r\n            }\r\n\r\n            try (Repository repository \u003d builder.build()) {\r\n                return repository.getObjectDatabase().exists();\r\n            }\r\n        }",
          "javadoc": {
            "description": "Check if a path is a valid Git repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to check"
              },
              {
                "name": "return",
                "value": "true if the path is a valid Git repository, false otherwise"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "FileRepositoryBuilder",
          "parameters": [],
          "body": "{\r\n                return false;\r\n            }",
          "javadoc": {
            "description": "Check if a path is a valid Git repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to check"
              },
              {
                "name": "return",
                "value": "true if the path is a valid Git repository, false otherwise"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                return false;\r\n            }",
          "javadoc": {
            "description": "Check if a path is a valid Git repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to check"
              },
              {
                "name": "return",
                "value": "true if the path is a valid Git repository, false otherwise"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "listFilesRespectingGitignore",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n        Path dirPath \u003d Paths.get(directory);\r\n        File gitignoreFile \u003d new File(directory, \".gitignore\");\r\n        File dirFile \u003d new File(directory);\r\n\r\n        // List to store ignore patterns\r\n        List\u003cString\u003e ignorePatterns \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Load .gitignore patterns if the file exists\r\n        if (gitignoreFile.exists() \u0026\u0026 gitignoreFile.isFile()) {\r\n            try {\r\n                // Use FileUtils to read the file\r\n                String gitignoreContent \u003d io.joshuasalcedo.utility.FileUtils.readFileAsString(gitignoreFile);\r\n                String[] lines \u003d gitignoreContent.split(\"\\\\r?\\\\n\");\r\n\r\n                for (String line : lines) {\r\n                    // Skip empty lines and comments\r\n                    if (line.trim().isEmpty() || line.startsWith(\"#\")) {\r\n                        continue;\r\n                    }\r\n                    ignorePatterns.add(line.trim());\r\n                }\r\n            } catch (IOException e) {\r\n                // If there\u0027s an error reading .gitignore, log it but continue without ignore rules\r\n                System.err.println(\"Error reading .gitignore file: \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        // Use FileUtils to list all files (without respecting gitignore since we\u0027re handling that manually)\r\n        List\u003cFile\u003e allFiles \u003d io.joshuasalcedo.utility.FileUtils.listAllFiles(directory, false);\r\n        List\u003cFile\u003e result \u003d new ArrayList\u003c\u003e();\r\n\r\n        for (File file : allFiles) {\r\n            // Get the relative path from the base directory\r\n            String pathStr \u003d io.joshuasalcedo.utility.FileUtils.getRelativePath(file, dirFile).replace(\u0027\\\\\u0027, \u0027/\u0027);\r\n\r\n            // Check if the file matches any ignore pattern\r\n            boolean isIgnored \u003d false;\r\n            for (String pattern : ignorePatterns) {\r\n                if (matchesGitignorePattern(pathStr, pattern)) {\r\n                    isIgnored \u003d true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Add the file to the result if it\u0027s not ignored\r\n            if (!isIgnored) {\r\n                result.add(file);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }",
          "javadoc": {
            "description": "List all files in a directory, respecting .gitignore rules if present.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to list files from"
              },
              {
                "name": "return",
                "value": "List of files, excluding those matched by .gitignore rules"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            try {\r\n                // Use FileUtils to read the file\r\n                String gitignoreContent \u003d io.joshuasalcedo.utility.FileUtils.readFileAsString(gitignoreFile);\r\n                String[] lines \u003d gitignoreContent.split(\"\\\\r?\\\\n\");\r\n\r\n                for (String line : lines) {\r\n                    // Skip empty lines and comments\r\n                    if (line.trim().isEmpty() || line.startsWith(\"#\")) {\r\n                        continue;\r\n                    }\r\n                    ignorePatterns.add(line.trim());\r\n                }\r\n            } catch (IOException e) {\r\n                // If there\u0027s an error reading .gitignore, log it but continue without ignore rules\r\n                System.err.println(\"Error reading .gitignore file: \" + e.getMessage());\r\n            }\r\n        }",
          "javadoc": {
            "description": "List all files in a directory, respecting .gitignore rules if present.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to list files from"
              },
              {
                "name": "return",
                "value": "List of files, excluding those matched by .gitignore rules"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": [
            "List"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            try {\r\n                // Use FileUtils to read the file\r\n                String gitignoreContent \u003d io.joshuasalcedo.utility.FileUtils.readFileAsString(gitignoreFile);\r\n                String[] lines \u003d gitignoreContent.split(\"\\\\r?\\\\n\");\r\n\r\n                for (String line : lines) {\r\n                    // Skip empty lines and comments\r\n                    if (line.trim().isEmpty() || line.startsWith(\"#\")) {\r\n                        continue;\r\n                    }\r\n                    ignorePatterns.add(line.trim());\r\n                }\r\n            } catch (IOException e) {\r\n                // If there\u0027s an error reading .gitignore, log it but continue without ignore rules\r\n                System.err.println(\"Error reading .gitignore file: \" + e.getMessage());\r\n            }\r\n        }",
          "comments": [
            "List to store ignore patterns"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "exists",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            try {\r\n                // Use FileUtils to read the file\r\n                String gitignoreContent \u003d io.joshuasalcedo.utility.FileUtils.readFileAsString(gitignoreFile);\r\n                String[] lines \u003d gitignoreContent.split(\"\\\\r?\\\\n\");\r\n\r\n                for (String line : lines) {\r\n                    // Skip empty lines and comments\r\n                    if (line.trim().isEmpty() || line.startsWith(\"#\")) {\r\n                        continue;\r\n                    }\r\n                    ignorePatterns.add(line.trim());\r\n                }\r\n            } catch (IOException e) {\r\n                // If there\u0027s an error reading .gitignore, log it but continue without ignore rules\r\n                System.err.println(\"Error reading .gitignore file: \" + e.getMessage());\r\n            }\r\n        }",
          "comments": [
            "List to store ignore patterns",
            "Load .gitignore patterns if the file exists"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "comments",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                        continue;\r\n                    }",
          "comments": [
            "Skip empty lines and comments"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "all",
          "methodName": "files",
          "parameters": [
            {
              "type": "without",
              "name": "respecting"
            }
          ],
          "body": "{\r\n            // Get the relative path from the base directory\r\n            String pathStr \u003d io.joshuasalcedo.utility.FileUtils.getRelativePath(file, dirFile).replace(\u0027\\\\\u0027, \u0027/\u0027);\r\n\r\n            // Check if the file matches any ignore pattern\r\n            boolean isIgnored \u003d false;\r\n            for (String pattern : ignorePatterns) {\r\n                if (matchesGitignorePattern(pathStr, pattern)) {\r\n                    isIgnored \u003d true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Add the file to the result if it\u0027s not ignored\r\n            if (!isIgnored) {\r\n                result.add(file);\r\n            }\r\n        }",
          "comments": [
            "Use FileUtils to list all files (without respecting gitignore since we\u0027re handling that manually)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "ignored",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                result.add(file);\r\n            }",
          "comments": [
            "Add the file to the result if it\u0027s not ignored"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "matchesGitignorePattern",
          "parameters": [
            {
              "type": "String",
              "name": "path"
            },
            {
              "type": "String",
              "name": "pattern"
            }
          ],
          "body": "{\r\n        // Handle negation (patterns starting with !)\r\n        boolean negate \u003d pattern.startsWith(\"!\");\r\n        if (negate) {\r\n            pattern \u003d pattern.substring(1);\r\n        }\r\n\r\n        // Handle directory-only patterns (ending with /)\r\n        boolean dirOnly \u003d pattern.endsWith(\"/\");\r\n        if (dirOnly) {\r\n            pattern \u003d pattern.substring(0, pattern.length() - 1);\r\n        }\r\n\r\n        // Convert gitignore glob pattern to regex\r\n        pattern \u003d pattern\r\n            .replace(\".\", \"\\\\.\")   // Escape dots\r\n            .replace(\"*\", \".*\")    // * becomes .*\r\n            .replace(\"?\", \".\");    // ? becomes .\r\n\r\n        // Match the pattern against the path\r\n        boolean matches \u003d path.matches(pattern);\r\n\r\n        // Return the result, taking negation into account\r\n        return negate ? !matches : matches;\r\n    }",
          "javadoc": {
            "description": "Check if a file path matches a gitignore pattern.\r\nThis is a simplified implementation and doesn\u0027t handle all gitignore pattern features.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The file path to check"
              },
              {
                "name": "param",
                "value": "pattern The gitignore pattern"
              },
              {
                "name": "return",
                "value": "true if the path matches the pattern, false otherwise"
              }
            ]
          },
          "comments": [
            "Handle neg"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Handle",
          "methodName": "negation",
          "parameters": [
            {
              "type": "patterns",
              "name": "starting"
            }
          ],
          "body": "{\r\n            pattern \u003d pattern.substring(1);\r\n        }",
          "javadoc": {
            "description": "Check if a file path matches a gitignore pattern.\r\nThis is a simplified implementation and doesn\u0027t handle all gitignore pattern features.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The file path to check"
              },
              {
                "name": "param",
                "value": "pattern The gitignore pattern"
              },
              {
                "name": "return",
                "value": "true if the path matches the pattern, false otherwise"
              }
            ]
          },
          "comments": [
            "Handle negation (patterns starting with !)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "only",
          "methodName": "patterns",
          "parameters": [
            {
              "type": "ending",
              "name": "with"
            }
          ],
          "body": "{\r\n            pattern \u003d pattern.substring(0, pattern.length() - 1);\r\n        }",
          "comments": [
            "Handle directory-only patterns (ending with /)"
          ]
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    "src/test/resources/repo/src/main/java/App.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/resources/repo/src/main/java/App.java",
      "methods": [],
      "className": "App",
      "packageName": "com.test"
    },
    "src/main/java/io/joshuasalcedo/parsers/PomParser.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/parsers/PomParser.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Maven",
          "methodName": "POM",
          "parameters": [],
          "body": "{\r\n\r\n    // Prevent instantiation\r\n    private PomParser() {\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }\r\n\r\n    /**\r\n     * Parse a POM file and extract its Maven Model.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return Model object representing the POM file\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static Model parsePom(File pomFile) throws IOException {\r\n        try (FileInputStream inputStream \u003d new FileInputStream(pomFile)) {\r\n            MavenStaxReader mavenReader \u003d new MavenStaxReader();\r\n            try {\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Error parsing POM file: \" + e.getMessage(), e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract project coordinates (groupId, artifactId, version) from a POM file.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return PomCoordinates object with the project coordinates\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static PomCoordinates extractCoordinates(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        String groupId \u003d model.getGroupId();\r\n        String artifactId \u003d model.getArtifactId();\r\n        String version \u003d model.getVersion();\r\n\r\n        // If coordinates are not directly specified, they might be inherited from parent\r\n        if (groupId \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }\r\n\r\n        if (version \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            version \u003d model.getParent().getVersion();\r\n        }\r\n\r\n        return PomCoordinates.builder()\r\n                .groupId(groupId)\r\n                .artifactId(artifactId)\r\n                .version(version)\r\n                .build();\r\n    }\r\n\r\n    /**\r\n     * Extract all dependencies from a POM file.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return List of Dependency objects\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static List\u003cDependency\u003e extractDependencies(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n        return model.getDependencies();\r\n    }\r\n\r\n    /**\r\n     * Extract parent POM information if available.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return Parent object or null if no parent exists\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static Parent extractParentInfo(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n        return model.getParent();\r\n    }\r\n\r\n    /**\r\n     * Extract build plugins from a POM file.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return List of Plugin objects or empty list if no plugins exist\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static List\u003cPlugin\u003e extractPlugins(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        if (model.getBuild() \u003d\u003d null || model.getBuild().getPlugins() \u003d\u003d null) {\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n\r\n        return model.getBuild().getPlugins();\r\n    }\r\n\r\n    /**\r\n     * Extract module names for multi-module projects.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return List of module names or empty list if not a multi-module project\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static List\u003cString\u003e extractModules(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        if (model \u003d\u003d null) {\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n\r\n        return model.getSubprojects();\r\n    }\r\n\r\n    /**\r\n     * Find all POM files in a directory and its subdirectories.\r\n     * \r\n     * @param directory The directory to search\r\n     * @return List of POM files\r\n     */\r\n    public static List\u003cFile\u003e findPomFiles(File directory) {\r\n        try {\r\n            // Use FileUtils to find all files named \"pom.xml\"\r\n            return FileUtils.listFilesMatching(\r\n                directory.getAbsolutePath(), \r\n                false, \r\n                file -\u003e file.getName().equals(\"pom.xml\")\r\n            );\r\n        } catch (IOException e) {\r\n            System.err.println(\"Error finding POM files: \" + e.getMessage());\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert a POM Model to JSON.\r\n     *\r\n     * @param model The Maven Model object\r\n     * @return JSON representation of the model\r\n     */\r\n    public static String modelToJson(Model model) {\r\n        return JsonUtils.toPrettyJson(model);\r\n    }\r\n\r\n    /**\r\n     * Convert POM coordinates to JSON.\r\n     *\r\n     * @param coordinates The PomCoordinates object\r\n     * @return JSON representation of the coordinates\r\n     */\r\n    public static String coordinatesToJson(PomCoordinates coordinates) {\r\n        return JsonUtils.toPrettyJson(coordinates);\r\n    }\r\n\r\n    /**\r\n     * Convert a list of dependencies to JSON.\r\n     *\r\n     * @param dependencies The list of dependencies\r\n     * @return JSON representation of the dependencies\r\n     */\r\n    public static String dependenciesToJson(List\u003cDependency\u003e dependencies) {\r\n        return JsonUtils.toPrettyJson(dependencies);\r\n    }\r\n\r\n    /**\r\n     * Convert parent POM information to JSON.\r\n     *\r\n     * @param parent The Parent object\r\n     * @return JSON representation of the parent information\r\n     */\r\n    public static String parentToJson(Parent parent) {\r\n        return JsonUtils.toPrettyJson(parent);\r\n    }\r\n\r\n    /**\r\n     * Convert a list of plugins to JSON.\r\n     *\r\n     * @param plugins The list of plugins\r\n     * @return JSON representation of the plugins\r\n     */\r\n    public static String pluginsToJson(List\u003cPlugin\u003e plugins) {\r\n        return JsonUtils.toPrettyJson(plugins);\r\n    }\r\n\r\n    /**\r\n     * Convert a list of modules to JSON.\r\n     *\r\n     * @param modules The list of module names\r\n     * @return JSON representation of the modules\r\n     */\r\n    public static String modulesToJson(List\u003cString\u003e modules) {\r\n        return JsonUtils.toPrettyJson(modules);\r\n    }\r\n}",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "PomParser",
          "parameters": [],
          "body": "{\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Maven POM (pom.xml) files using the official Maven Model API.\r\nThis class provides static methods to analyze Maven project files and extract structural information.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AssertionError",
          "parameters": [
            {
              "type": "\"Utility",
              "name": "class"
            }
          ],
          "body": "{\r\n        try (FileInputStream inputStream \u003d new FileInputStream(pomFile)) {\r\n            MavenStaxReader mavenReader \u003d new MavenStaxReader();\r\n            try {\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Error parsing POM file: \" + e.getMessage(), e);\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Maven POM (pom.xml) files using the official Maven Model API.\r\nThis class provides static methods to analyze Maven project files and extract structural information.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Model",
          "methodName": "parsePom",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        try (FileInputStream inputStream \u003d new FileInputStream(pomFile)) {\r\n            MavenStaxReader mavenReader \u003d new MavenStaxReader();\r\n            try {\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Error parsing POM file: \" + e.getMessage(), e);\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Parse a POM file and extract its Maven Model.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "Model object representing the POM file"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "FileInputStream",
          "parameters": [],
          "body": "{\r\n            MavenStaxReader mavenReader \u003d new MavenStaxReader();\r\n            try {\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Error parsing POM file: \" + e.getMessage(), e);\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse a POM file and extract its Maven Model.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "Model object representing the POM file"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "MavenStaxReader",
          "parameters": [],
          "body": "{\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            }",
          "javadoc": {
            "description": "Parse a POM file and extract its Maven Model.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "Model object representing the POM file"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": [
            "Use the MavenStaxReader to read the P"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "IOException",
          "parameters": [
            {
              "type": "\"Error",
              "name": "parsing"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        String groupId \u003d model.getGroupId();\r\n        String artifactId \u003d model.getArtifactId();\r\n        String version \u003d model.getVersion();\r\n\r\n        // If coordinates are not directly specified, they might be inherited from parent\r\n        if (groupId \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }\r\n\r\n        if (version \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            version \u003d model.getParent().getVersion();\r\n        }\r\n\r\n        return PomCoordinates.builder()\r\n                .groupId(groupId)\r\n                .artifactId(artifactId)\r\n                .version(version)\r\n                .build();\r\n    }",
          "comments": [
            "Return the model as is - no conversion needed"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "project",
          "methodName": "coordinates",
          "parameters": [],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        String groupId \u003d model.getGroupId();\r\n        String artifactId \u003d model.getArtifactId();\r\n        String version \u003d model.getVersion();\r\n\r\n        // If coordinates are not directly specified, they might be inherited from parent\r\n        if (groupId \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }\r\n\r\n        if (version \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            version \u003d model.getParent().getVersion();\r\n        }\r\n\r\n        return PomCoordinates.builder()\r\n                .groupId(groupId)\r\n                .artifactId(artifactId)\r\n                .version(version)\r\n                .build();\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "PomCoordinates",
          "methodName": "extractCoordinates",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        String groupId \u003d model.getGroupId();\r\n        String artifactId \u003d model.getArtifactId();\r\n        String version \u003d model.getVersion();\r\n\r\n        // If coordinates are not directly specified, they might be inherited from parent\r\n        if (groupId \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }\r\n\r\n        if (version \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            version \u003d model.getParent().getVersion();\r\n        }\r\n\r\n        return PomCoordinates.builder()\r\n                .groupId(groupId)\r\n                .artifactId(artifactId)\r\n                .version(version)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Extract project coordinates (groupId, artifactId, version) from a POM file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "PomCoordinates object with the project coordinates"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parent",
          "methodName": "if",
          "parameters": [
            {
              "type": "groupId",
              "name": "\u003d\u003d"
            }
          ],
          "body": "{\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }",
          "comments": [
            "If coordinates are not directly specified, they might be inherited from parent"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cDependency\u003e",
          "methodName": "extractDependencies",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n        return model.getDependencies();\r\n    }",
          "javadoc": {
            "description": "Extract all dependencies from a POM file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "List of Dependency objects"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Parent",
          "methodName": "extractParentInfo",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n        return model.getParent();\r\n    }",
          "javadoc": {
            "description": "Extract parent POM information if available.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "Parent object or null if no parent exists"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cPlugin\u003e",
          "methodName": "extractPlugins",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        if (model.getBuild() \u003d\u003d null || model.getBuild().getPlugins() \u003d\u003d null) {\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n\r\n        return model.getBuild().getPlugins();\r\n    }",
          "javadoc": {
            "description": "Extract build plugins from a POM file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "List of Plugin objects or empty list if no plugins exist"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cString\u003e",
          "methodName": "extractModules",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        if (model \u003d\u003d null) {\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n\r\n        return model.getSubprojects();\r\n    }",
          "javadoc": {
            "description": "Extract module names for multi-module projects.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "List of module names or empty list if not a multi-module project"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "findPomFiles",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            }
          ],
          "body": "{\r\n        try {\r\n            // Use FileUtils to find all files named \"pom.xml\"\r\n            return FileUtils.listFilesMatching(\r\n                directory.getAbsolutePath(), \r\n                false, \r\n                file -\u003e file.getName().equals(\"pom.xml\")\r\n            );\r\n        } catch (IOException e) {\r\n            System.err.println(\"Error finding POM files: \" + e.getMessage());\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Find all POM files in a directory and its subdirectories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "return",
                "value": "List of POM files"
              }
            ]
          },
          "comments": [
            "Use FileUtils"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "modelToJson",
          "parameters": [
            {
              "type": "Model",
              "name": "model"
            }
          ],
          "body": "{\r\n        return JsonUtils.toPrettyJson(model);\r\n    }",
          "javadoc": {
            "description": "Convert a POM Model to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "model The Maven Model object"
              },
              {
                "name": "return",
                "value": "JSON representation of the model"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "coordinatesToJson",
          "parameters": [
            {
              "type": "PomCoordinates",
              "name": "coordinates"
            }
          ],
          "body": "{\r\n        return JsonUtils.toPrettyJson(coordinates);\r\n    }",
          "javadoc": {
            "description": "Convert POM coordinates to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "coordinates The PomCoordinates object"
              },
              {
                "name": "return",
                "value": "JSON representation of the coordinates"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "dependenciesToJson",
          "parameters": [
            {
              "type": "List\u003cDependency\u003e",
              "name": "dependencies"
            }
          ],
          "body": "{\r\n        return JsonUtils.toPrettyJson(dependencies);\r\n    }",
          "javadoc": {
            "description": "Convert a list of dependencies to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "dependencies The list of dependencies"
              },
              {
                "name": "return",
                "value": "JSON representation of the dependencies"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "parentToJson",
          "parameters": [
            {
              "type": "Parent",
              "name": "parent"
            }
          ],
          "body": "{\r\n        return JsonUtils.toPrettyJson(parent);\r\n    }",
          "javadoc": {
            "description": "Convert parent POM information to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "parent The Parent object"
              },
              {
                "name": "return",
                "value": "JSON representation of the parent information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "pluginsToJson",
          "parameters": [
            {
              "type": "List\u003cPlugin\u003e",
              "name": "plugins"
            }
          ],
          "body": "{\r\n        return JsonUtils.toPrettyJson(plugins);\r\n    }",
          "javadoc": {
            "description": "Convert a list of plugins to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "plugins The list of plugins"
              },
              {
                "name": "return",
                "value": "JSON representation of the plugins"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "modulesToJson",
          "parameters": [
            {
              "type": "List\u003cString\u003e",
              "name": "modules"
            }
          ],
          "body": "{\r\n        return JsonUtils.toPrettyJson(modules);\r\n    }",
          "javadoc": {
            "description": "Convert a list of modules to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "modules The list of module names"
              },
              {
                "name": "return",
                "value": "JSON representation of the modules"
              }
            ]
          },
          "comments": []
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    "src/main/java/io/joshuasalcedo/model/javafile/ClassStructure.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/javafile/ClassStructure.java",
      "methods": [],
      "className": "ClassStructure",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    "src/main/java/io/joshuasalcedo/model/javafile/MethodStructure.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/javafile/MethodStructure.java",
      "methods": [],
      "className": "MethodStructure",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    "src/main/java/io/joshuasalcedo/model/markdown/MarkdownImage.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/markdown/MarkdownImage.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "local",
          "methodName": "image",
          "parameters": [
            {
              "type": "file",
              "name": "path"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The title of the image, if any.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "external",
          "methodName": "image",
          "parameters": [],
          "body": "",
          "javadoc": {
            "description": "The title of the image, if any.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "MarkdownImage",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    "target/test-classes/repo/Utils.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/target/test-classes/repo/Utils.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "helper",
          "parameters": [],
          "body": "{ }",
          "comments": []
        }
      ],
      "className": "Utils",
      "packageName": "default"
    },
    "src/main/java/io/joshuasalcedo/model/javafile/JavadocStructure.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/javafile/JavadocStructure.java",
      "methods": [],
      "className": "JavadocStructure",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    "src/main/java/io/joshuasalcedo/parsers/JavaParser.java": {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/parsers/JavaParser.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "JavaParser",
          "parameters": [],
          "body": "{\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Java files and extracting structural information.\r\nThis class provides static methods to analyze Java source code.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AssertionError",
          "parameters": [
            {
              "type": "\"Utility",
              "name": "class"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Utility class for parsing Java files and extracting structural information.\r\nThis class provides static methods to analyze Java source code.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation",
            "Regular expression"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "findJavaFiles",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            }
          ],
          "body": "{\r\n        try {\r\n            return io.joshuasalcedo.utility.FileUtils.listFilesByExtension(directory.getAbsolutePath(), \"java\");\r\n        } catch (java.io.IOException e) {\r\n            // Log the error and return an empty list\r\n            System.err.println(\"Error finding Java files: \" + e.getMessage());\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Find all Java files in a directory and its subdirectories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "return",
                "value": "List of Java files"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "extractPackageName",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n        Matcher matcher \u003d PACKAGE_PATTERN.matcher(content);\r\n        return matcher.find() ? matcher.group(1) : \"default\";\r\n    }",
          "javadoc": {
            "description": "Extract the package name from Java file content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "The package name or \"default\" if not found"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "JavadocStructure",
          "methodName": "extractClassJavadoc",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n        // Find class declaration position\r\n        Matcher classMatcher \u003d CLASS_PATTERN.matcher(content);\r\n        if (!classMatcher.find()) {\r\n            return null;\r\n        }\r\n\r\n        // Get position of class declaration\r\n        int classPosition \u003d classMatcher.start();\r\n\r\n        // Search for JavaDoc before class declaration\r\n        String contentBeforeClass \u003d content.substring(0, classPosition);\r\n        Matcher javadocMatcher \u003d JAVADOC_PATTERN.matcher(contentBeforeClass);\r\n\r\n        // Find the last JavaDoc before class declaration\r\n        JavadocStructure javadoc \u003d null;\r\n        while (javadocMatcher.find()) {\r\n            String javadocText \u003d javadocMatcher.group(1).trim();\r\n            javadoc \u003d parseJavadoc(javadocText);\r\n        }\r\n\r\n        return javadoc;\r\n    }",
          "javadoc": {
            "description": "Extract the class JavaDoc from Java file content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "JavadocStructure object or null if not found"
              }
            ]
          },
          "comments": [
            "Find class declarat"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cString\u003e",
          "methodName": "extractClassComments",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n        List\u003cString\u003e comments \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Find class declaration position\r\n        Matcher classMatcher \u003d CLASS_PATTERN.matcher(content);\r\n        if (!classMatcher.find()) {\r\n            return comments;\r\n        }\r\n\r\n        // Get position of class declaration\r\n        int classPosition \u003d classMatcher.start();\r\n\r\n        // Define a window around the class declaration (200 chars before and after)\r\n        int startPos \u003d Math.max(0, classPosition - 200);\r\n        int endPos \u003d Math.min(content.length(), classPosition + 200);\r\n        String windowContent \u003d content.substring(startPos, endPos);\r\n\r\n        // Extract single-line comments\r\n        Matcher singleLineCommentMatcher \u003d SINGLE_LINE_COMMENT_PATTERN.matcher(windowContent);\r\n        while (singleLineCommentMatcher.find()) {\r\n            comments.add(singleLineCommentMatcher.group(1).trim());\r\n        }\r\n\r\n        // Extract multi-line comments (excluding JavaDoc)\r\n        Matcher multiLineCommentMatcher \u003d MULTI_LINE_COMMENT_PATTERN.matcher(windowContent);\r\n        while (multiLineCommentMatcher.find()) {\r\n            String commentText \u003d multiLineCommentMatcher.group(1).trim();\r\n            // If it doesn\u0027t start with *, it\u0027s not a JavaDoc\r\n            if (!commentText.startsWith(\"*\")) {\r\n                comments.add(commentText);\r\n            }\r\n        }\r\n\r\n        return comments;\r\n    }",
          "javadoc": {
            "description": "Extract all non-JavaDoc comments around the class declaration.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "List of comments"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "class",
          "methodName": "declaration",
          "parameters": [
            {
              "type": "200",
              "name": "chars"
            }
          ],
          "body": "{\r\n            comments.add(singleLineCommentMatcher.group(1).trim());\r\n        }",
          "comments": [
            "Get position of class declaration",
            "Define a window around the class declaration (200 chars before and after)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "line",
          "methodName": "comments",
          "parameters": [
            {
              "type": "excluding",
              "name": "JavaDoc"
            }
          ],
          "body": "{\r\n            String commentText \u003d multiLineCommentMatcher.group(1).trim();\r\n            // If it doesn\u0027t start with *, it\u0027s not a JavaDoc\r\n            if (!commentText.startsWith(\"*\")) {\r\n                comments.add(commentText);\r\n            }\r\n        }",
          "comments": [
            "Extract multi-line comments (excluding JavaDoc)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "JavaDoc",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                comments.add(commentText);\r\n            }",
          "comments": [
            "If it doesn\u0027t start with *, it\u0027s not a JavaDoc"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "ClassStructure",
          "methodName": "extractClassStructure",
          "parameters": [
            {
              "type": "String",
              "name": "fileName"
            },
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n        String packageName \u003d extractPackageName(content);\r\n\r\n        // Extract class name and type\r\n        String className \u003d fileName.replace(\".java\", \"\");\r\n        String classType \u003d \"class\";\r\n\r\n        Matcher classMatcher \u003d CLASS_PATTERN.matcher(content);\r\n        if (classMatcher.find()) {\r\n            className \u003d classMatcher.group(4);\r\n            classType \u003d classMatcher.group(3); // class, interface, or enum\r\n        }\r\n\r\n        // Extract methods\r\n        List\u003cMethodStructure\u003e methods \u003d extractMethods(content);\r\n\r\n        // Extract JavaDoc and comments\r\n        JavadocStructure javadoc \u003d extractClassJavadoc(content);\r\n        List\u003cString\u003e comments \u003d extractClassComments(content);\r\n\r\n        // Assuming you\u0027ve built a proper ClassStructure builder elsewhere\r\n        return ClassStructure.builder()\r\n                .fileName(fileName)\r\n                .packageName(packageName)\r\n                .className(className)\r\n                .classType(classType)\r\n                .methods(methods)\r\n                .javadoc(javadoc)\r\n                .comments(comments)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Extract the class structure from Java file content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "fileName The Java file name"
              },
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "ClassStructure object"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMethodStructure\u003e",
          "methodName": "extractMethods",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Extract all methods from a Java file content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "List of MethodStructure objects"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "signature",
          "methodName": "if",
          "parameters": [],
          "body": "{\")) {\r\n                    bodyStart \u003d content.indexOf(\"{\", bodyStart);\r\n                    if (bodyStart \u003e\u003d 0) {\r\n                        // Find the matching closing brace\r\n                        int bodyEnd \u003d findMatchingBrace(content, bodyStart);\r\n                        if (bodyEnd \u003e bodyStart) {\r\n                            // Extract the method body including braces\r\n                            body \u003d content.substring(bodyStart, bodyEnd + 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Assuming you\u0027ve built a proper MethodStructure builder elsewhere\r\n            MethodStructure method \u003d  MethodStructure.builder()\r\n                    .accessModifier(accessModifier !\u003d null ? accessModifier : \"\")\r\n                    .isStatic(staticModifier !\u003d null)\r\n                    .returnType(returnType)\r\n                    .methodName(methodName)\r\n                    .parameters(parseParameters(parameters))\r\n                    .body(body)\r\n                    .javadoc(javadoc)\r\n                    .comments(comments)\r\n                    .build();\r\n\r\n            methods.add(method);\r\n        }",
          "comments": [
            "Position after the method signature",
            "Search for the opening brace if not part of the signature"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "JavadocStructure",
          "methodName": "extractMethodJavadoc",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            },
            {
              "type": "int",
              "name": "methodPosition"
            }
          ],
          "body": "{\r\n        // Search for JavaDoc before method\r\n        int searchStart \u003d Math.max(0, methodPosition - 500); // Look up to 500 chars before method\r\n        String contentBefore \u003d content.substring(searchStart, methodPosition);\r\n\r\n        Matcher javadocMatcher \u003d JAVADOC_PATTERN.matcher(contentBefore);\r\n\r\n        // Find the last JavaDoc before method\r\n        JavadocStructure javadoc \u003d null;\r\n        while (javadocMatcher.find()) {\r\n            String javadocText \u003d javadocMatcher.group(1).trim();\r\n            javadoc \u003d parseJavadoc(javadocText);\r\n        }\r\n\r\n        return javadoc;\r\n    }",
          "javadoc": {
            "description": "Extract JavaDoc for a method.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "param",
                "value": "methodPosition Position of method in content"
              },
              {
                "name": "return",
                "value": "JavadocStructure object or null if not found"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cString\u003e",
          "methodName": "extractMethodComments",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            },
            {
              "type": "int",
              "name": "methodPosition"
            }
          ],
          "body": "{\r\n        List\u003cString\u003e comments \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Define a window around the method declaration\r\n        int startPos \u003d Math.max(0, methodPosition - 200);\r\n        int endPos \u003d Math.min(content.length(), methodPosition + 100);\r\n        String windowContent \u003d content.substring(startPos, endPos);\r\n\r\n        // Extract single-line comments\r\n        Matcher singleLineCommentMatcher \u003d SINGLE_LINE_COMMENT_PATTERN.matcher(windowContent);\r\n        while (singleLineCommentMatcher.find()) {\r\n            comments.add(singleLineCommentMatcher.group(1).trim());\r\n        }\r\n\r\n        // Extract multi-line comments (excluding JavaDoc)\r\n        Matcher multiLineCommentMatcher \u003d MULTI_LINE_COMMENT_PATTERN.matcher(windowContent);\r\n        while (multiLineCommentMatcher.find()) {\r\n            String commentText \u003d multiLineCommentMatcher.group(1).trim();\r\n            // If it doesn\u0027t start with *, it\u0027s not a JavaDoc\r\n            if (!commentText.startsWith(\"*\")) {\r\n                comments.add(commentText);\r\n            }\r\n        }\r\n\r\n        return comments;\r\n    }",
          "javadoc": {
            "description": "Extract non-JavaDoc comments for a method.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "param",
                "value": "methodPosition Position of method in content"
              },
              {
                "name": "return",
                "value": "List of comments"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "line",
          "methodName": "comments",
          "parameters": [
            {
              "type": "excluding",
              "name": "JavaDoc"
            }
          ],
          "body": "{\r\n            String commentText \u003d multiLineCommentMatcher.group(1).trim();\r\n            // If it doesn\u0027t start with *, it\u0027s not a JavaDoc\r\n            if (!commentText.startsWith(\"*\")) {\r\n                comments.add(commentText);\r\n            }\r\n        }",
          "comments": [
            "Extract multi-line comments (excluding JavaDoc)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "JavaDoc",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                comments.add(commentText);\r\n            }",
          "comments": [
            "If it doesn\u0027t start with *, it\u0027s not a JavaDoc"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "JavadocStructure",
          "methodName": "parseJavadoc",
          "parameters": [
            {
              "type": "String",
              "name": "javadocText"
            }
          ],
          "body": "{\r\n        // Clean up the JavaDoc text by removing leading asterisks and extra whitespace\r\n        String cleanJavadoc \u003d javadocText.replaceAll(\"^\\\\s*\\\\*\\\\s*\", \"\")\r\n                .replaceAll(\"\\\\n\\\\s*\\\\*\\\\s*\", \"\\n\")\r\n                .trim();\r\n\r\n        // Split into main description and tags\r\n        int firstTagIndex \u003d cleanJavadoc.indexOf(\"@\");\r\n        String description \u003d \"\";\r\n\r\n        if (firstTagIndex \u003d\u003d -1) {\r\n            // No tags, whole text is description\r\n            description \u003d cleanJavadoc;\r\n        } else {\r\n            // Extract description (text before first @tag)\r\n            description \u003d cleanJavadoc.substring(0, firstTagIndex).trim();\r\n        }\r\n\r\n        // Extract tags\r\n        List\u003cJavadocTag\u003e tags \u003d new ArrayList\u003c\u003e();\r\n        if (firstTagIndex !\u003d -1) {\r\n            Matcher tagMatcher \u003d JAVADOC_TAG_PATTERN.matcher(cleanJavadoc);\r\n\r\n            while (tagMatcher.find()) {\r\n                String tagName \u003d tagMatcher.group(1);\r\n                String tagValue \u003d tagMatcher.group(2).trim();\r\n\r\n                // Assuming you\u0027ve built a proper JavadocTag builder elsewhere\r\n                JavadocTag tag \u003d  JavadocTag.builder()\r\n                        .name(tagName)\r\n                        .value(tagValue)\r\n                        .build();\r\n\r\n                tags.add(tag);\r\n            }\r\n        }\r\n\r\n        // Assuming you\u0027ve built a proper JavadocStructure builder elsewhere\r\n        return  JavadocStructure.builder()\r\n                .description(description)\r\n                .tags(tags)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Parse a JavaDoc comment text into a structured representation.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "javadocText The JavaDoc text to parse"
              },
              {
                "name": "return",
                "value": "JavadocStructure object"
              }
            ]
          },
          "comments": [
            "Clean up the JavaDoc t"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Extract",
          "methodName": "description",
          "parameters": [
            {
              "type": "text",
              "name": "before"
            }
          ],
          "body": "{\r\n            Matcher tagMatcher \u003d JAVADOC_TAG_PATTERN.matcher(cleanJavadoc);\r\n\r\n            while (tagMatcher.find()) {\r\n                String tagName \u003d tagMatcher.group(1);\r\n                String tagValue \u003d tagMatcher.group(2).trim();\r\n\r\n                // Assuming you\u0027ve built a proper JavadocTag builder elsewhere\r\n                JavadocTag tag \u003d  JavadocTag.builder()\r\n                        .name(tagName)\r\n                        .value(tagValue)\r\n                        .build();\r\n\r\n                tags.add(tag);\r\n            }\r\n        }",
          "comments": [
            "No tags, whole text is description",
            "Extract description (text before first @tag)"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "int",
          "methodName": "findMatchingBrace",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            },
            {
              "type": "int",
              "name": "openingBracePos"
            }
          ],
          "body": "{\r\n        int count \u003d 1;\r\n        for (int i \u003d openingBracePos + 1; i \u003c content.length(); i++) {\r\n            char c \u003d content.charAt(i);\r\n            if (c \u003d\u003d \u0027{\u0027) {\r\n                count++;\r\n            } else if (c \u003d\u003d \u0027}\u0027) {\r\n                count--;\r\n                if (count \u003d\u003d 0) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1; // No matching brace found\r\n    }",
          "javadoc": {
            "description": "Find the position of the matching closing brace for an opening brace.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The text to search in"
              },
              {
                "name": "param",
                "value": "openingBracePos Position of the opening brace"
              },
              {
                "name": "return",
                "value": "Position of the matching closing brace or -1 if not found"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [
            {
              "type": "c",
              "name": "\u003d\u003d"
            }
          ],
          "body": "{\r\n                count--;\r\n                if (count \u003d\u003d 0) {\r\n                    return i;\r\n                }\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parameter",
          "methodName": "string",
          "parameters": [
            {
              "type": "\"String",
              "name": "name\""
            }
          ],
          "body": "{\r\n            if (parameterString \u003d\u003d null || parameterString.trim().isEmpty()) {\r\n                return null;\r\n            }\r\n\r\n            String cleanParam \u003d parameterString.trim();\r\n            String[] parts \u003d cleanParam.split(\"\\\\s+\");\r\n\r\n            if (parts.length \u003e\u003d 2) {\r\n                return Parameter.builder()\r\n                        .type(parts[0])\r\n                        .name(parts[1].replace(\")\", \"\"))\r\n                        .build();\r\n            }\r\n\r\n            return null;\r\n        }",
          "comments": [
            "No matching brace found"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Parameter",
          "methodName": "parseParameter",
          "parameters": [
            {
              "type": "String",
              "name": "parameterString"
            }
          ],
          "body": "{\r\n            if (parameterString \u003d\u003d null || parameterString.trim().isEmpty()) {\r\n                return null;\r\n            }\r\n\r\n            String cleanParam \u003d parameterString.trim();\r\n            String[] parts \u003d cleanParam.split(\"\\\\s+\");\r\n\r\n            if (parts.length \u003e\u003d 2) {\r\n                return Parameter.builder()\r\n                        .type(parts[0])\r\n                        .name(parts[1].replace(\")\", \"\"))\r\n                        .build();\r\n            }\r\n\r\n            return null;\r\n        }",
          "javadoc": {
            "description": "Parse a single parameter string into a Parameter object.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "parameterString The single parameter string (e.g., \"String name\")"
              },
              {
                "name": "return",
                "value": "Parameter object or null if parsing fails"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cParameter\u003e",
          "methodName": "parseParameters",
          "parameters": [
            {
              "type": "String",
              "name": "parameterString"
            }
          ],
          "body": "{\r\n            List\u003cParameter\u003e parameters \u003d new ArrayList\u003c\u003e();\r\n\r\n            if (parameterString \u003d\u003d null || parameterString.trim().isEmpty()) {\r\n                return parameters;\r\n            }\r\n\r\n            String[] paramArray \u003d parameterString.split(\",\");\r\n            for (String param : paramArray) {\r\n                Parameter parameter \u003d parseParameter(param);\r\n                if (parameter !\u003d null) {\r\n                    parameters.add(parameter);\r\n                }\r\n            }\r\n\r\n            return parameters;\r\n        }",
          "javadoc": {
            "description": "Parse method parameters into a list of Parameter objects.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "parameterString The parameter string from the method signature"
              },
              {
                "name": "return",
                "value": "List of Parameter objects"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "toJson",
          "parameters": [
            {
              "type": "ClassStructure",
              "name": "classStructure"
            }
          ],
          "body": "{\r\n        return io.joshuasalcedo.utility.JsonUtils.toPrettyJson(classStructure);\r\n    }",
          "javadoc": {
            "description": "Convert a ClassStructure object to JSON.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "classStructure The ClassStructure object to convert"
              },
              {
                "name": "return",
                "value": "JSON representation of the ClassStructure"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "toJson",
          "parameters": [
            {
              "type": "ClassStructure",
              "name": "classStructure"
            },
            {
              "type": "boolean",
              "name": "prettyPrint"
            }
          ],
          "body": "{\r\n        if (prettyPrint) {\r\n            return io.joshuasalcedo.utility.JsonUtils.toPrettyJson(classStructure);\r\n        } else {\r\n            return io.joshuasalcedo.utility.JsonUtils.toJson(classStructure);\r\n        }\r\n    }",
          "javadoc": {
            "description": "Convert a ClassStructure object to JSON with specified formatting.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "classStructure The ClassStructure object to convert"
              },
              {
                "name": "param",
                "value": "prettyPrint Whether to format the JSON with indentation"
              },
              {
                "name": "return",
                "value": "JSON representation of the ClassStructure"
              }
            ]
          },
          "comments": []
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    }
  },
  "htmlFiles": [
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/help-doc.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "help",
        "generator": "javadoc/HelpWriter",
        "title": "API Help (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 13,
      "links": 33,
      "title": "API Help (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/index.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "package index",
        "generator": "javadoc/PackageIndexWriter",
        "title": "Overview (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 12,
      "title": "Overview (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/allclasses-index.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "class index",
        "generator": "javadoc/AllClassesIndexWriter",
        "title": "All Classes and Interfaces (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 41,
      "title": "All Classes and Interfaces (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/search.html",
      "images": 1,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "search",
        "generator": "javadoc/SearchWriter",
        "title": "Search (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 6,
      "title": "Search (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/ParserRunner.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo, class: ParserRunner",
        "generator": "javadoc/ClassWriterImpl",
        "title": "ParserRunner (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 9,
      "links": 36,
      "title": "ParserRunner (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/package-use.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo",
        "generator": "javadoc/PackageUseWriter",
        "title": "Uses of Package io.joshuasalcedo (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 7,
      "title": "Uses of Package io.joshuasalcedo (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/package-summary.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo",
        "generator": "javadoc/PackageWriterImpl",
        "title": "io.joshuasalcedo (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 14,
      "title": "io.joshuasalcedo (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/class-use/ParserRunner.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo, class: ParserRunner",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.ParserRunner (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.ParserRunner (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/Property.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.maven, class: Property",
        "generator": "javadoc/ClassWriterImpl",
        "title": "Property (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "Property (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/ParentInfo.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.maven, class: ParentInfo",
        "generator": "javadoc/ClassWriterImpl",
        "title": "ParentInfo (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "ParentInfo (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/package-use.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.maven",
        "generator": "javadoc/PackageUseWriter",
        "title": "Uses of Package io.joshuasalcedo.model.maven (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 12,
      "title": "Uses of Package io.joshuasalcedo.model.maven (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/PomCoordinates.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.maven, class: PomCoordinates",
        "generator": "javadoc/ClassWriterImpl",
        "title": "PomCoordinates (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "PomCoordinates (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/package-summary.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.maven",
        "generator": "javadoc/PackageWriterImpl",
        "title": "io.joshuasalcedo.model.maven (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 16,
      "title": "io.joshuasalcedo.model.maven (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/class-use/Property.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.maven, class: Property",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.maven.Property (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.model.maven.Property (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/class-use/ParentInfo.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.maven, class: ParentInfo",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.maven.ParentInfo (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.model.maven.ParentInfo (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/class-use/PomCoordinates.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.maven, class: PomCoordinates",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.maven.PomCoordinates (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 22,
      "title": "Uses of Class io.joshuasalcedo.model.maven.PomCoordinates (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/class-use/PluginConfiguration.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.maven, class: PluginConfiguration",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.maven.PluginConfiguration (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.model.maven.PluginConfiguration (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/class-use/Dependency.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.maven, class: Dependency",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.maven.Dependency (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.model.maven.Dependency (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/class-use/Plugin.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.maven, class: Plugin",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.maven.Plugin (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.model.maven.Plugin (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/class-use/PomStructure.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.maven, class: PomStructure",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.maven.PomStructure (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.model.maven.PomStructure (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/package-tree.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "tree: package: io.joshuasalcedo.model.maven",
        "generator": "javadoc/PackageTreeWriter",
        "title": "io.joshuasalcedo.model.maven Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 15,
      "title": "io.joshuasalcedo.model.maven Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/PluginConfiguration.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.maven, class: PluginConfiguration",
        "generator": "javadoc/ClassWriterImpl",
        "title": "PluginConfiguration (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "PluginConfiguration (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/Dependency.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.maven, class: Dependency",
        "generator": "javadoc/ClassWriterImpl",
        "title": "Dependency (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "Dependency (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/Plugin.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.maven, class: Plugin",
        "generator": "javadoc/ClassWriterImpl",
        "title": "Plugin (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "Plugin (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/maven/PomStructure.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.maven, class: PomStructure",
        "generator": "javadoc/ClassWriterImpl",
        "title": "PomStructure (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "PomStructure (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/javafile/Parameter.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.javafile, class: Parameter",
        "generator": "javadoc/ClassWriterImpl",
        "title": "Parameter (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "Parameter (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/javafile/package-use.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.javafile",
        "generator": "javadoc/PackageUseWriter",
        "title": "Uses of Package io.joshuasalcedo.model.javafile (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 15,
      "title": "Uses of Package io.joshuasalcedo.model.javafile (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/javafile/package-summary.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.javafile",
        "generator": "javadoc/PackageWriterImpl",
        "title": "io.joshuasalcedo.model.javafile (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 14,
      "title": "io.joshuasalcedo.model.javafile (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/javafile/class-use/Parameter.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.javafile, class: Parameter",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.javafile.Parameter (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 23,
      "title": "Uses of Class io.joshuasalcedo.model.javafile.Parameter (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/javafile/class-use/JavadocStructure.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.javafile, class: JavadocStructure",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.javafile.JavadocStructure (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 23,
      "title": "Uses of Class io.joshuasalcedo.model.javafile.JavadocStructure (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/javafile/class-use/MethodStructure.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.javafile, class: MethodStructure",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.javafile.MethodStructure (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 18,
      "title": "Uses of Class io.joshuasalcedo.model.javafile.MethodStructure (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/javafile/class-use/JavadocTag.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.javafile, class: JavadocTag",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.javafile.JavadocTag (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.model.javafile.JavadocTag (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/javafile/class-use/ClassStructure.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.javafile, class: ClassStructure",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.javafile.ClassStructure (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 26,
      "title": "Uses of Class io.joshuasalcedo.model.javafile.ClassStructure (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/javafile/JavadocStructure.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.javafile, class: JavadocStructure",
        "generator": "javadoc/ClassWriterImpl",
        "title": "JavadocStructure (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "JavadocStructure (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/javafile/MethodStructure.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.javafile, class: MethodStructure",
        "generator": "javadoc/ClassWriterImpl",
        "title": "MethodStructure (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "MethodStructure (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/javafile/JavadocTag.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.javafile, class: JavadocTag",
        "generator": "javadoc/ClassWriterImpl",
        "title": "JavadocTag (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "JavadocTag (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/javafile/package-tree.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "tree: package: io.joshuasalcedo.model.javafile",
        "generator": "javadoc/PackageTreeWriter",
        "title": "io.joshuasalcedo.model.javafile Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 13,
      "title": "io.joshuasalcedo.model.javafile Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/javafile/ClassStructure.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.javafile, class: ClassStructure",
        "generator": "javadoc/ClassWriterImpl",
        "title": "ClassStructure (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "ClassStructure (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/markdown/package-use.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.markdown",
        "generator": "javadoc/PackageUseWriter",
        "title": "Uses of Package io.joshuasalcedo.model.markdown (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 16,
      "title": "Uses of Package io.joshuasalcedo.model.markdown (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/markdown/package-summary.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.markdown",
        "generator": "javadoc/PackageWriterImpl",
        "title": "io.joshuasalcedo.model.markdown (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 14,
      "title": "io.joshuasalcedo.model.markdown (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/markdown/class-use/MarkdownLink.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.markdown, class: MarkdownLink",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.markdown.MarkdownLink (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 24,
      "title": "Uses of Class io.joshuasalcedo.model.markdown.MarkdownLink (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/markdown/class-use/MarkdownCodeBlock.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.markdown, class: MarkdownCodeBlock",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.markdown.MarkdownCodeBlock (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 24,
      "title": "Uses of Class io.joshuasalcedo.model.markdown.MarkdownCodeBlock (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/markdown/class-use/MarkdownContent.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.markdown, class: MarkdownContent",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.markdown.MarkdownContent (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 31,
      "title": "Uses of Class io.joshuasalcedo.model.markdown.MarkdownContent (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/markdown/class-use/MarkdownHeading.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.markdown, class: MarkdownHeading",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.markdown.MarkdownHeading (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 24,
      "title": "Uses of Class io.joshuasalcedo.model.markdown.MarkdownHeading (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/markdown/class-use/MarkdownImage.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.markdown, class: MarkdownImage",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.markdown.MarkdownImage (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 24,
      "title": "Uses of Class io.joshuasalcedo.model.markdown.MarkdownImage (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/markdown/MarkdownLink.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.markdown, class: MarkdownLink",
        "generator": "javadoc/ClassWriterImpl",
        "title": "MarkdownLink (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "MarkdownLink (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/markdown/MarkdownCodeBlock.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.markdown, class: MarkdownCodeBlock",
        "generator": "javadoc/ClassWriterImpl",
        "title": "MarkdownCodeBlock (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "MarkdownCodeBlock (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/markdown/MarkdownContent.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.markdown, class: MarkdownContent",
        "generator": "javadoc/ClassWriterImpl",
        "title": "MarkdownContent (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "MarkdownContent (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/markdown/package-tree.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "tree: package: io.joshuasalcedo.model.markdown",
        "generator": "javadoc/PackageTreeWriter",
        "title": "io.joshuasalcedo.model.markdown Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 13,
      "title": "io.joshuasalcedo.model.markdown Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/markdown/MarkdownHeading.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.markdown, class: MarkdownHeading",
        "generator": "javadoc/ClassWriterImpl",
        "title": "MarkdownHeading (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "MarkdownHeading (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/markdown/MarkdownImage.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.markdown, class: MarkdownImage",
        "generator": "javadoc/ClassWriterImpl",
        "title": "MarkdownImage (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "MarkdownImage (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/package-use.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.git",
        "generator": "javadoc/PackageUseWriter",
        "title": "Uses of Package io.joshuasalcedo.model.git (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 17,
      "title": "Uses of Package io.joshuasalcedo.model.git (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/BranchInfo.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.git, class: BranchInfo",
        "generator": "javadoc/ClassWriterImpl",
        "title": "BranchInfo (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "BranchInfo (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/ContributorInfo.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.git, class: ContributorInfo",
        "generator": "javadoc/ClassWriterImpl",
        "title": "ContributorInfo (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "ContributorInfo (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/package-summary.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.git",
        "generator": "javadoc/PackageWriterImpl",
        "title": "io.joshuasalcedo.model.git (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 16,
      "title": "io.joshuasalcedo.model.git (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/class-use/BranchInfo.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.git, class: BranchInfo",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.git.BranchInfo (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.model.git.BranchInfo (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/class-use/ContributorInfo.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.git, class: ContributorInfo",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.git.ContributorInfo (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.model.git.ContributorInfo (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/class-use/FileChange.ChangeType.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.git, class: FileChange, enum: ChangeType",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Enum Class io.joshuasalcedo.model.git.FileChange.ChangeType (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 19,
      "title": "Uses of Enum Class io.joshuasalcedo.model.git.FileChange.ChangeType (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/class-use/GitRepositoryInfo.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.git, class: GitRepositoryInfo",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.git.GitRepositoryInfo (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 17,
      "title": "Uses of Class io.joshuasalcedo.model.git.GitRepositoryInfo (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/class-use/TagInfo.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.git, class: TagInfo",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.git.TagInfo (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.model.git.TagInfo (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/class-use/FileChange.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.git, class: FileChange",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.git.FileChange (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.model.git.FileChange (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/class-use/CommitInfo.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.model.git, class: CommitInfo",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.model.git.CommitInfo (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 44,
      "title": "Uses of Class io.joshuasalcedo.model.git.CommitInfo (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/package-tree.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "tree: package: io.joshuasalcedo.model.git",
        "generator": "javadoc/PackageTreeWriter",
        "title": "io.joshuasalcedo.model.git Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 3,
      "links": 20,
      "title": "io.joshuasalcedo.model.git Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/FileChange.ChangeType.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.git, class: FileChange, enum: ChangeType",
        "generator": "javadoc/ClassWriterImpl",
        "title": "FileChange.ChangeType (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 16,
      "links": 73,
      "title": "FileChange.ChangeType (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/GitRepositoryInfo.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.git, class: GitRepositoryInfo",
        "generator": "javadoc/ClassWriterImpl",
        "title": "GitRepositoryInfo (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "GitRepositoryInfo (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/TagInfo.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.git, class: TagInfo",
        "generator": "javadoc/ClassWriterImpl",
        "title": "TagInfo (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "TagInfo (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/FileChange.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.git, class: FileChange",
        "generator": "javadoc/ClassWriterImpl",
        "title": "FileChange (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 7,
      "links": 33,
      "title": "FileChange (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/model/git/CommitInfo.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.model.git, class: CommitInfo",
        "generator": "javadoc/ClassWriterImpl",
        "title": "CommitInfo (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 6,
      "links": 30,
      "title": "CommitInfo (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/Parser.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.parsers, class: Parser",
        "generator": "javadoc/ClassWriterImpl",
        "title": "Parser (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 7,
      "links": 33,
      "title": "Parser (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/package-use.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.parsers",
        "generator": "javadoc/PackageUseWriter",
        "title": "Uses of Package io.joshuasalcedo.parsers (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 7,
      "title": "Uses of Package io.joshuasalcedo.parsers (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/MarkdownParser.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.parsers, class: MarkdownParser",
        "generator": "javadoc/ClassWriterImpl",
        "title": "MarkdownParser (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 18,
      "links": 119,
      "title": "MarkdownParser (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/package-summary.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.parsers",
        "generator": "javadoc/PackageWriterImpl",
        "title": "io.joshuasalcedo.parsers (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 20,
      "title": "io.joshuasalcedo.parsers (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/GitParser.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.parsers, class: GitParser",
        "generator": "javadoc/ClassWriterImpl",
        "title": "GitParser (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 21,
      "links": 186,
      "title": "GitParser (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/class-use/Parser.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.parsers, class: Parser",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.parsers.Parser (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.parsers.Parser (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/class-use/MarkdownParser.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.parsers, class: MarkdownParser",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.parsers.MarkdownParser (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.parsers.MarkdownParser (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/class-use/GitParser.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.parsers, class: GitParser",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.parsers.GitParser (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.parsers.GitParser (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/class-use/PomParser.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.parsers, class: PomParser",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.parsers.PomParser (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.parsers.PomParser (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/class-use/HtmlParser.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.parsers, class: HtmlParser",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.parsers.HtmlParser (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.parsers.HtmlParser (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/class-use/Parser.parse.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.parsers, class: Parser, class: parse",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.parsers.Parser.parse (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.parsers.Parser.parse (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/class-use/JavaParser.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.parsers, class: JavaParser",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.parsers.JavaParser (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.parsers.JavaParser (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/PomParser.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.parsers, class: PomParser",
        "generator": "javadoc/ClassWriterImpl",
        "title": "PomParser (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 17,
      "links": 102,
      "title": "PomParser (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/package-tree.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "tree: package: io.joshuasalcedo.parsers",
        "generator": "javadoc/PackageTreeWriter",
        "title": "io.joshuasalcedo.parsers Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 15,
      "title": "io.joshuasalcedo.parsers Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/HtmlParser.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.parsers, class: HtmlParser",
        "generator": "javadoc/ClassWriterImpl",
        "title": "HtmlParser (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 33,
      "links": 168,
      "title": "HtmlParser (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/Parser.parse.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.parsers, class: Parser, class: parse",
        "generator": "javadoc/ClassWriterImpl",
        "title": "Parser.parse (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 13,
      "links": 87,
      "title": "Parser.parse (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/parsers/JavaParser.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.parsers, class: JavaParser",
        "generator": "javadoc/ClassWriterImpl",
        "title": "JavaParser (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 18,
      "links": 107,
      "title": "JavaParser (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/package-tree.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "tree: package: io.joshuasalcedo",
        "generator": "javadoc/PackageTreeWriter",
        "title": "io.joshuasalcedo Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 9,
      "title": "io.joshuasalcedo Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/utility/package-use.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.utility",
        "generator": "javadoc/PackageUseWriter",
        "title": "Uses of Package io.joshuasalcedo.utility (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 7,
      "title": "Uses of Package io.joshuasalcedo.utility (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/utility/package-summary.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.utility",
        "generator": "javadoc/PackageWriterImpl",
        "title": "io.joshuasalcedo.utility (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 16,
      "title": "io.joshuasalcedo.utility (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/utility/class-use/UtilityTest.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.utility, class: UtilityTest",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.utility.UtilityTest (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.utility.UtilityTest (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/utility/class-use/FileUtils.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.utility, class: FileUtils",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.utility.FileUtils (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.utility.FileUtils (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/utility/class-use/JsonUtils.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "use: package: io.joshuasalcedo.utility, class: JsonUtils",
        "generator": "javadoc/ClassUseWriter",
        "title": "Uses of Class io.joshuasalcedo.utility.JsonUtils (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 8,
      "title": "Uses of Class io.joshuasalcedo.utility.JsonUtils (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/utility/UtilityTest.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.utility, class: UtilityTest",
        "generator": "javadoc/ClassWriterImpl",
        "title": "UtilityTest (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 8,
      "links": 35,
      "title": "UtilityTest (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/utility/FileUtils.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.utility, class: FileUtils",
        "generator": "javadoc/ClassWriterImpl",
        "title": "FileUtils (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 23,
      "links": 130,
      "title": "FileUtils (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/utility/package-tree.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "tree: package: io.joshuasalcedo.utility",
        "generator": "javadoc/PackageTreeWriter",
        "title": "io.joshuasalcedo.utility Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 2,
      "links": 11,
      "title": "io.joshuasalcedo.utility Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/io/joshuasalcedo/utility/JsonUtils.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "declaration: package: io.joshuasalcedo.utility, class: JsonUtils",
        "generator": "javadoc/ClassWriterImpl",
        "title": "JsonUtils (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 10,
      "links": 51,
      "title": "JsonUtils (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/allpackages-index.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "package index",
        "generator": "javadoc/AllPackagesIndexWriter",
        "title": "All Packages (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 1,
      "links": 13,
      "title": "All Packages (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/overview-tree.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "class tree",
        "generator": "javadoc/TreeWriter",
        "title": "Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 3,
      "links": 53,
      "title": "Class Hierarchy (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/index-all.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "index",
        "generator": "javadoc/IndexWriter",
        "title": "Index (Java Structure Analyzer 1.0.0 API)"
      },
      "headings": 20,
      "links": 426,
      "title": "Index (Java Structure Analyzer 1.0.0 API)"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/overview-summary.html",
      "images": 0,
      "metadata": {
        "dc.created": "2025-05-09",
        "viewport": "width\u003ddevice-width, initial-scale\u003d1",
        "description": "index redirect",
        "generator": "javadoc/IndexRedirectWriter",
        "title": "Java Structure Analyzer 1.0.0 API"
      },
      "headings": 0,
      "links": 1,
      "title": "Java Structure Analyzer 1.0.0 API"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/target/test-classes/test/html/test.html",
      "images": 1,
      "metadata": {
        "keywords": "test, html, parser",
        "author": "Joshua Salcedo",
        "description": "Test HTML file for parser",
        "title": "Test HTML Document"
      },
      "headings": 5,
      "links": 2,
      "title": "Test HTML Document"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/.parsed/index.html",
      "images": 0,
      "metadata": {
        "viewport": "width\u003ddevice-width, initial-scale\u003d1.0",
        "title": "Parser Utility Viewer"
      },
      "headings": 4,
      "links": 0,
      "title": "Parser Utility Viewer"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/resources/test/html/test.html",
      "images": 1,
      "metadata": {
        "keywords": "test, html, parser",
        "author": "Joshua Salcedo",
        "description": "Test HTML file for parser",
        "title": "Test HTML Document"
      },
      "headings": 5,
      "links": 2,
      "title": "Test HTML Document"
    }
  ],
  "markdownFiles": [
    {
      "codeBlocks": [
        {
          "fenced": true,
          "language": "",
          "content": "Copyright jQuery Foundation and other contributors, https://jquery.org/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/jquery-ui\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n\u003d\u003d\u003d\u003d\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\u003d\u003d\u003d\u003d\n\nCopyright and related rights for sample code are waived via CC0. Sample\ncode is defined as all source code contained within the demos directory.\n\nCC0: http://creativecommons.org/publicdomain/zero/1.0/\n\n\u003d\u003d\u003d\u003d\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n\n"
        }
      ],
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/legal/jqueryUI.md",
      "images": [],
      "wordCount": 277,
      "headings": [
        {
          "level": 2,
          "text": "jQuery UI v1.13.2",
          "id": "jquery-ui-v1132"
        },
        {
          "level": 3,
          "text": "jQuery UI License",
          "id": "jquery-ui-license"
        }
      ],
      "links": [],
      "title": "jQuery UI v1.13.2",
      "readingTimeMinutes": 2
    },
    {
      "codeBlocks": [
        {
          "fenced": true,
          "language": "",
          "content": "jQuery v 3.7.1\nCopyright OpenJS Foundation and other contributors, https://openjsf.org/\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        }
      ],
      "path": "/home/joshuasalcedo-io/parser-utility/target/apidocs/legal/jquery.md",
      "images": [],
      "wordCount": 177,
      "headings": [
        {
          "level": 2,
          "text": "jQuery v3.7.1",
          "id": "jquery-v371"
        },
        {
          "level": 3,
          "text": "jQuery License",
          "id": "jquery-license"
        }
      ],
      "links": [],
      "title": "jQuery v3.7.1",
      "readingTimeMinutes": 1
    },
    {
      "codeBlocks": [
        {
          "fenced": true,
          "language": "",
          "content": "src/test/resources/\n├── sample-pom.xml                 # Sample POM file for PomParser tests\n├── multi-module-pom.xml           # Multi-module POM file for PomParser tests\n├── SampleClass.java               # Sample Java file for JavaParser tests\n├── sample.html                    # Sample HTML file for HtmlParser tests\n├── repo/                          # Git repository for GitParser tests\n└── multi-module-project/          # Directory structure for multi-module project tests\n    ├── pom.xml                    # Parent POM file\n    ├── module-a/\n    │   └── pom.xml               # Module A POM file\n    ├── module-b/\n    │   └── pom.xml               # Module B POM file\n    └── module-c/\n        └── pom.xml               # Module C POM file\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "mkdir -p src/test/resources/multi-module-project/module-a\nmkdir -p src/test/resources/multi-module-project/module-b\nmkdir -p src/test/resources/multi-module-project/module-c\nmkdir -p src/test/resources/java-files\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "chmod +x create-test-repo.sh\n./create-test-repo.sh\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "# Run all tests\nmvn test\n\n# Run specific test classes\nmvn test -Dtest\u003dPomParserTest\nmvn test -Dtest\u003dJavaParserTest\nmvn test -Dtest\u003dHtmlParserTest\nmvn test -Dtest\u003dGitParserTest\n"
        }
      ],
      "path": "/home/joshuasalcedo-io/parser-utility/target/test-classes/test/markdown/test.md",
      "images": [],
      "wordCount": 374,
      "headings": [
        {
          "level": 1,
          "text": "Parser Test Resources",
          "id": "parser-test-resources"
        },
        {
          "level": 2,
          "text": "Directory Structure",
          "id": "directory-structure"
        },
        {
          "level": 2,
          "text": "Setting Up Test Resources",
          "id": "setting-up-test-resources"
        },
        {
          "level": 2,
          "text": "Running Tests",
          "id": "running-tests"
        },
        {
          "level": 2,
          "text": "Test Contents",
          "id": "test-contents"
        },
        {
          "level": 3,
          "text": "PomParser Tests",
          "id": "pomparser-tests"
        },
        {
          "level": 3,
          "text": "JavaParser Tests",
          "id": "javaparser-tests"
        },
        {
          "level": 3,
          "text": "HtmlParser Tests",
          "id": "htmlparser-tests"
        },
        {
          "level": 3,
          "text": "GitParser Tests",
          "id": "gitparser-tests"
        },
        {
          "level": 2,
          "text": "Expected Test Failures",
          "id": "expected-test-failures"
        }
      ],
      "links": [],
      "title": "Parser Test Resources",
      "readingTimeMinutes": 2
    },
    {
      "codeBlocks": [],
      "path": "/home/joshuasalcedo-io/parser-utility/target/test-classes/repo/README.md",
      "images": [],
      "wordCount": 2,
      "headings": [
        {
          "level": 1,
          "text": "Test Repository",
          "id": "test-repository"
        }
      ],
      "links": [],
      "title": "Test Repository",
      "readingTimeMinutes": 1
    },
    {
      "codeBlocks": [
        {
          "fenced": true,
          "language": "",
          "content": "src/test/resources/\n├── sample-pom.xml                 # Sample POM file for PomParser tests\n├── multi-module-pom.xml           # Multi-module POM file for PomParser tests\n├── SampleClass.java               # Sample Java file for JavaParser tests\n├── sample.html                    # Sample HTML file for HtmlParser tests\n├── repo/                          # Git repository for GitParser tests\n└── multi-module-project/          # Directory structure for multi-module project tests\n    ├── pom.xml                    # Parent POM file\n    ├── module-a/\n    │   └── pom.xml               # Module A POM file\n    ├── module-b/\n    │   └── pom.xml               # Module B POM file\n    └── module-c/\n        └── pom.xml               # Module C POM file\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "mkdir -p src/test/resources/multi-module-project/module-a\nmkdir -p src/test/resources/multi-module-project/module-b\nmkdir -p src/test/resources/multi-module-project/module-c\nmkdir -p src/test/resources/java-files\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "chmod +x create-test-repo.sh\n./create-test-repo.sh\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "# Run all tests\nmvn test\n\n# Run specific test classes\nmvn test -Dtest\u003dPomParserTest\nmvn test -Dtest\u003dJavaParserTest\nmvn test -Dtest\u003dHtmlParserTest\nmvn test -Dtest\u003dGitParserTest\n"
        }
      ],
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/resources/test/markdown/test.md",
      "images": [],
      "wordCount": 374,
      "headings": [
        {
          "level": 1,
          "text": "Parser Test Resources",
          "id": "parser-test-resources"
        },
        {
          "level": 2,
          "text": "Directory Structure",
          "id": "directory-structure"
        },
        {
          "level": 2,
          "text": "Setting Up Test Resources",
          "id": "setting-up-test-resources"
        },
        {
          "level": 2,
          "text": "Running Tests",
          "id": "running-tests"
        },
        {
          "level": 2,
          "text": "Test Contents",
          "id": "test-contents"
        },
        {
          "level": 3,
          "text": "PomParser Tests",
          "id": "pomparser-tests"
        },
        {
          "level": 3,
          "text": "JavaParser Tests",
          "id": "javaparser-tests"
        },
        {
          "level": 3,
          "text": "HtmlParser Tests",
          "id": "htmlparser-tests"
        },
        {
          "level": 3,
          "text": "GitParser Tests",
          "id": "gitparser-tests"
        },
        {
          "level": 2,
          "text": "Expected Test Failures",
          "id": "expected-test-failures"
        }
      ],
      "links": [],
      "title": "Parser Test Resources",
      "readingTimeMinutes": 2
    },
    {
      "codeBlocks": [],
      "path": "/home/joshuasalcedo-io/parser-utility/src/test/resources/repo/README.md",
      "images": [],
      "wordCount": 2,
      "headings": [
        {
          "level": 1,
          "text": "Test Repository",
          "id": "test-repository"
        }
      ],
      "links": [],
      "title": "Test Repository",
      "readingTimeMinutes": 1
    },
    {
      "codeBlocks": [
        {
          "fenced": true,
          "language": "typescript",
          "content": "Output Structure\nThe parser generates a JSON structure with the following type definition:\ntypescript// Main Parser Output\ninterface ParserOutput {\n  git: GitRepositoryInfo;\n  java: Record\u003cstring, ClassStructure\u003e;\n  pom: Record\u003cstring, PomStructure\u003e;\n  markdown: Record\u003cstring, MarkdownContent\u003e;\n  html: Record\u003cstring, HtmlDocumentInfo\u003e;\n}\n\n// Git Repository Models\ninterface GitRepositoryInfo {\n  name: string;\n  path: string;\n  currentBranch: string;\n  remoteUrl: string;\n  latestCommit: CommitInfo;\n  branches: BranchInfo[];\n  tags: TagInfo[];\n  hasUncommittedChanges: boolean;\n  commitCount: number;\n  statistics: Record\u003cstring, any\u003e;\n  topContributors: ContributorInfo[];\n  creationDate: Date;\n  lastUpdatedDate: Date;\n  fileExtensionCounts: Record\u003cstring, number\u003e;\n}\n\ninterface CommitInfo {\n  id: string;\n  shortId: string;\n  message: string;\n  authorName: string;\n  authorEmail: string;\n  authorDate: Date;\n  committerName: string;\n  committerEmail: string;\n  commitDate: Date;\n  parentIds: string[];\n  changedFiles: FileChange[];\n}\n\ninterface FileChange {\n  type: ChangeType;\n  path: string;\n  oldPath: string;\n  linesAdded: number;\n  linesDeleted: number;\n  mode: number;\n}\n\nenum ChangeType {\n  ADD,\n  MODIFY,\n  DELETE,\n  RENAME,\n  COPY\n}\n\ninterface BranchInfo {\n  name: string;\n  current: boolean;\n  remote: boolean;\n  remoteName: string;\n  commitId: string;\n  trackingBranch: string;\n  merged: boolean;\n}\n\ninterface TagInfo {\n  name: string;\n  commitId: string;\n  annotated: boolean;\n  message: string;\n  taggerName: string;\n  taggerEmail: string;\n  taggerDate: Date;\n}\n\ninterface ContributorInfo {\n  name: string;\n  email: string;\n  commitCount: number;\n  linesAdded: number;\n  linesDeleted: number;\n  firstCommitDate: Date;\n  lastCommitDate: Date;\n}\n\n// Java File Models\ninterface ClassStructure {\n  name: string;\n  packageName: string;\n  path: string;\n  type: string;\n  modifiers: string[];\n  superclass: string;\n  interfaces: string[];\n  methods: MethodStructure[];\n  fields: FieldStructure[];\n  innerClasses: ClassStructure[];\n  javadoc: JavadocStructure;\n  imports: string[];\n  annotations: string[];\n}\n\ninterface MethodStructure {\n  name: string;\n  returnType: string;\n  modifiers: string[];\n  parameters: Parameter[];\n  exceptions: string[];\n  javadoc: JavadocStructure;\n  annotations: string[];\n  body: string;\n}\n\ninterface Parameter {\n  name: string;\n  type: string;\n  annotations: string[];\n}\n\ninterface JavadocStructure {\n  description: string;\n  tags: JavadocTag[];\n}\n\ninterface JavadocTag {\n  name: string;\n  value: string;\n}\n\ninterface FieldStructure {\n  name: string;\n  type: string;\n  modifiers: string[];\n  initialValue: string;\n  javadoc: JavadocStructure;\n  annotations: string[];\n}\n\n// Maven POM Models\ninterface PomStructure {\n  coordinates: PomCoordinates;\n  parent: ParentInfo;\n  name: string;\n  description: string;\n  url: string;\n  dependencies: Dependency[];\n  plugins: Plugin[];\n  properties: Property[];\n  modules: string[];\n  profiles: string[];\n}\n\ninterface PomCoordinates {\n  groupId: string;\n  artifactId: string;\n  version: string;\n  packaging: string;\n}\n\ninterface ParentInfo {\n  groupId: string;\n  artifactId: string;\n  version: string;\n  relativePath: string;\n}\n\ninterface Dependency {\n  groupId: string;\n  artifactId: string;\n  version: string;\n  scope: string;\n  optional: boolean;\n}\n\ninterface Plugin {\n  groupId: string;\n  artifactId: string;\n  version: string;\n  configuration: PluginConfiguration;\n}\n\ninterface PluginConfiguration {\n  properties: Record\u003cstring, string\u003e;\n}\n\ninterface Property {\n  name: string;\n  value: string;\n}\n\n// Markdown Models\ninterface MarkdownContent {\n  headings: MarkdownHeading[];\n  links: MarkdownLink[];\n  images: MarkdownImage[];\n  codeBlocks: MarkdownCodeBlock[];\n  plainText: string;\n}\n\ninterface MarkdownHeading {\n  level: number;\n  text: string;\n  id: string;\n}\n\ninterface MarkdownLink {\n  text: string;\n  url: string;\n  title: string;\n}\n\ninterface MarkdownImage {\n  altText: string;\n  url: string;\n  title: string;\n}\n\ninterface MarkdownCodeBlock {\n  language: string;\n  code: string;\n}\n\n// HTML Models\ninterface HtmlDocumentInfo {\n  title: string;\n  headings: HtmlHeading[];\n  links: HtmlLink[];\n  images: HtmlImage[];\n  metadata: Record\u003cstring, string\u003e;\n}\n\ninterface HtmlHeading {\n  level: number;\n  text: string;\n  id: string;\n}\n\ninterface HtmlLink {\n  text: string;\n  href: string;\n  rel: string;\n}\n\ninterface HtmlImage {\n  src: string;\n  alt: string;\n  width: number;\n  height: number;\n}\n"
        },
        {
          "fenced": true,
          "language": "",
          "content": "json{\n  \"git\": {\n    \"name\": \"parser-utility\",\n    \"path\": \"/path/to/repository\",\n    \"currentBranch\": \"main\",\n    // More Git information...\n  },\n  \"java\": {\n    \"io.joshuasalcedo.ParserRunner\": {\n      \"name\": \"ParserRunner\",\n      \"packageName\": \"io.joshuasalcedo\",\n      // More Java class information...\n    }\n    // More Java classes...\n  },\n  // More sections for POM, Markdown, and HTML...\n}\n"
        },
        {
          "fenced": true,
          "language": "xml",
          "content": "\u003cdependency\u003e\n    \u003cgroupId\u003eio.joshuasalcedo\u003c/groupId\u003e\n    \u003cartifactId\u003eparser-utility\u003c/artifactId\u003e\n    \u003cversion\u003e1.0.0\u003c/version\u003e\n\u003c/dependency\u003e\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "git clone https://github.com/joshuasalcedo-io/parser-utility.git\ncd parser-utility\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "mvn clean package\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "java -jar parser-utility.jar [command] [arguments]\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "# Show help information\njava -jar parser-utility.jar help\n\n# Parse all supported files in the current directory\njava -jar parser-utility.jar all .\n\n# Parse Java files in a specific directory\njava -jar parser-utility.jar java src/main/java\n\n# Parse a Git repository\njava -jar parser-utility.jar git /path/to/repo\n\n# Parse POM files\njava -jar parser-utility.jar pom .\n\n# Parse HTML files\njava -jar parser-utility.jar html src/main/resources\n\n# Parse Markdown files\njava -jar parser-utility.jar markdown docs\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "mvn exec:java -Dexec.mainClass\u003d\"io.joshuasalcedo.ParserRunner\" -Dexec.args\u003d\"all .\"\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "# Make the script executable\nchmod +x parse.sh\n\n# Run the demo\n./parse.sh\n"
        },
        {
          "fenced": true,
          "language": "java",
          "content": "import io.joshuasalcedo.parsers.Parser;\nimport java.util.Map;\n\n// Parse Java files\nMap\u003cString, Object\u003e javaResults \u003d Parser.parse.java(\"/path/to/java/files\");\n\n// Parse Git repository\nMap\u003cString, Object\u003e gitResults \u003d Parser.parse.git(\"/path/to/repo\");\n\n// Parse all supported files\nMap\u003cString, Object\u003e allResults \u003d Parser.parse.all(\"/path/to/project\");\n"
        },
        {
          "fenced": true,
          "language": "xml",
          "content": "\u003csettings\u003e\n  \u003cservers\u003e\n    \u003cserver\u003e\n      \u003cid\u003egithub\u003c/id\u003e\n      \u003cusername\u003eYOUR_GITHUB_USERNAME\u003c/username\u003e\n      \u003cpassword\u003eYOUR_GITHUB_TOKEN\u003c/password\u003e\n    \u003c/server\u003e\n  \u003c/servers\u003e\n\u003c/settings\u003e\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "mvn clean deploy -P github\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "mvn site\n"
        },
        {
          "fenced": true,
          "language": "xml",
          "content": "\u003csettings\u003e\n  \u003cservers\u003e\n    \u003cserver\u003e\n      \u003cid\u003egithub\u003c/id\u003e\n      \u003cusername\u003eYOUR_GITHUB_USERNAME\u003c/username\u003e\n      \u003cpassword\u003eYOUR_GITHUB_TOKEN\u003c/password\u003e\n    \u003c/server\u003e\n  \u003c/servers\u003e\n\u003c/settings\u003e\n"
        },
        {
          "fenced": true,
          "language": "bash",
          "content": "mvn site site:deploy\n"
        }
      ],
      "path": "/home/joshuasalcedo-io/parser-utility/README.md",
      "images": [],
      "wordCount": 1388,
      "headings": [
        {
          "level": 1,
          "text": "Parser Utility",
          "id": "parser-utility"
        },
        {
          "level": 2,
          "text": "Usage",
          "id": "usage"
        },
        {
          "level": 2,
          "text": "Features",
          "id": "features"
        },
        {
          "level": 2,
          "text": "Installation",
          "id": "installation"
        },
        {
          "level": 3,
          "text": "Maven Dependency",
          "id": "maven-dependency"
        },
        {
          "level": 3,
          "text": "Building from Source",
          "id": "building-from-source"
        },
        {
          "level": 2,
          "text": "Usage",
          "id": "usage"
        },
        {
          "level": 3,
          "text": "Command-Line Interface",
          "id": "command-line-interface"
        },
        {
          "level": 4,
          "text": "Available Commands",
          "id": "available-commands"
        },
        {
          "level": 4,
          "text": "Examples",
          "id": "examples"
        },
        {
          "level": 3,
          "text": "Using with Maven",
          "id": "using-with-maven"
        },
        {
          "level": 3,
          "text": "Demo Script",
          "id": "demo-script"
        },
        {
          "level": 2,
          "text": "Output",
          "id": "output"
        },
        {
          "level": 3,
          "text": "JSON Structure",
          "id": "json-structure"
        },
        {
          "level": 2,
          "text": "Programmatic Usage",
          "id": "programmatic-usage"
        },
        {
          "level": 2,
          "text": "Deployment to GitHub Packages",
          "id": "deployment-to-github-packages"
        },
        {
          "level": 2,
          "text": "GitHub Wiki Documentation",
          "id": "github-wiki-documentation"
        },
        {
          "level": 3,
          "text": "Generating Documentation",
          "id": "generating-documentation"
        },
        {
          "level": 3,
          "text": "Deploying to GitHub Wiki",
          "id": "deploying-to-github-wiki"
        },
        {
          "level": 2,
          "text": "Contributing",
          "id": "contributing"
        },
        {
          "level": 2,
          "text": "License",
          "id": "license"
        }
      ],
      "links": [
        {
          "internal": false,
          "text": ".parsed",
          "url": ".parsed"
        }
      ],
      "title": "Parser Utility",
      "readingTimeMinutes": 7
    },
    {
      "codeBlocks": [
        {
          "fenced": true,
          "language": "java",
          "content": "/**\n * Brief description of what the method does.\n * \n * @param paramName Description of the parameter\n * @return Description of the return value\n * @throws ExceptionType Description of when this exception is thrown\n */\npublic ReturnType methodName(ParamType paramName) throws ExceptionType {\n    // Method implementation\n}\n"
        }
      ],
      "path": "/home/joshuasalcedo-io/parser-utility/CODING_GUIDELINES.md",
      "images": [],
      "wordCount": 1004,
      "headings": [
        {
          "level": 1,
          "text": "Coding Guidelines",
          "id": "coding-guidelines"
        },
        {
          "level": 2,
          "text": "Table of Contents",
          "id": "table-of-contents"
        },
        {
          "level": 2,
          "text": "Introduction",
          "id": "introduction"
        },
        {
          "level": 2,
          "text": "Code Style and Formatting",
          "id": "code-style-and-formatting"
        },
        {
          "level": 3,
          "text": "General Guidelines",
          "id": "general-guidelines"
        },
        {
          "level": 3,
          "text": "Java-Specific Guidelines",
          "id": "java-specific-guidelines"
        },
        {
          "level": 3,
          "text": "Class Structure",
          "id": "class-structure"
        },
        {
          "level": 2,
          "text": "Naming Conventions",
          "id": "naming-conventions"
        },
        {
          "level": 3,
          "text": "General Guidelines",
          "id": "general-guidelines"
        },
        {
          "level": 3,
          "text": "Specific Naming Rules",
          "id": "specific-naming-rules"
        },
        {
          "level": 2,
          "text": "Documentation",
          "id": "documentation"
        },
        {
          "level": 3,
          "text": "Javadoc",
          "id": "javadoc"
        },
        {
          "level": 3,
          "text": "Example Javadoc Format",
          "id": "example-javadoc-format"
        },
        {
          "level": 3,
          "text": "Code Comments",
          "id": "code-comments"
        },
        {
          "level": 2,
          "text": "Testing",
          "id": "testing"
        },
        {
          "level": 3,
          "text": "General Guidelines",
          "id": "general-guidelines"
        },
        {
          "level": 3,
          "text": "JUnit Guidelines",
          "id": "junit-guidelines"
        },
        {
          "level": 3,
          "text": "Test Resources",
          "id": "test-resources"
        },
        {
          "level": 2,
          "text": "Error Handling",
          "id": "error-handling"
        },
        {
          "level": 3,
          "text": "Exception Guidelines",
          "id": "exception-guidelines"
        },
        {
          "level": 3,
          "text": "Logging",
          "id": "logging"
        },
        {
          "level": 2,
          "text": "Project Structure",
          "id": "project-structure"
        },
        {
          "level": 3,
          "text": "Directory Structure",
          "id": "directory-structure"
        },
        {
          "level": 3,
          "text": "Package Organization",
          "id": "package-organization"
        },
        {
          "level": 2,
          "text": "Version Control",
          "id": "version-control"
        },
        {
          "level": 3,
          "text": "Git Guidelines",
          "id": "git-guidelines"
        },
        {
          "level": 3,
          "text": "Pull Requests",
          "id": "pull-requests"
        },
        {
          "level": 2,
          "text": "Dependencies",
          "id": "dependencies"
        },
        {
          "level": 3,
          "text": "General Guidelines",
          "id": "general-guidelines"
        },
        {
          "level": 3,
          "text": "Maven Guidelines",
          "id": "maven-guidelines"
        },
        {
          "level": 2,
          "text": "Performance Considerations",
          "id": "performance-considerations"
        },
        {
          "level": 3,
          "text": "General Guidelines",
          "id": "general-guidelines"
        },
        {
          "level": 3,
          "text": "Specific Recommendations",
          "id": "specific-recommendations"
        }
      ],
      "links": [
        {
          "internal": true,
          "text": "Introduction",
          "url": "#introduction"
        },
        {
          "internal": true,
          "text": "Code Style and Formatting",
          "url": "#code-style-and-formatting"
        },
        {
          "internal": true,
          "text": "Naming Conventions",
          "url": "#naming-conventions"
        },
        {
          "internal": true,
          "text": "Documentation",
          "url": "#documentation"
        },
        {
          "internal": true,
          "text": "Testing",
          "url": "#testing"
        },
        {
          "internal": true,
          "text": "Error Handling",
          "url": "#error-handling"
        },
        {
          "internal": true,
          "text": "Project Structure",
          "url": "#project-structure"
        },
        {
          "internal": true,
          "text": "Version Control",
          "url": "#version-control"
        },
        {
          "internal": true,
          "text": "Dependencies",
          "url": "#dependencies"
        },
        {
          "internal": true,
          "text": "Performance Considerations",
          "url": "#performance-considerations"
        },
        {
          "internal": false,
          "text": "Oracle Java Code Conventions",
          "url": "https://www.oracle.com/java/technologies/javase/codeconventions-contents.html"
        }
      ],
      "title": "Coding Guidelines",
      "readingTimeMinutes": 5
    },
    {
      "codeBlocks": [
        {
          "fenced": true,
          "language": "java",
          "content": "\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\n/**\n * JavaStructureAnalyzer - A utility to analyze Java source files and output their structure in JSON format.\n * This program walks through a directory, finds all Java files, and extracts information about packages,\n * classes, methods, parameters, return types, method bodies, and comments.\n */\npublic class JavaStructureAnalyzer {\n\n    // Regular expressions for parsing Java code\n    private static final Pattern PACKAGE_PATTERN \u003d Pattern.compile(\"package\\\\s+([\\\\w.]+)\\\\s*;\");\n    private static final Pattern CLASS_PATTERN \u003d Pattern.compile(\"(public|private|protected)?\\\\s*(static)?\\\\s*(class|interface|enum)\\\\s+(\\\\w+)\");\n    private static final Pattern METHOD_PATTERN \u003d Pattern.compile(\"(public|private|protected)?\\\\s*(static)?\\\\s*(\\\\w+(?:\u003c.*\u003e)?)\\\\s+(\\\\w+)\\\\s*\\\\(([^)]*)\\\\)\");\n    private static final Pattern METHOD_BODY_PATTERN \u003d Pattern.compile(\"(public|private|protected)?\\\\s*(static)?\\\\s*(\\\\w+(?:\u003c.*\u003e)?)\\\\s+(\\\\w+)\\\\s*\\\\(([^)]*)\\\\)\\\\s*(?:throws\\\\s+[\\\\w,\\\\s.]+)?\\\\s*\\\\{\");\n    \n    // Regular expressions for parsing JavaDoc and comments\n    private static final Pattern JAVADOC_PATTERN \u003d Pattern.compile(\"/\\\\*\\\\*(.*?)\\\\*/\", Pattern.DOTALL);\n    private static final Pattern SINGLE_LINE_COMMENT_PATTERN \u003d Pattern.compile(\"//(.*)$\", Pattern.MULTILINE);\n    private static final Pattern MULTI_LINE_COMMENT_PATTERN \u003d Pattern.compile(\"/\\\\*(.*?)\\\\*/\", Pattern.DOTALL);\n    private static final Pattern JAVADOC_TAG_PATTERN \u003d Pattern.compile(\"@(\\\\w+)\\\\s+(.*?)(?\u003d\\\\s*@|\\\\s*\\\\*/|$)\", Pattern.DOTALL);\n\n    /**\n     * Main method that prompts for a directory and processes all Java files.\n     */\n    public static void main(String[] args) {\n        Scanner scanner \u003d new Scanner(System.in);\n        System.out.print(\"Enter the root directory to analyze: \");\n        String rootDirectory \u003d scanner.nextLine();\n        scanner.close();\n\n        try {\n            File rootDir \u003d new File(rootDirectory);\n            if (!rootDir.exists() || !rootDir.isDirectory()) {\n                System.err.println(\"Invalid directory: \" + rootDirectory);\n                return;\n            }\n\n            Map\u003cString, List\u003cClassStructure\u003e\u003e packageToClassesMap \u003d new HashMap\u003c\u003e();\n            \n            // Find all Java files in the directory and its subdirectories\n            List\u003cFile\u003e javaFiles \u003d findJavaFiles(rootDir);\n            System.out.println(\"Found \" + javaFiles.size() + \" Java files to analyze.\");\n            \n            // Process each Java file\n            for (File file : javaFiles) {\n                try {\n                    String content \u003d Files.readString(file.toPath());\n                    \n                    // Extract package name\n                    String packageName \u003d extractPackageName(content);\n                    \n                    // Extract class structure\n                    ClassStructure classStructure \u003d extractClassStructure(file.getName(), content);\n                    classStructure.setPackageName(packageName);\n                    \n                    // Extract class comments\n                    classStructure.setJavadoc(extractClassJavadoc(content));\n                    classStructure.setComments(extractClassComments(content));\n                    \n                    // Add to the package map\n                    packageToClassesMap.computeIfAbsent(packageName, k -\u003e new ArrayList\u003c\u003e())\n                                      .add(classStructure);\n                    \n                    System.out.println(\"Processed: \" + file.getPath());\n                } catch (IOException e) {\n                    System.err.println(\"Error processing file \" + file.getPath() + \": \" + e.getMessage());\n                }\n            }\n            \n            // Convert to JSON and save to file\n            Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\n            String json \u003d gson.toJson(packageToClassesMap);\n            \n            String outputFile \u003d rootDirectory + File.separator + \"java-structure.json\";\n            try (FileWriter writer \u003d new FileWriter(outputFile)) {\n                writer.write(json);\n                System.out.println(\"Analysis complete. JSON output saved to: \" + outputFile);\n            }\n            \n        } catch (Exception e) {\n            System.err.println(\"Error during analysis: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Find all Java files in a directory and its subdirectories.\n     */\n    private static List\u003cFile\u003e findJavaFiles(File directory) {\n        List\u003cFile\u003e javaFiles \u003d new ArrayList\u003c\u003e();\n        findJavaFilesRecursive(directory, javaFiles);\n        return javaFiles;\n    }\n\n    /**\n     * Recursive helper method to find all Java files.\n     */\n    private static void findJavaFilesRecursive(File directory, List\u003cFile\u003e javaFiles) {\n        File[] files \u003d directory.listFiles();\n        if (files !\u003d null) {\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    findJavaFilesRecursive(file, javaFiles);\n                } else if (file.getName().endsWith(\".java\")) {\n                    javaFiles.add(file);\n                }\n            }\n        }\n    }\n\n    /**\n     * Extract the package name from a Java file content.\n     */\n    private static String extractPackageName(String content) {\n        Matcher matcher \u003d PACKAGE_PATTERN.matcher(content);\n        return matcher.find() ? matcher.group(1) : \"default\";\n    }\n\n    /**\n     * Extract the class JavaDoc from a Java file content.\n     */\n    private static JavadocStructure extractClassJavadoc(String content) {\n        // Find class declaration position\n        Matcher classMatcher \u003d CLASS_PATTERN.matcher(content);\n        if (!classMatcher.find()) {\n            return null;\n        }\n        \n        // Get position of class declaration\n        int classPosition \u003d classMatcher.start();\n        \n        // Search for JavaDoc before class declaration\n        String contentBeforeClass \u003d content.substring(0, classPosition);\n        Matcher javadocMatcher \u003d JAVADOC_PATTERN.matcher(contentBeforeClass);\n        \n        // Find the last JavaDoc before class declaration\n        JavadocStructure javadoc \u003d null;\n        while (javadocMatcher.find()) {\n            String javadocText \u003d javadocMatcher.group(1).trim();\n            javadoc \u003d parseJavadoc(javadocText);\n        }\n        \n        return javadoc;\n    }\n\n    /**\n     * Extract all non-JavaDoc comments around the class declaration.\n     */\n    private static List\u003cString\u003e extractClassComments(String content) {\n        List\u003cString\u003e comments \u003d new ArrayList\u003c\u003e();\n        \n        // Find class declaration position\n        Matcher classMatcher \u003d CLASS_PATTERN.matcher(content);\n        if (!classMatcher.find()) {\n            return comments;\n        }\n        \n        // Get position of class declaration\n        int classPosition \u003d classMatcher.start();\n        \n        // Define a window around the class declaration (200 chars before and after)\n        int startPos \u003d Math.max(0, classPosition - 200);\n        int endPos \u003d Math.min(content.length(), classPosition + 200);\n        String windowContent \u003d content.substring(startPos, endPos);\n        \n        // Extract single-line comments\n        Matcher singleLineCommentMatcher \u003d SINGLE_LINE_COMMENT_PATTERN.matcher(windowContent);\n        while (singleLineCommentMatcher.find()) {\n            comments.add(singleLineCommentMatcher.group(1).trim());\n        }\n        \n        // Extract multi-line comments (excluding JavaDoc)\n        Matcher multiLineCommentMatcher \u003d MULTI_LINE_COMMENT_PATTERN.matcher(windowContent);\n        while (multiLineCommentMatcher.find()) {\n            String commentText \u003d multiLineCommentMatcher.group(1).trim();\n            // If it doesn\u0027t start with *, it\u0027s not a JavaDoc\n            if (!commentText.startsWith(\"*\")) {\n                comments.add(commentText);\n            }\n        }\n        \n        return comments;\n    }\n\n    /**\n     * Extract the class structure from a Java file content.\n     */\n    private static ClassStructure extractClassStructure(String fileName, String content) {\n        ClassStructure classStructure \u003d new ClassStructure();\n        classStructure.setFileName(fileName);\n        \n        // Extract class name\n        Matcher classMatcher \u003d CLASS_PATTERN.matcher(content);\n        if (classMatcher.find()) {\n            classStructure.setClassName(classMatcher.group(4));\n            classStructure.setClassType(classMatcher.group(3)); // class, interface, or enum\n        } else {\n            classStructure.setClassName(fileName.replace(\".java\", \"\"));\n            classStructure.setClassType(\"class\");\n        }\n        \n        // Extract methods\n        List\u003cMethodStructure\u003e methods \u003d extractMethods(content);\n        classStructure.setMethods(methods);\n        \n        return classStructure;\n    }\n\n    /**\n     * Extract all methods from a Java file content.\n     */\n    private static List\u003cMethodStructure\u003e extractMethods(String content) {\n        List\u003cMethodStructure\u003e methods \u003d new ArrayList\u003c\u003e();\n        Matcher methodMatcher \u003d METHOD_PATTERN.matcher(content);\n        \n        while (methodMatcher.find()) {\n            MethodStructure method \u003d new MethodStructure();\n            \n            String accessModifier \u003d methodMatcher.group(1);\n            String staticModifier \u003d methodMatcher.group(2);\n            String returnType \u003d methodMatcher.group(3);\n            String methodName \u003d methodMatcher.group(4);\n            String parameters \u003d methodMatcher.group(5);\n            \n            method.setAccessModifier(accessModifier !\u003d null ? accessModifier : \"\");\n            method.setStatic(staticModifier !\u003d null);\n            method.setReturnType(returnType);\n            method.setMethodName(methodName);\n            method.setParameters(parseParameters(parameters));\n            \n            // Extract method comments and JavaDoc\n            int methodStart \u003d methodMatcher.start();\n            method.setJavadoc(extractMethodJavadoc(content, methodStart));\n            method.setComments(extractMethodComments(content, methodStart));\n            \n            // Find the method body\n            String methodSignature \u003d methodMatcher.group(0);\n            methodStart \u003d content.indexOf(methodSignature);\n            if (methodStart \u003e\u003d 0) {\n                // Position after the method signature\n                int bodyStart \u003d methodStart + methodSignature.length();\n                \n                // Search for the opening brace if not part of the signature\n                if (!methodSignature.trim().endsWith(\"{\")) {\n                    bodyStart \u003d content.indexOf(\"{\", bodyStart);\n                    if (bodyStart \u003c 0) continue; // Skip if no body found\n                }\n                \n                // Find the matching closing brace\n                int bodyEnd \u003d findMatchingBrace(content, bodyStart);\n                if (bodyEnd \u003e bodyStart) {\n                    // Extract the method body including braces\n                    String body \u003d content.substring(bodyStart, bodyEnd + 1);\n                    method.setBody(body);\n                }\n            }\n            \n            methods.add(method);\n        }\n        \n        return methods;\n    }\n\n    /**\n     * Extract JavaDoc for a method.\n     */\n    private static JavadocStructure extractMethodJavadoc(String content, int methodPosition) {\n        // Search for JavaDoc before method\n        int searchStart \u003d Math.max(0, methodPosition - 500); // Look up to 500 chars before method\n        String contentBefore \u003d content.substring(searchStart, methodPosition);\n        \n        Matcher javadocMatcher \u003d JAVADOC_PATTERN.matcher(contentBefore);\n        \n        // Find the last JavaDoc before method\n        JavadocStructure javadoc \u003d null;\n        while (javadocMatcher.find()) {\n            String javadocText \u003d javadocMatcher.group(1).trim();\n            javadoc \u003d parseJavadoc(javadocText);\n        }\n        \n        return javadoc;\n    }\n\n    /**\n     * Extract non-JavaDoc comments for a method.\n     */\n    private static List\u003cString\u003e extractMethodComments(String content, int methodPosition) {\n        List\u003cString\u003e comments \u003d new ArrayList\u003c\u003e();\n        \n        // Define a window around the method declaration\n        int startPos \u003d Math.max(0, methodPosition - 200);\n        int endPos \u003d Math.min(content.length(), methodPosition + 100);\n        String windowContent \u003d content.substring(startPos, endPos);\n        \n        // Extract single-line comments\n        Matcher singleLineCommentMatcher \u003d SINGLE_LINE_COMMENT_PATTERN.matcher(windowContent);\n        while (singleLineCommentMatcher.find()) {\n            comments.add(singleLineCommentMatcher.group(1).trim());\n        }\n        \n        // Extract multi-line comments (excluding JavaDoc)\n        Matcher multiLineCommentMatcher \u003d MULTI_LINE_COMMENT_PATTERN.matcher(windowContent);\n        while (multiLineCommentMatcher.find()) {\n            String commentText \u003d multiLineCommentMatcher.group(1).trim();\n            // If it doesn\u0027t start with *, it\u0027s not a JavaDoc\n            if (!commentText.startsWith(\"*\")) {\n                comments.add(commentText);\n            }\n        }\n        \n        return comments;\n    }\n\n    /**\n     * Parse a JavaDoc comment text into a structured representation.\n     */\n    private static JavadocStructure parseJavadoc(String javadocText) {\n        JavadocStructure javadoc \u003d new JavadocStructure();\n        \n        // Clean up the JavaDoc text by removing leading asterisks and extra whitespace\n        String cleanJavadoc \u003d javadocText.replaceAll(\"^\\\\s*\\\\*\\\\s*\", \"\")\n                                          .replaceAll(\"\\\\n\\\\s*\\\\*\\\\s*\", \"\\n\")\n                                          .trim();\n        \n        // Split into main description and tags\n        int firstTagIndex \u003d cleanJavadoc.indexOf(\"@\");\n        \n        if (firstTagIndex \u003d\u003d -1) {\n            // No tags, whole text is description\n            javadoc.setDescription(cleanJavadoc);\n        } else {\n            // Extract description (text before first @tag)\n            javadoc.setDescription(cleanJavadoc.substring(0, firstTagIndex).trim());\n            \n            // Extract tags\n            List\u003cJavadocTag\u003e tags \u003d new ArrayList\u003c\u003e();\n            Matcher tagMatcher \u003d JAVADOC_TAG_PATTERN.matcher(cleanJavadoc);\n            \n            while (tagMatcher.find()) {\n                String tagName \u003d tagMatcher.group(1);\n                String tagValue \u003d tagMatcher.group(2).trim();\n                \n                JavadocTag tag \u003d new JavadocTag();\n                tag.setName(tagName);\n                tag.setValue(tagValue);\n                tags.add(tag);\n            }\n            \n            javadoc.setTags(tags);\n        }\n        \n        return javadoc;\n    }\n\n    /**\n     * Find the position of the matching closing brace for an opening brace.\n     */\n    private static int findMatchingBrace(String content, int openingBracePos) {\n        int count \u003d 1;\n        for (int i \u003d openingBracePos + 1; i \u003c content.length(); i++) {\n            char c \u003d content.charAt(i);\n            if (c \u003d\u003d \u0027{\u0027) {\n                count++;\n            } else if (c \u003d\u003d \u0027}\u0027) {\n                count--;\n                if (count \u003d\u003d 0) {\n                    return i;\n                }\n            }\n        }\n        return -1; // No matching brace found\n    }\n\n    /**\n     * Parse method parameters into a list of Parameter objects.\n     */\n    private static List\u003cParameter\u003e parseParameters(String parameterString) {\n        List\u003cParameter\u003e parameters \u003d new ArrayList\u003c\u003e();\n        \n        if (parameterString \u003d\u003d null || parameterString.trim().isEmpty()) {\n            return parameters;\n        }\n        \n        String[] paramArray \u003d parameterString.split(\",\");\n        for (String param : paramArray) {\n            param \u003d param.trim();\n            if (!param.isEmpty()) {\n                String[] parts \u003d param.split(\"\\\\s+\");\n                if (parts.length \u003e\u003d 2) {\n                    Parameter parameter \u003d new Parameter();\n                    parameter.setType(parts[0]);\n                    parameter.setName(parts[1].replace(\")\", \"\"));\n                    parameters.add(parameter);\n                }\n            }\n        }\n        \n        return parameters;\n    }\n\n    /**\n     * Structure to represent a Java class.\n     */\n    static class ClassStructure {\n        private String fileName;\n        private String packageName;\n        private String className;\n        private String classType; // class, interface, or enum\n        private List\u003cMethodStructure\u003e methods;\n        private JavadocStructure javadoc;\n        private List\u003cString\u003e comments;\n\n        public String getFileName() {\n            return fileName;\n        }\n\n        public void setFileName(String fileName) {\n            this.fileName \u003d fileName;\n        }\n\n        public String getPackageName() {\n            return packageName;\n        }\n\n        public void setPackageName(String packageName) {\n            this.packageName \u003d packageName;\n        }\n\n        public String getClassName() {\n            return className;\n        }\n\n        public void setClassName(String className) {\n            this.className \u003d className;\n        }\n\n        public String getClassType() {\n            return classType;\n        }\n\n        public void setClassType(String classType) {\n            this.classType \u003d classType;\n        }\n\n        public List\u003cMethodStructure\u003e getMethods() {\n            return methods;\n        }\n\n        public void setMethods(List\u003cMethodStructure\u003e methods) {\n            this.methods \u003d methods;\n        }\n\n        public JavadocStructure getJavadoc() {\n            return javadoc;\n        }\n\n        public void setJavadoc(JavadocStructure javadoc) {\n            this.javadoc \u003d javadoc;\n        }\n\n        public List\u003cString\u003e getComments() {\n            return comments;\n        }\n\n        public void setComments(List\u003cString\u003e comments) {\n            this.comments \u003d comments;\n        }\n    }\n\n    /**\n     * Structure to represent a Java method.\n     */\n    static class MethodStructure {\n        private String accessModifier;\n        private boolean isStatic;\n        private String returnType;\n        private String methodName;\n        private List\u003cParameter\u003e parameters;\n        private String body;\n        private JavadocStructure javadoc;\n        private List\u003cString\u003e comments;\n\n        public String getAccessModifier() {\n            return accessModifier;\n        }\n\n        public void setAccessModifier(String accessModifier) {\n            this.accessModifier \u003d accessModifier;\n        }\n\n        public boolean isStatic() {\n            return isStatic;\n        }\n\n        public void setStatic(boolean isStatic) {\n            this.isStatic \u003d isStatic;\n        }\n\n        public String getReturnType() {\n            return returnType;\n        }\n\n        public void setReturnType(String returnType) {\n            this.returnType \u003d returnType;\n        }\n\n        public String getMethodName() {\n            return methodName;\n        }\n\n        public void setMethodName(String methodName) {\n            this.methodName \u003d methodName;\n        }\n\n        public List\u003cParameter\u003e getParameters() {\n            return parameters;\n        }\n\n        public void setParameters(List\u003cParameter\u003e parameters) {\n            this.parameters \u003d parameters;\n        }\n\n        public String getBody() {\n            return body;\n        }\n\n        public void setBody(String body) {\n            this.body \u003d body;\n        }\n\n        public JavadocStructure getJavadoc() {\n            return javadoc;\n        }\n\n        public void setJavadoc(JavadocStructure javadoc) {\n            this.javadoc \u003d javadoc;\n        }\n\n        public List\u003cString\u003e getComments() {\n            return comments;\n        }\n\n        public void setComments(List\u003cString\u003e comments) {\n            this.comments \u003d comments;\n        }\n    }\n\n    /**\n     * Structure to represent a method parameter.\n     */\n    static class Parameter {\n        private String type;\n        private String name;\n\n        public String getType() {\n            return type;\n        }\n\n        public void setType(String type) {\n            this.type \u003d type;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name \u003d name;\n        }\n    }\n    \n    /**\n     * Structure to represent a JavaDoc comment.\n     */\n    static class JavadocStructure {\n        private String description;\n        private List\u003cJavadocTag\u003e tags;\n        \n        public JavadocStructure() {\n            this.tags \u003d new ArrayList\u003c\u003e();\n        }\n        \n        public String getDescription() {\n            return description;\n        }\n        \n        public void setDescription(String description) {\n            this.description \u003d description;\n        }\n        \n        public List\u003cJavadocTag\u003e getTags() {\n            return tags;\n        }\n        \n        public void setTags(List\u003cJavadocTag\u003e tags) {\n            this.tags \u003d tags;\n        }\n    }\n    \n    /**\n     * Structure to represent a JavaDoc tag.\n     */\n    static class JavadocTag {\n        private String name;\n        private String value;\n        \n        public String getName() {\n            return name;\n        }\n        \n        public void setName(String name) {\n            this.name \u003d name;\n        }\n        \n        public String getValue() {\n            return value;\n        }\n        \n        public void setValue(String value) {\n            this.value \u003d value;\n        }\n    }\n}\n"
        }
      ],
      "path": "/home/joshuasalcedo-io/parser-utility/structure.md",
      "images": [],
      "wordCount": 1980,
      "headings": [],
      "links": [],
      "readingTimeMinutes": 9
    }
  ]
}