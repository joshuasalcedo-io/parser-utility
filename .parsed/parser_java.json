{
  "javaFiles": [
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/ParserRunner.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "main",
          "parameters": [
            {
              "type": "String[]",
              "name": "args"
            }
          ],
          "body": "{\r\n        if (args.length \u003d\u003d 0) {\r\n            printWarning(\"No arguments provided. Use \u0027help\u0027 for usage information.\");\r\n            help();\r\n            return;\r\n        }\r\n\r\n        String command \u003d args[0];\r\n\r\n        switch (command) {\r\n            case \"help\":\r\n                help();\r\n                break;\r\n            case \"version\":\r\n                showVersion();\r\n                break;\r\n            case \"all\":\r\n            case \"java\":\r\n            case \"git\":\r\n            case \"pom\":\r\n            case \"html\":\r\n            case \"markdown\":\r\n                handleParserCommand(command, args);\r\n                break;\r\n            default:\r\n                // Assume it\u0027s a file path and try to parse it based on extension\r\n                parseFile(command);\r\n                break;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "extension",
          "methodName": "parseFile",
          "parameters": [],
          "body": "{\r\n        if (args.length \u003c 2) {\r\n            printError(\"Please provide a directory path.\");\r\n            return;\r\n        }\r\n\r\n        String directory \u003d args[1];\r\n        executeParser(command, directory);\r\n    }",
          "comments": [
            "Assume it\u0027s a file path and try to parse it based on extension"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "handleParserCommand",
          "parameters": [
            {
              "type": "String",
              "name": "command"
            },
            {
              "type": "String[]",
              "name": "args"
            }
          ],
          "body": "{\r\n        if (args.length \u003c 2) {\r\n            printError(\"Please provide a directory path.\");\r\n            return;\r\n        }\r\n\r\n        String directory \u003d args[1];\r\n        executeParser(command, directory);\r\n    }",
          "javadoc": {
            "description": "Handles parser commands that require a directory path\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "command The command to execute"
              },
              {
                "name": "param",
                "value": "args Command-line arguments"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "executeParser",
          "parameters": [
            {
              "type": "String",
              "name": "command"
            },
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n        String title \u003d COMMAND_TITLES.getOrDefault(command, \"PARSING \" + command.toUpperCase());\r\n        System.out.println(ConsoleFormatterFactory.createDivider(title));\r\n\r\n        printInfo(\"Parsing \" + (command.equals(\"git\") ? \"Git repository\" : command + \" files\") + \" in: \" + directory);\r\n\r\n        try {\r\n            File dir \u003d new File(directory);\r\n            if (!validateDirectory(dir)) {\r\n                return;\r\n            }\r\n\r\n            // Get the parser function from the map and execute it\r\n            Function\u003cString, Map\u003cString, Object\u003e\u003e parserFunction \u003d PARSER_FUNCTIONS.get(command);\r\n            if (parserFunction \u003d\u003d null) {\r\n                printError(\"Unknown parser command: \" + command);\r\n                return;\r\n            }\r\n\r\n            Map\u003cString, Object\u003e result \u003d parserFunction.apply(directory);\r\n            String outputPath \u003d saveResultToJsonFile(result, directory, command);\r\n            outputResult(result, outputPath);\r\n\r\n        } catch (Exception e) {\r\n            printError(\"Error executing parser: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Execute a parser based on the command name and directory\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "command The command name"
              },
              {
                "name": "param",
                "value": "directory The directory to parse"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                return;\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "validateDirectory",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            }
          ],
          "body": "{\r\n        if (!directory.exists() || !directory.isDirectory()) {\r\n            printError(\"Directory does not exist: \" + directory);\r\n            return false;\r\n        }\r\n        return true;\r\n    }",
          "javadoc": {
            "description": "Validates if a directory exists and is a directory\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to validate"
              },
              {
                "name": "return",
                "value": "true if directory is valid, false otherwise"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "parseFile",
          "parameters": [
            {
              "type": "String",
              "name": "filePath"
            }
          ],
          "body": "{\r\n        File file \u003d new File(filePath);\r\n        if (!file.exists()) {\r\n            printError(\"File does not exist: \" + filePath);\r\n            return;\r\n        }\r\n\r\n        String fileName \u003d file.getName().toLowerCase();\r\n        String parserType \u003d determineParserType(fileName);\r\n\r\n        if (parserType \u003d\u003d null) {\r\n            printError(\"Unsupported file type: \" + fileName);\r\n            return;\r\n        }\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"PARSING \" + parserType.toUpperCase() + \" FILE\"));\r\n        printWarning(parserType + \" file parsing not implemented for single files yet.\");\r\n    }",
          "javadoc": {
            "description": "Parse a single file based on its extension\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "filePath Path to the file"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            printError(\"File does not exist: \" + filePath);\r\n            return;\r\n        }",
          "javadoc": {
            "description": "Parse a single file based on its extension\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "filePath Path to the file"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "String",
          "methodName": "determineParserType",
          "parameters": [
            {
              "type": "String",
              "name": "fileName"
            }
          ],
          "body": "{\r\n        if (fileName.endsWith(\".java\")) {\r\n            return \"java\";\r\n        } else if (fileName.endsWith(\".html\") || fileName.endsWith(\".htm\")) {\r\n            return \"html\";\r\n        } else if (fileName.equals(\"pom.xml\")) {\r\n            return \"pom\";\r\n        } else if (fileName.endsWith(\".md\") || fileName.endsWith(\".markdown\")) {\r\n            return \"markdown\";\r\n        }\r\n        return null;\r\n    }",
          "javadoc": {
            "description": "Determine the parser type based on file name\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "fileName The file name"
              },
              {
                "name": "return",
                "value": "The parser type or null if unsupported"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            return \"html\";\r\n        }",
          "javadoc": {
            "description": "Determine the parser type based on file name\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "fileName The file name"
              },
              {
                "name": "return",
                "value": "The parser type or null if unsupported"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            return \"pom\";\r\n        }",
          "javadoc": {
            "description": "Determine the parser type based on file name\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "fileName The file name"
              },
              {
                "name": "return",
                "value": "The parser type or null if unsupported"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            return \"markdown\";\r\n        }",
          "javadoc": {
            "description": "Determine the parser type based on file name\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "fileName The file name"
              },
              {
                "name": "return",
                "value": "The parser type or null if unsupported"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parser",
          "methodName": "used",
          "parameters": [],
          "body": "{\r\n        Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n        String json \u003d gson.toJson(result);\r\n\r\n        // Create output filename\r\n        String filename \u003d String.format(\"parser_%s.json\", parserType);\r\n\r\n        // Create .parsed directory where the command is executed\r\n        File parsedDir \u003d createOutputDirectory();\r\n\r\n        // Create the output file in the .parsed directory\r\n        return writeJsonToFile(json, parsedDir, filename);\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "String",
          "methodName": "saveResultToJsonFile",
          "parameters": [
            {
              "type": "Object\u003e",
              "name": "result"
            },
            {
              "type": "String",
              "name": "directory"
            },
            {
              "type": "String",
              "name": "parserType"
            }
          ],
          "body": "{\r\n        Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n        String json \u003d gson.toJson(result);\r\n\r\n        // Create output filename\r\n        String filename \u003d String.format(\"parser_%s.json\", parserType);\r\n\r\n        // Create .parsed directory where the command is executed\r\n        File parsedDir \u003d createOutputDirectory();\r\n\r\n        // Create the output file in the .parsed directory\r\n        return writeJsonToFile(json, parsedDir, filename);\r\n    }",
          "javadoc": {
            "description": "Save parsing results to a JSON file in the .parsed directory\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "result The parsing result map"
              },
              {
                "name": "param",
                "value": "directory The directory that was parsed"
              },
              {
                "name": "param",
                "value": "parserType The type of parser used (all, java, git, etc.)"
              },
              {
                "name": "return",
                "value": "The path to the saved JSON file"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "GsonBuilder",
          "parameters": [],
          "body": "{\r\n        File currentDirectory \u003d new File(\".\");\r\n        File parsedDir \u003d new File(currentDirectory, \".parsed\");\r\n\r\n        // Create the directory if it doesn\u0027t exist\r\n        if (!parsedDir.exists()) {\r\n            if (!parsedDir.mkdir()) {\r\n                printWarning(\"Failed to create .parsed directory. Using current directory instead.\");\r\n                parsedDir \u003d currentDirectory;\r\n            }\r\n        }\r\n\r\n        return parsedDir;\r\n    }",
          "javadoc": {
            "description": "Save parsing results to a JSON file in the .parsed directory\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "result The parsing result map"
              },
              {
                "name": "param",
                "value": "directory The directory that was parsed"
              },
              {
                "name": "param",
                "value": "parserType The type of parser used (all, java, git, etc.)"
              },
              {
                "name": "return",
                "value": "The path to the saved JSON file"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "writeJsonToFile",
          "parameters": [],
          "body": "{\r\n        File currentDirectory \u003d new File(\".\");\r\n        File parsedDir \u003d new File(currentDirectory, \".parsed\");\r\n\r\n        // Create the directory if it doesn\u0027t exist\r\n        if (!parsedDir.exists()) {\r\n            if (!parsedDir.mkdir()) {\r\n                printWarning(\"Failed to create .parsed directory. Using current directory instead.\");\r\n                parsedDir \u003d currentDirectory;\r\n            }\r\n        }\r\n\r\n        return parsedDir;\r\n    }",
          "comments": [
            "Create .parsed directory where the command is executed",
            "Create the output file in the .parsed directory"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "File",
          "methodName": "createOutputDirectory",
          "parameters": [],
          "body": "{\r\n        File currentDirectory \u003d new File(\".\");\r\n        File parsedDir \u003d new File(currentDirectory, \".parsed\");\r\n\r\n        // Create the directory if it doesn\u0027t exist\r\n        if (!parsedDir.exists()) {\r\n            if (!parsedDir.mkdir()) {\r\n                printWarning(\"Failed to create .parsed directory. Using current directory instead.\");\r\n                parsedDir \u003d currentDirectory;\r\n            }\r\n        }\r\n\r\n        return parsedDir;\r\n    }",
          "javadoc": {
            "description": "Creates the output directory for storing results\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The created directory or current directory as fallback"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            if (!parsedDir.mkdir()) {\r\n                printWarning(\"Failed to create .parsed directory. Using current directory instead.\");\r\n                parsedDir \u003d currentDirectory;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Creates the output directory for storing results\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The created directory or current directory as fallback"
              }
            ]
          },
          "comments": [
            "Creat"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            if (!parsedDir.mkdir()) {\r\n                printWarning(\"Failed to create .parsed directory. Using current directory instead.\");\r\n                parsedDir \u003d currentDirectory;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Creates the output directory for storing results\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The created directory or current directory as fallback"
              }
            ]
          },
          "comments": [
            "Create the directory if it doesn\u0027t exist"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "exist",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            if (!parsedDir.mkdir()) {\r\n                printWarning(\"Failed to create .parsed directory. Using current directory instead.\");\r\n                parsedDir \u003d currentDirectory;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Creates the output directory for storing results\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The created directory or current directory as fallback"
              }
            ]
          },
          "comments": [
            "Create the directory if it doesn\u0027t exist"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "String",
          "methodName": "writeJsonToFile",
          "parameters": [
            {
              "type": "String",
              "name": "json"
            },
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "String",
              "name": "filename"
            }
          ],
          "body": "{\r\n        File outputFile \u003d new File(directory, filename);\r\n\r\n        try (FileWriter writer \u003d new FileWriter(outputFile)) {\r\n            writer.write(json);\r\n            return outputFile.getAbsolutePath();\r\n        } catch (IOException e) {\r\n            printError(\"Error saving JSON to file: \" + e.getMessage());\r\n\r\n            // Fallback to saving in the current directory\r\n            try {\r\n                outputFile \u003d new File(filename);\r\n                try (FileWriter writer \u003d new FileWriter(outputFile)) {\r\n                    writer.write(json);\r\n                    return outputFile.getAbsolutePath();\r\n                }\r\n            } catch (IOException ex) {\r\n                printError(\"Failed to save JSON file in fallback location: \" + ex.getMessage());\r\n                return null;\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Write JSON content to a file\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "json The JSON content to write"
              },
              {
                "name": "param",
                "value": "directory The directory to write to"
              },
              {
                "name": "param",
                "value": "filename The filename to use"
              },
              {
                "name": "return",
                "value": "The path to the saved file or null if failed"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            writer.write(json);\r\n            return outputFile.getAbsolutePath();\r\n        }",
          "javadoc": {
            "description": "Write JSON content to a file\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "json The JSON content to write"
              },
              {
                "name": "param",
                "value": "directory The directory to write to"
              },
              {
                "name": "param",
                "value": "filename The filename to use"
              },
              {
                "name": "return",
                "value": "The path to the saved file or null if failed"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "FileWriter",
          "parameters": [],
          "body": "{\r\n            writer.write(json);\r\n            return outputFile.getAbsolutePath();\r\n        }",
          "javadoc": {
            "description": "Write JSON content to a file\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "json The JSON content to write"
              },
              {
                "name": "param",
                "value": "directory The directory to write to"
              },
              {
                "name": "param",
                "value": "filename The filename to use"
              },
              {
                "name": "return",
                "value": "The path to the saved file or null if failed"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    writer.write(json);\r\n                    return outputFile.getAbsolutePath();\r\n                }",
          "comments": [
            "Fallback to saving in the current directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "FileWriter",
          "parameters": [],
          "body": "{\r\n            writer.write(json);\r\n            return outputFile.getAbsolutePath();\r\n        }",
          "comments": [
            "Fallback to saving in the current directory"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "outputResult",
          "parameters": [
            {
              "type": "Object\u003e",
              "name": "result"
            },
            {
              "type": "String",
              "name": "outputPath"
            }
          ],
          "body": "{\r\n        Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n        String json \u003d gson.toJson(result);\r\n\r\n        // Print the results to console\r\n        printSuccess(\"Results:\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(json, MessageType.DOC_CODE));\r\n\r\n        // Print information about saved file\r\n        if (outputPath !\u003d null) {\r\n            System.out.println(ConsoleFormatterFactory.createDivider(\"OUTPUT FILE\"));\r\n            printSuccess(\"Results saved to: \" + outputPath);\r\n        }\r\n    }",
          "javadoc": {
            "description": "Output the parsing results to console and show file save location\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "result The parsing results"
              },
              {
                "name": "param",
                "value": "outputPath The path where results were saved"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "GsonBuilder",
          "parameters": [],
          "body": "{\r\n        File currentDirectory \u003d new File(\".\");\r\n        File parsedDir \u003d new File(currentDirectory, \".parsed\");\r\n\r\n        // Create the directory if it doesn\u0027t exist\r\n        if (!parsedDir.exists()) {\r\n            if (!parsedDir.mkdir()) {\r\n                printWarning(\"Failed to create .parsed directory. Using current directory instead.\");\r\n                parsedDir \u003d currentDirectory;\r\n            }\r\n        }\r\n\r\n        return parsedDir;\r\n    }",
          "javadoc": {
            "description": "Output the parsing results to console and show file save location\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "result The parsing results"
              },
              {
                "name": "param",
                "value": "outputPath The path where results were saved"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "console",
          "methodName": "printSuccess",
          "parameters": [],
          "body": "{\r\n            System.out.println(ConsoleFormatterFactory.createDivider(\"OUTPUT FILE\"));\r\n            printSuccess(\"Results saved to: \" + outputPath);\r\n        }",
          "javadoc": {
            "description": "Output the parsing results to console and show file save location\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "result The parsing results"
              },
              {
                "name": "param",
                "value": "outputPath The path where results were saved"
              }
            ]
          },
          "comments": [
            "Print the results to console"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "file",
          "methodName": "if",
          "parameters": [
            {
              "type": "outputPath",
              "name": "!\u003d"
            }
          ],
          "body": "{\r\n            System.out.println(ConsoleFormatterFactory.createDivider(\"OUTPUT FILE\"));\r\n            printSuccess(\"Results saved to: \" + outputPath);\r\n        }",
          "comments": [
            "Print information about saved file"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "showVersion",
          "parameters": [],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createBox(\"Java Structure Parser v1.0\", MessageType.UI_HEADER));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Copyright © 2024 Joshua Salcedo\", MessageType.UI_SUBHEADER));\r\n    }",
          "javadoc": {
            "description": "Print version information",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "help",
          "parameters": [],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createBox(\"JAVA STRUCTURE PARSER\", MessageType.UI_HEADER));\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"USAGE\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar [command] [arguments]\", MessageType.DOC_CODE));\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"COMMANDS\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"help\", MessageType.UI_LABEL) + \"        - Show this help message\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"version\", MessageType.UI_LABEL) + \"     - Show version information\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"all\", MessageType.UI_LABEL) + \" [dir]   - Parse all supported files in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java\", MessageType.UI_LABEL) + \" [dir]  - Parse Java files in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"git\", MessageType.UI_LABEL) + \" [dir]   - Parse Git repository in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"pom\", MessageType.UI_LABEL) + \" [dir]   - Parse POM files in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"html\", MessageType.UI_LABEL) + \" [dir]  - Parse HTML files in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"markdown\", MessageType.UI_LABEL) + \" [dir] - Parse Markdown files in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"[file]\", MessageType.UI_LABEL) + \"      - Parse the specified file based on its extension\");\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"EXAMPLES\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar help\", MessageType.DOC_CODE));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar all /path/to/project\", MessageType.DOC_CODE));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar java /path/to/project\", MessageType.DOC_CODE));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar pom.xml\", MessageType.DOC_CODE));\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"NOTES\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"The parser outputs results as JSON both in the console and saves to a file in the parsed directory.\", MessageType.DOC_NOTE));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Output files are named \u0027parser_[type].json\u0027\", MessageType.DOC_NOTE));\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"LICENSE\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Copyright © 2024 Joshua Salcedo\", MessageType.SUCCESS));\r\n    }",
          "javadoc": {
            "description": "Print help documentation",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "printInfo",
          "parameters": [
            {
              "type": "String",
              "name": "message"
            }
          ],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createMessage(message, MessageType.INFO));\r\n    }",
          "comments": [
            "Utility methods for consistent message formatting"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "printError",
          "parameters": [
            {
              "type": "String",
              "name": "message"
            }
          ],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createMessage(message, MessageType.ERROR));\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "printWarning",
          "parameters": [
            {
              "type": "String",
              "name": "message"
            }
          ],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createMessage(message, MessageType.WARNING));\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "printSuccess",
          "parameters": [
            {
              "type": "String",
              "name": "message"
            }
          ],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createMessage(message, MessageType.SUCCESS));\r\n    }",
          "comments": []
        }
      ],
      "className": "ParserRunner",
      "packageName": "io.joshuasalcedo"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/ClipboardService.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "5",
          "methodName": "minutes",
          "parameters": [],
          "body": "{\r\n//        // Get the system clipboard\r\n//        clipboard \u003d Toolkit.getDefaultToolkit().getSystemClipboard();\r\n//\r\n//        // Initialize HTTP client (using Java 11+ HttpClient)\r\n//        httpClient \u003d HttpClient.newBuilder()\r\n//                .version(HttpClient.Version.HTTP_2)\r\n//                .connectTimeout(Duration.ofSeconds(10))\r\n//                .build();\r\n//\r\n//        // Check if primary server is available, otherwise use fallback\r\n//        checkServerAvailability();\r\n//\r\n//        // Add shutdown hook to clean up threads\r\n//        Runtime.getRuntime().addShutdownHook(new Thread(() -\u003e {\r\n//            stopMonitoring();\r\n//            clipboardExecutor.shutdownNow();\r\n//            scheduledExecutor.shutdownNow();\r\n//        }));\r\n//\r\n//        System.out.println(\"[ClipboardService] Initialized\");\r\n//    }",
          "comments": [
            "public class ClipboardService {",
            "private final Clipboard clipboard;",
            "private String lastClipboardContent \u003d \"\";",
            "private static final int SAVE_INTERVAL_MS \u003d 300000; // Save every 5 minutes (300,000ms)",
            "private final HttpClient httpClient;",
            "private static final Strin"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AtomicBoolean",
          "parameters": [],
          "body": "{\r\n//        // Get the system clipboard\r\n//        clipboard \u003d Toolkit.getDefaultToolkit().getSystemClipboard();\r\n//\r\n//        // Initialize HTTP client (using Java 11+ HttpClient)\r\n//        httpClient \u003d HttpClient.newBuilder()\r\n//                .version(HttpClient.Version.HTTP_2)\r\n//                .connectTimeout(Duration.ofSeconds(10))\r\n//                .build();\r\n//\r\n//        // Check if primary server is available, otherwise use fallback\r\n//        checkServerAvailability();\r\n//\r\n//        // Add shutdown hook to clean up threads\r\n//        Runtime.getRuntime().addShutdownHook(new Thread(() -\u003e {\r\n//            stopMonitoring();\r\n//            clipboardExecutor.shutdownNow();\r\n//            scheduledExecutor.shutdownNow();\r\n//        }));\r\n//\r\n//        System.out.println(\"[ClipboardService] Initialized\");\r\n//    }",
          "comments": [
            "private ClipboardListenerTask clipboardListenerTask;",
            "private ScheduledFuture\u003c?\u003e serverSaveTask;",
            "private final AtomicBoolean isRunning \u003d new AtomicBoolean(false);",
            "",
            "public ClipboardService() {",
            "// Get the system clipb"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "public",
          "methodName": "ClipboardService",
          "parameters": [],
          "body": "{\r\n//        // Get the system clipboard\r\n//        clipboard \u003d Toolkit.getDefaultToolkit().getSystemClipboard();\r\n//\r\n//        // Initialize HTTP client (using Java 11+ HttpClient)\r\n//        httpClient \u003d HttpClient.newBuilder()\r\n//                .version(HttpClient.Version.HTTP_2)\r\n//                .connectTimeout(Duration.ofSeconds(10))\r\n//                .build();\r\n//\r\n//        // Check if primary server is available, otherwise use fallback\r\n//        checkServerAvailability();\r\n//\r\n//        // Add shutdown hook to clean up threads\r\n//        Runtime.getRuntime().addShutdownHook(new Thread(() -\u003e {\r\n//            stopMonitoring();\r\n//            clipboardExecutor.shutdownNow();\r\n//            scheduledExecutor.shutdownNow();\r\n//        }));\r\n//\r\n//        System.out.println(\"[ClipboardService] Initialized\");\r\n//    }",
          "comments": [
            "private ClipboardListenerTask clipboardListenerTask;",
            "private ScheduledFuture\u003c?\u003e serverSaveTask;",
            "private final AtomicBoolean isRunning \u003d new AtomicBoolean(false);",
            "",
            "public ClipboardService() {",
            "// Get the system clipboard",
            "clipboard \u003d Toolki"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "HTTP",
          "methodName": "client",
          "parameters": [
            {
              "type": "using",
              "name": "Java"
            }
          ],
          "body": "{\r\n//            stopMonitoring();\r\n//            clipboardExecutor.shutdownNow();\r\n//            scheduledExecutor.shutdownNow();\r\n//        }",
          "comments": [
            "",
            "public ClipboardService() {",
            "// Get the system clipboard",
            "clipboard \u003d Toolkit.getDefaultToolkit().getSystemClipboard();",
            "",
            "// Initialize HTTP client (using Java 11+ HttpClient)",
            "httpClient \u003d HttpClient.newBuilder()",
            ""
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "Thread",
          "parameters": [],
          "body": "{\r\n//            stopMonitoring();\r\n//            clipboardExecutor.shutdownNow();\r\n//            scheduledExecutor.shutdownNow();\r\n//        }",
          "comments": [
            "checkServerAvailability();",
            "",
            "// Add shutdown hook to clean up threads",
            "Runtime.getRuntime().addShutdownHook(new Thread(() -\u003e {",
            "stopMonitoring();",
            "clipboardExecutor.shutdownNow();"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "start",
          "parameters": [],
          "body": "{\r\n//        if (isRunning.getAndSet(true)) {\r\n//            return; // Already running\r\n//        }\r\n//\r\n//        System.out.println(\"[ClipboardService] Starting clipboard monitoring...\");\r\n//\r\n//        // Initialize the clipboard listener task\r\n//        clipboardListenerTask \u003d new ClipboardListenerTask();\r\n//        clipboardExecutor.submit(clipboardListenerTask);\r\n//\r\n//        // Schedule the server save task\r\n//        serverSaveTask \u003d scheduledExecutor.scheduleAtFixedRate(\r\n//                this::saveClipboardHistoryToServer,\r\n//                SAVE_INTERVAL_MS,\r\n//                SAVE_INTERVAL_MS,\r\n//                TimeUnit.MILLISECONDS\r\n//        );\r\n//\r\n//        System.out.println(\"[ClipboardService] Clipboard monitoring started\");\r\n//    }",
          "comments": [
            "clipboardExecutor.shutdownNow();",
            "scheduledExecutor.shutdownNow();",
            "}));",
            "",
            "System.out.println(\"[ClipboardService] Initialized\");",
            "}",
            "",
            "public void start() {",
            "if (isRunning.getAndSet(true)) {",
            "return; // Already"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ClipboardListenerTask",
          "parameters": [],
          "body": "{\r\n//        if (!isRunning.getAndSet(false)) {\r\n//            return; // Already stopped\r\n//        }\r\n//\r\n//        System.out.println(\"[ClipboardService] Stopping clipboard monitoring...\");\r\n//\r\n//        // Cancel the clipboard listener task\r\n//        if (clipboardListenerTask !\u003d null) {\r\n//            clipboardListenerTask.stop();\r\n//        }\r\n//\r\n//        // Cancel the server save task\r\n//        if (serverSaveTask !\u003d null) {\r\n//            serverSaveTask.cancel(false);\r\n//        }\r\n//\r\n//        System.out.println(\"[ClipboardService] Clipboard monitoring stopped\");\r\n//    }",
          "comments": [
            "}",
            "",
            "System.out.println(\"[ClipboardService] Starting clipboard monitoring...\");",
            "",
            "// Initialize the clipboard listener task",
            "clipboardListenerTask \u003d new ClipboardListenerTask();",
            "clipboardExecutor.submit(clipboardListenerTask);",
            "",
            ""
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "stop",
          "parameters": [],
          "body": "{\r\n//        if (!isRunning.getAndSet(false)) {\r\n//            return; // Already stopped\r\n//        }\r\n//\r\n//        System.out.println(\"[ClipboardService] Stopping clipboard monitoring...\");\r\n//\r\n//        // Cancel the clipboard listener task\r\n//        if (clipboardListenerTask !\u003d null) {\r\n//            clipboardListenerTask.stop();\r\n//        }\r\n//\r\n//        // Cancel the server save task\r\n//        if (serverSaveTask !\u003d null) {\r\n//            serverSaveTask.cancel(false);\r\n//        }\r\n//\r\n//        System.out.println(\"[ClipboardService] Clipboard monitoring stopped\");\r\n//    }",
          "comments": [
            "SAVE_INTERVAL_MS,",
            "TimeUnit.MILLISECONDS",
            ");",
            "",
            "System.out.println(\"[ClipboardService] Clipboard monitoring started\");",
            "}",
            "",
            "public void stop() {",
            "if (!isRunning.getAndSet(false)) {",
            "return; // Already"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "saveClipboardHistoryToServer",
          "parameters": [],
          "body": "{\r\n//        // This would save clipboard history to the server\r\n//        // Simplified version just logs the action\r\n//        System.out.println(\"[ClipboardService] Saving clipboard history to server: \" + currentApiUrl);\r\n//    }",
          "comments": [
            "serverSaveTask.cancel(false);",
            "}",
            "",
            "System.out.println(\"[ClipboardService] Clipboard monitoring stopped\");",
            "}",
            "",
            "private void saveClipboardHistoryToServer() {",
            "// This would save clipboard history to the"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "checkServerAvailability",
          "parameters": [],
          "body": "{\r\n//        CompletableFuture.supplyAsync(() -\u003e isServerAvailable(PRIMARY_API_URL))\r\n//                .thenAccept(available -\u003e {\r\n//                    if (available) {\r\n//                        currentApiUrl \u003d PRIMARY_API_URL;\r\n//                        System.out.println(\"[ClipboardService] Using primary server: \" + PRIMARY_API_URL);\r\n//                    } else {\r\n//                        currentApiUrl \u003d FALLBACK_API_URL;\r\n//                        System.out.println(\"[ClipboardService] Primary server unavailable. Using fallback server: \" + FALLBACK_API_URL);\r\n//\r\n//                        // Schedule a task to periodically check if the primary server becomes available\r\n//                        scheduledExecutor.scheduleAtFixedRate(() -\u003e {\r\n//                            if (isServerAvailable(PRIMARY_API_URL) \u0026\u0026\r\n//                                    !currentApiUrl.equals(PRIMARY_API_URL)) {\r\n//                                currentApiUrl \u003d PRIMARY_API_URL;\r\n//                                System.out.println(\"[ClipboardService] Reconnected to primary server: \" + PRIMARY_API_URL);\r\n//                            }\r\n//                        }, 60, 60, TimeUnit.SECONDS); // Check every minute\r\n//                    }\r\n//                });\r\n//    }",
          "comments": [
            "// Simplified version just logs the action",
            "System.out.println(\"[ClipboardService] Saving clipboard history to server: \" + currentApiUrl);",
            "}",
            "",
            "private void checkServerAvailability() {",
            "CompletableFuture.supplyAsync(() -\u003e isServerAvai"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "boolean",
          "methodName": "isServerAvailable",
          "parameters": [
            {
              "type": "String",
              "name": "url"
            }
          ],
          "body": "{\r\n//        try {\r\n//            HttpRequest request \u003d HttpRequest.newBuilder()\r\n//                    .uri(URI.create(url))\r\n//                    .timeout(Duration.ofSeconds(SERVER_CHECK_TIMEOUT_SECONDS))\r\n//                    .method(\"HEAD\", HttpRequest.BodyPublishers.noBody())\r\n//                    .build();\r\n//\r\n//            HttpResponse\u003cVoid\u003e response \u003d httpClient.send(request,\r\n//                    HttpResponse.BodyHandlers.discarding());\r\n//\r\n//            return response.statusCode() \u003e\u003d 200 \u0026\u0026 response.statusCode() \u003c 300;\r\n//        } catch (Exception e) {\r\n//            return false;\r\n//        }\r\n//    }",
          "comments": [
            "}",
            "}, 60, 60, TimeUnit.SECONDS); // Check every minute",
            "}",
            "});",
            "}",
            "",
            "private boolean isServerAvailable(String url) {",
            "try {",
            "HttpRequest request"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "CompletableFuture\u003cString\u003e",
          "methodName": "postToServer",
          "parameters": [
            {
              "type": "String",
              "name": "url"
            },
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n//        HttpRequest request \u003d HttpRequest.newBuilder()\r\n//                .uri(URI.create(url))\r\n//                .header(\"Content-Type\", \"application/json\")\r\n//                .POST(HttpRequest.BodyPublishers.ofString(content))\r\n//                .build();\r\n//\r\n//        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\r\n//                .thenApply(HttpResponse::body)\r\n//                .exceptionally(ex -\u003e \"Error: \" + ex.getMessage());\r\n//    }",
          "comments": [
            "",
            "return response.statusCode() \u003e\u003d 200 \u0026\u0026 response.statusCode() \u003c 300;",
            "} catch (Exception e) {",
            "return false;",
            "}",
            "}",
            "",
            "private CompletableFuture\u003cString\u003e postToServer(String url, String content) {",
            "HttpRequest"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AtomicBoolean",
          "parameters": [],
          "body": "{\r\n//            running.set(false);\r\n//        }",
          "comments": [
            ".exceptionally(ex -\u003e \"Error: \" + ex.getMessage());",
            "}",
            "",
            "private class ClipboardListenerTask implements Runnable {",
            "private final AtomicBoolean running \u003d new AtomicBoolean(true);",
            "",
            "public void stop() {",
            "running.set(false);",
            ""
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "stop",
          "parameters": [],
          "body": "{\r\n//        if (!isRunning.getAndSet(false)) {\r\n//            return; // Already stopped\r\n//        }\r\n//\r\n//        System.out.println(\"[ClipboardService] Stopping clipboard monitoring...\");\r\n//\r\n//        // Cancel the clipboard listener task\r\n//        if (clipboardListenerTask !\u003d null) {\r\n//            clipboardListenerTask.stop();\r\n//        }\r\n//\r\n//        // Cancel the server save task\r\n//        if (serverSaveTask !\u003d null) {\r\n//            serverSaveTask.cancel(false);\r\n//        }\r\n//\r\n//        System.out.println(\"[ClipboardService] Clipboard monitoring stopped\");\r\n//    }",
          "comments": [
            "}",
            "",
            "private class ClipboardListenerTask implements Runnable {",
            "private final AtomicBoolean running \u003d new AtomicBoolean(true);",
            "",
            "public void stop() {",
            "running.set(false);",
            "}",
            "",
            "@Override",
            ""
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "run",
          "parameters": [],
          "body": "{\r\n//            try {\r\n//                // Take initial ownership of the clipboard\r\n//                Transferable contents \u003d clipboard.getContents(null);\r\n//                ClipboardOwner owner \u003d new ClipboardOwner() {\r\n//                    @Override\r\n//                    public void lostOwnership(Clipboard clipboard, Transferable contents) {\r\n//                        if (!running.get()) return;\r\n//\r\n//                        try {\r\n//                            // Small delay to allow clipboard content to change\r\n//                            Thread.sleep(200);\r\n//\r\n//                            // Get new clipboard contents\r\n//                            Transferable newContents \u003d clipboard.getContents(null);\r\n//\r\n//                            // Process the content if it\u0027s text\r\n//                            if (newContents !\u003d null \u0026\u0026 newContents.isDataFlavorSupported(DataFlavor.stringFlavor)) {\r\n//                                String data \u003d (String) newContents.getTransferData(DataFlavor.stringFlavor);\r\n//\r\n//                                // Only process if content has changed\r\n//                                if (!data.equals(lastClipboardContent) \u0026\u0026 !data.isEmpty()) {\r\n//                                    lastClipboardContent \u003d data;\r\n//                                    System.out.println(\"[ClipboardService] Clipboard changed: \" + data);\r\n//\r\n//                                    // Send clipboard content to server\r\n//                                    postToServer(currentApiUrl, data)\r\n//                                            .thenAccept(response -\u003e System.out.println(\"[ClipboardService] Server response: \" + response))\r\n//                                            .exceptionally(ex -\u003e {\r\n//                                                System.err.println(\"[ClipboardService] Error sending clipboard content to server: \" + ex.getMessage());\r\n//                                                return null;\r\n//                                            });\r\n//                                }\r\n//                            }\r\n//\r\n//                            // Take ownership again to continue monitoring\r\n//                            if (running.get()) {\r\n//                                clipboard.setContents(newContents, this);\r\n//                            }\r\n//                        } catch (Exception e) {\r\n//                            System.err.println(\"[ClipboardService] Error processing clipboard content: \" + e.getMessage());\r\n//\r\n//                            // Try to recover ownership\r\n//                            if (running.get()) {\r\n//                                try {\r\n//                                    clipboard.setContents(clipboard.getContents(null), this);\r\n//                                } catch (Exception ex) {\r\n//                                    System.err.println(\"[ClipboardService] Failed to recover clipboard ownership: \" + ex.getMessage());\r\n//                                }\r\n//                            }\r\n//                        }\r\n//                    }\r\n//                };\r\n//\r\n//                // Store initial clipboard content if it\u0027s text\r\n//                if (contents !\u003d null \u0026\u0026 contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {\r\n//                    lastClipboardContent \u003d (String) contents.getTransferData(DataFlavor.stringFlavor);\r\n//                }\r\n//\r\n//                // Take ownership\r\n//                clipboard.setContents(contents, owner);\r\n//\r\n//                // Keep the thread alive until stopped\r\n//                while (running.get()) {\r\n//                    // Periodically check if we still have clipboard ownership\r\n//                    try {\r\n//                        Thread.sleep(1000);\r\n//                        // Sometimes ownership can be lost without notification, so we check periodically\r\n//                        if (running.get()) {\r\n//                            Transferable current \u003d clipboard.getContents(null);\r\n//                            if (current !\u003d null \u0026\u0026 current.isDataFlavorSupported(DataFlavor.stringFlavor)) {\r\n//                                String currentText \u003d (String) current.getTransferData(DataFlavor.stringFlavor);\r\n//                                // If content changed but we didn\u0027t get a lostOwnership notification\r\n//                                if (!currentText.equals(lastClipboardContent)) {\r\n//                                    lastClipboardContent \u003d currentText;\r\n//                                    System.out.println(\"[ClipboardService] Clipboard changed (poll): \" + currentText);\r\n//\r\n//                                    // Retake ownership\r\n//                                    clipboard.setContents(current, owner);\r\n//\r\n//                                    // Send to server\r\n//                                    postToServer(currentApiUrl, currentText)\r\n//                                            .thenAccept(response -\u003e System.out.println(\"[ClipboardService] Server response: \" + response))\r\n//                                            .exceptionally(ex -\u003e {\r\n//                                                System.err.println(\"[ClipboardService] Error sending clipboard content to server: \" + ex.getMessage());\r\n//                                                return null;\r\n//                                            });\r\n//                                }\r\n//                            }\r\n//                        }\r\n//                    } catch (Exception e) {\r\n//                        if (running.get()) {\r\n//                            System.err.println(\"[ClipboardService] Error polling clipboard: \" + e.getMessage());\r\n//                        }\r\n//                    }\r\n//                }\r\n//            } catch (Exception e) {\r\n//                System.err.println(\"[ClipboardService] Clipboard listener error: \" + e.getMessage());\r\n//            }\r\n//        }",
          "comments": [
            "private final AtomicBoolean running \u003d new AtomicBoolean(true);",
            "",
            "public void stop() {",
            "running.set(false);",
            "}",
            "",
            "@Override",
            "public void run() {",
            "try {",
            "// Take initial ownership of the clipboa"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ClipboardOwner",
          "parameters": [],
          "body": "{\r\n//                    @Override\r\n//                    public void lostOwnership(Clipboard clipboard, Transferable contents) {\r\n//                        if (!running.get()) return;\r\n//\r\n//                        try {\r\n//                            // Small delay to allow clipboard content to change\r\n//                            Thread.sleep(200);\r\n//\r\n//                            // Get new clipboard contents\r\n//                            Transferable newContents \u003d clipboard.getContents(null);\r\n//\r\n//                            // Process the content if it\u0027s text\r\n//                            if (newContents !\u003d null \u0026\u0026 newContents.isDataFlavorSupported(DataFlavor.stringFlavor)) {\r\n//                                String data \u003d (String) newContents.getTransferData(DataFlavor.stringFlavor);\r\n//\r\n//                                // Only process if content has changed\r\n//                                if (!data.equals(lastClipboardContent) \u0026\u0026 !data.isEmpty()) {\r\n//                                    lastClipboardContent \u003d data;\r\n//                                    System.out.println(\"[ClipboardService] Clipboard changed: \" + data);\r\n//\r\n//                                    // Send clipboard content to server\r\n//                                    postToServer(currentApiUrl, data)\r\n//                                            .thenAccept(response -\u003e System.out.println(\"[ClipboardService] Server response: \" + response))\r\n//                                            .exceptionally(ex -\u003e {\r\n//                                                System.err.println(\"[ClipboardService] Error sending clipboard content to server: \" + ex.getMessage());\r\n//                                                return null;\r\n//                                            });\r\n//                                }\r\n//                            }\r\n//\r\n//                            // Take ownership again to continue monitoring\r\n//                            if (running.get()) {\r\n//                                clipboard.setContents(newContents, this);\r\n//                            }\r\n//                        } catch (Exception e) {\r\n//                            System.err.println(\"[ClipboardService] Error processing clipboard content: \" + e.getMessage());\r\n//\r\n//                            // Try to recover ownership\r\n//                            if (running.get()) {\r\n//                                try {\r\n//                                    clipboard.setContents(clipboard.getContents(null), this);\r\n//                                } catch (Exception ex) {\r\n//                                    System.err.println(\"[ClipboardService] Failed to recover clipboard ownership: \" + ex.getMessage());\r\n//                                }\r\n//                            }\r\n//                        }\r\n//                    }\r\n//                }",
          "comments": [
            "try {",
            "// Take initial ownership of the clipboard",
            "Transferable contents \u003d clipboard.getContents(null);",
            "ClipboardOwner owner \u003d new ClipboardOwner() {",
            "@Override",
            "public void lostOwne"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "lostOwnership",
          "parameters": [
            {
              "type": "Clipboard",
              "name": "clipboard"
            },
            {
              "type": "Transferable",
              "name": "contents"
            }
          ],
          "body": "{\r\n//                        if (!running.get()) return;\r\n//\r\n//                        try {\r\n//                            // Small delay to allow clipboard content to change\r\n//                            Thread.sleep(200);\r\n//\r\n//                            // Get new clipboard contents\r\n//                            Transferable newContents \u003d clipboard.getContents(null);\r\n//\r\n//                            // Process the content if it\u0027s text\r\n//                            if (newContents !\u003d null \u0026\u0026 newContents.isDataFlavorSupported(DataFlavor.stringFlavor)) {\r\n//                                String data \u003d (String) newContents.getTransferData(DataFlavor.stringFlavor);\r\n//\r\n//                                // Only process if content has changed\r\n//                                if (!data.equals(lastClipboardContent) \u0026\u0026 !data.isEmpty()) {\r\n//                                    lastClipboardContent \u003d data;\r\n//                                    System.out.println(\"[ClipboardService] Clipboard changed: \" + data);\r\n//\r\n//                                    // Send clipboard content to server\r\n//                                    postToServer(currentApiUrl, data)\r\n//                                            .thenAccept(response -\u003e System.out.println(\"[ClipboardService] Server response: \" + response))\r\n//                                            .exceptionally(ex -\u003e {\r\n//                                                System.err.println(\"[ClipboardService] Error sending clipboard content to server: \" + ex.getMessage());\r\n//                                                return null;\r\n//                                            });\r\n//                                }\r\n//                            }\r\n//\r\n//                            // Take ownership again to continue monitoring\r\n//                            if (running.get()) {\r\n//                                clipboard.setContents(newContents, this);\r\n//                            }\r\n//                        } catch (Exception e) {\r\n//                            System.err.println(\"[ClipboardService] Error processing clipboard content: \" + e.getMessage());\r\n//\r\n//                            // Try to recover ownership\r\n//                            if (running.get()) {\r\n//                                try {\r\n//                                    clipboard.setContents(clipboard.getContents(null), this);\r\n//                                } catch (Exception ex) {\r\n//                                    System.err.println(\"[ClipboardService] Failed to recover clipboard ownership: \" + ex.getMessage());\r\n//                                }\r\n//                            }\r\n//                        }\r\n//                    }",
          "comments": [
            "Transferable contents \u003d clipboard.getContents(null);",
            "ClipboardOwner owner \u003d new ClipboardOwner() {",
            "@Override",
            "public void lostOwnership(Clipboard clipboard, Transferable contents) {",
            "i"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Clipboard",
          "methodName": "changed",
          "parameters": [],
          "body": "{\r\n//                                                System.err.println(\"[ClipboardService] Error sending clipboard content to server: \" + ex.getMessage());\r\n//                                                return null;\r\n//                                            }",
          "comments": [
            "lastClipboardContent \u003d currentText;",
            "System.out.println(\"[ClipboardService] Clipboard changed (poll): \" + currentText);",
            "",
            "// Retake ow"
          ]
        }
      ],
      "className": "ClipboardService",
      "packageName": "io.joshuasalcedo"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/maven/Dependency.java",
      "methods": [],
      "className": "Dependency",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/maven/Plugin.java",
      "methods": [],
      "className": "Plugin",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/maven/PomCoordinates.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "project",
          "parameters": [],
          "body": "",
          "javadoc": {
            "description": "The version of the project.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "PomCoordinates",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/maven/PomStructure.java",
      "methods": [],
      "className": "PomStructure",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/maven/Property.java",
      "methods": [],
      "className": "Property",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/maven/PluginConfiguration.java",
      "methods": [],
      "className": "PluginConfiguration",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/maven/ParentInfo.java",
      "methods": [],
      "className": "ParentInfo",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/javafile/JavadocTag.java",
      "methods": [],
      "className": "JavadocTag",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/javafile/JavadocStructure.java",
      "methods": [],
      "className": "JavadocStructure",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/javafile/ClassStructure.java",
      "methods": [],
      "className": "ClassStructure",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/javafile/Parameter.java",
      "methods": [],
      "className": "Parameter",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/javafile/MethodStructure.java",
      "methods": [],
      "className": "MethodStructure",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/markdown/MarkdownHeading.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "heading",
          "parameters": [],
          "body": "",
          "javadoc": {
            "description": "Represents a heading in a Markdown document.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "heading",
          "parameters": [
            {
              "type": "for",
              "name": "anchor"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The text content of the heading.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "MarkdownHeading",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/markdown/MarkdownLink.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "internal",
          "methodName": "link",
          "parameters": [
            {
              "type": "within",
              "name": "the"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The title attribute of the link, if any.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "MarkdownLink",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/markdown/MarkdownCodeBlock.java",
      "methods": [],
      "className": "MarkdownCodeBlock",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/markdown/MarkdownContent.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "document",
          "parameters": [
            {
              "type": "usually",
              "name": "from"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Represents the parsed structure of a Markdown document.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "if",
          "methodName": "present",
          "parameters": [
            {
              "type": "for",
              "name": "formats"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "List of all code blocks in the document.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "MarkdownContent",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/markdown/MarkdownImage.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "local",
          "methodName": "image",
          "parameters": [
            {
              "type": "file",
              "name": "path"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The title of the image, if any.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "external",
          "methodName": "image",
          "parameters": [],
          "body": "",
          "javadoc": {
            "description": "The title of the image, if any.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "MarkdownImage",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/git/TagInfo.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "tag",
          "parameters": [
            {
              "type": "for",
              "name": "annotated"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Whether this is an annotated tag.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "tagger",
          "parameters": [
            {
              "type": "for",
              "name": "annotated"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The message of the tag (for annotated tags).",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "tagger",
          "parameters": [
            {
              "type": "for",
              "name": "annotated"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The name of the tagger (for annotated tags).",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "was",
          "methodName": "created",
          "parameters": [
            {
              "type": "for",
              "name": "annotated"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The email of the tagger (for annotated tags).",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "TagInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/git/CommitInfo.java",
      "methods": [],
      "className": "CommitInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/git/ContributorInfo.java",
      "methods": [],
      "className": "ContributorInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/git/GitRepositoryInfo.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "repository",
          "parameters": [
            {
              "type": "earliest",
              "name": "commit"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "List of top contributors.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "repository",
          "parameters": [
            {
              "type": "latest",
              "name": "commit"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Creation date of the repository (earliest commit).",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "GitRepositoryInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/git/BranchInfo.java",
      "methods": [],
      "className": "BranchInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/model/git/FileChange.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "change",
          "methodName": "type",
          "parameters": [],
          "body": "{\r\n        /**\r\n         * File was added.\r\n         */\r\n        ADD,\r\n        \r\n        /**\r\n         * File was modified.\r\n         */\r\n        MODIFY,\r\n        \r\n        /**\r\n         * File was deleted.\r\n         */\r\n        DELETE,\r\n        \r\n        /**\r\n         * File was renamed.\r\n         */\r\n        RENAME,\r\n        \r\n        /**\r\n         * File was copied.\r\n         */\r\n        COPY\r\n    }",
          "javadoc": {
            "description": "Represents information about a file change in a Git commit.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "file",
          "parameters": [
            {
              "type": "for",
              "name": "renames"
            }
          ],
          "body": "{\r\n        /**\r\n         * File was added.\r\n         */\r\n        ADD,\r\n        \r\n        /**\r\n         * File was modified.\r\n         */\r\n        MODIFY,\r\n        \r\n        /**\r\n         * File was deleted.\r\n         */\r\n        DELETE,\r\n        \r\n        /**\r\n         * File was renamed.\r\n         */\r\n        RENAME,\r\n        \r\n        /**\r\n         * File was copied.\r\n         */\r\n        COPY\r\n    }",
          "javadoc": {
            "description": "The path of the file.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "FileChange",
      "packageName": "io.joshuasalcedo.model.git"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/parsers/MarkdownParser.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "MarkdownParser",
          "parameters": [],
          "body": "{\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Markdown content using CommonMark.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AssertionError",
          "parameters": [
            {
              "type": "\"Utility",
              "name": "class"
            }
          ],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return MarkdownContent.builder().rawContent(\"\").htmlContent(\"\").build();\r\n        }\r\n        \r\n        // Create parser with extensions\r\n        List\u003corg.commonmark.Extension\u003e extensions \u003d Arrays.asList(\r\n                AutolinkExtension.create(),\r\n                TablesExtension.create(),\r\n                StrikethroughExtension.create(),\r\n                InsExtension.create(),\r\n                HeadingAnchorExtension.create(),\r\n                YamlFrontMatterExtension.create()\r\n        );\r\n        \r\n        Parser parser \u003d Parser.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        HtmlRenderer renderer \u003d HtmlRenderer.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        // Parse markdown\r\n        Node document \u003d parser.parse(markdown);\r\n        \r\n        // Process front matter\r\n        YamlFrontMatterVisitor frontMatterVisitor \u003d new YamlFrontMatterVisitor();\r\n        document.accept(frontMatterVisitor);\r\n        Map\u003cString, Object\u003e frontMatter \u003d convertFrontMatter(frontMatterVisitor.getData());\r\n        \r\n        // Collect structural elements\r\n        List\u003cMarkdownHeading\u003e headings \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownLink\u003e links \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownImage\u003e images \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownCodeBlock\u003e codeBlocks \u003d new ArrayList\u003c\u003e();\r\n        \r\n        // Extract structure by visiting nodes\r\n        StructureCollector collector \u003d new StructureCollector(headings, links, images, codeBlocks);\r\n        document.accept(collector);\r\n        \r\n        // Extract title (first heading if available)\r\n        String title \u003d null;\r\n        if (!headings.isEmpty()) {\r\n            title \u003d headings.get(0).getText();\r\n        }\r\n        \r\n        // Count words and estimate reading time\r\n        int wordCount \u003d countWords(markdown);\r\n        int readingTimeMinutes \u003d calculateReadingTime(wordCount);\r\n        \r\n        // Render HTML\r\n        String htmlContent \u003d renderer.render(document);\r\n        \r\n        return MarkdownContent.builder()\r\n                .title(title)\r\n                .rawContent(markdown)\r\n                .htmlContent(htmlContent)\r\n                .headings(headings)\r\n                .links(links)\r\n                .images(images)\r\n                .codeBlocks(codeBlocks)\r\n                .frontMatter(frontMatter)\r\n                .wordCount(wordCount)\r\n                .readingTimeMinutes(readingTimeMinutes)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Markdown content using CommonMark.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "MarkdownContent",
          "methodName": "parseMarkdown",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return MarkdownContent.builder().rawContent(\"\").htmlContent(\"\").build();\r\n        }\r\n        \r\n        // Create parser with extensions\r\n        List\u003corg.commonmark.Extension\u003e extensions \u003d Arrays.asList(\r\n                AutolinkExtension.create(),\r\n                TablesExtension.create(),\r\n                StrikethroughExtension.create(),\r\n                InsExtension.create(),\r\n                HeadingAnchorExtension.create(),\r\n                YamlFrontMatterExtension.create()\r\n        );\r\n        \r\n        Parser parser \u003d Parser.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        HtmlRenderer renderer \u003d HtmlRenderer.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        // Parse markdown\r\n        Node document \u003d parser.parse(markdown);\r\n        \r\n        // Process front matter\r\n        YamlFrontMatterVisitor frontMatterVisitor \u003d new YamlFrontMatterVisitor();\r\n        document.accept(frontMatterVisitor);\r\n        Map\u003cString, Object\u003e frontMatter \u003d convertFrontMatter(frontMatterVisitor.getData());\r\n        \r\n        // Collect structural elements\r\n        List\u003cMarkdownHeading\u003e headings \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownLink\u003e links \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownImage\u003e images \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownCodeBlock\u003e codeBlocks \u003d new ArrayList\u003c\u003e();\r\n        \r\n        // Extract structure by visiting nodes\r\n        StructureCollector collector \u003d new StructureCollector(headings, links, images, codeBlocks);\r\n        document.accept(collector);\r\n        \r\n        // Extract title (first heading if available)\r\n        String title \u003d null;\r\n        if (!headings.isEmpty()) {\r\n            title \u003d headings.get(0).getText();\r\n        }\r\n        \r\n        // Count words and estimate reading time\r\n        int wordCount \u003d countWords(markdown);\r\n        int readingTimeMinutes \u003d calculateReadingTime(wordCount);\r\n        \r\n        // Render HTML\r\n        String htmlContent \u003d renderer.render(document);\r\n        \r\n        return MarkdownContent.builder()\r\n                .title(title)\r\n                .rawContent(markdown)\r\n                .htmlContent(htmlContent)\r\n                .headings(headings)\r\n                .links(links)\r\n                .images(images)\r\n                .codeBlocks(codeBlocks)\r\n                .frontMatter(frontMatter)\r\n                .wordCount(wordCount)\r\n                .readingTimeMinutes(readingTimeMinutes)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Parse markdown content into a structured MarkdownContent object.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to parse"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "YamlFrontMatterVisitor",
          "parameters": [],
          "body": "{\r\n            title \u003d headings.get(0).getText();\r\n        }",
          "comments": [
            "Parse markdown",
            "Process front matter"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StructureCollector",
          "parameters": [],
          "body": "{\r\n            title \u003d headings.get(0).getText();\r\n        }",
          "comments": [
            "Extract structure by visiting nodes"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Extract",
          "methodName": "title",
          "parameters": [
            {
              "type": "first",
              "name": "heading"
            }
          ],
          "body": "{\r\n            title \u003d headings.get(0).getText();\r\n        }",
          "comments": [
            "Extract structure by visiting nodes",
            "Extract title (first heading if available)"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "MarkdownContent",
          "methodName": "parseMarkdownFile",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            }
          ],
          "body": "{\r\n        String content \u003d Files.readString(file.toPath());\r\n        return parseMarkdown(content);\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The markdown file to parse"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "parseMarkdown",
          "parameters": [],
          "body": "{\r\n        String content \u003d Files.readString(path);\r\n        return parseMarkdown(content);\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The markdown file to parse"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "MarkdownContent",
          "methodName": "parseMarkdownFile",
          "parameters": [
            {
              "type": "Path",
              "name": "path"
            }
          ],
          "body": "{\r\n        String content \u003d Files.readString(path);\r\n        return parseMarkdown(content);\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a Path.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to the markdown file"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "parseMarkdown",
          "parameters": [],
          "body": "{\r\n        String content \u003d Files.readString(path);\r\n        return parseMarkdown(content);\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a Path.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to the markdown file"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "MarkdownContent",
          "methodName": "parseMarkdownReader",
          "parameters": [
            {
              "type": "Reader",
              "name": "reader"
            }
          ],
          "body": "{\r\n        StringBuilder sb \u003d new StringBuilder();\r\n        char[] buffer \u003d new char[4096];\r\n        int n;\r\n        while ((n \u003d reader.read(buffer)) !\u003d -1) {\r\n            sb.append(buffer, 0, n);\r\n        }\r\n        return parseMarkdown(sb.toString());\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a Reader.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "reader The reader containing markdown content"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StringBuilder",
          "parameters": [],
          "body": "{\r\n            sb.append(buffer, 0, n);\r\n        }",
          "javadoc": {
            "description": "Parse markdown content from a Reader.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "reader The reader containing markdown content"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "parseMarkdown",
          "parameters": [],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return \"\";\r\n        }\r\n        \r\n        List\u003corg.commonmark.Extension\u003e extensions \u003d Arrays.asList(\r\n                AutolinkExtension.create(),\r\n                TablesExtension.create(),\r\n                StrikethroughExtension.create(),\r\n                InsExtension.create()\r\n        );\r\n        \r\n        Parser parser \u003d Parser.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        HtmlRenderer renderer \u003d HtmlRenderer.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        Node document \u003d parser.parse(markdown);\r\n        return renderer.render(document);\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "markdownToHtml",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return \"\";\r\n        }\r\n        \r\n        List\u003corg.commonmark.Extension\u003e extensions \u003d Arrays.asList(\r\n                AutolinkExtension.create(),\r\n                TablesExtension.create(),\r\n                StrikethroughExtension.create(),\r\n                InsExtension.create()\r\n        );\r\n        \r\n        Parser parser \u003d Parser.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        HtmlRenderer renderer \u003d HtmlRenderer.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        Node document \u003d parser.parse(markdown);\r\n        return renderer.render(document);\r\n    }",
          "javadoc": {
            "description": "Simply convert markdown to HTML.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to convert"
              },
              {
                "name": "return",
                "value": "HTML representation of the markdown"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMarkdownHeading\u003e",
          "methodName": "extractHeadings",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        MarkdownContent content \u003d parseMarkdown(markdown);\r\n        return content.getHeadings();\r\n    }",
          "javadoc": {
            "description": "Extract all headings from markdown content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to process"
              },
              {
                "name": "return",
                "value": "List of headings"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMarkdownLink\u003e",
          "methodName": "extractLinks",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        MarkdownContent content \u003d parseMarkdown(markdown);\r\n        return content.getLinks();\r\n    }",
          "javadoc": {
            "description": "Extract all links from markdown content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to process"
              },
              {
                "name": "return",
                "value": "List of links"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMarkdownImage\u003e",
          "methodName": "extractImages",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        MarkdownContent content \u003d parseMarkdown(markdown);\r\n        return content.getImages();\r\n    }",
          "javadoc": {
            "description": "Extract all images from markdown content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to process"
              },
              {
                "name": "return",
                "value": "List of images"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMarkdownCodeBlock\u003e",
          "methodName": "extractCodeBlocks",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        MarkdownContent content \u003d parseMarkdown(markdown);\r\n        return content.getCodeBlocks();\r\n    }",
          "javadoc": {
            "description": "Extract all code blocks from markdown content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to process"
              },
              {
                "name": "return",
                "value": "List of code blocks"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "int",
          "methodName": "countWords",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return 0;\r\n        }\r\n        \r\n        // Remove YAML front matter if present\r\n        String content \u003d markdown;\r\n        if (content.startsWith(\"---\")) {\r\n            int end \u003d content.indexOf(\"---\", 3);\r\n            if (end \u003e 0) {\r\n                content \u003d content.substring(end + 3);\r\n            }\r\n        }\r\n        \r\n        // Remove code blocks\r\n        content \u003d content.replaceAll(\"```.*?```\", \" \");\r\n        \r\n        // Remove HTML tags\r\n        content \u003d content.replaceAll(\"\u003c[^\u003e]*\u003e\", \" \");\r\n        \r\n        // Remove markdown symbols\r\n        content \u003d content.replaceAll(\"[#*_~`\\\\[\\\\](){}|]+\", \" \");\r\n        \r\n        // Split by whitespace and count non-empty words\r\n        String[] words \u003d content.trim().split(\"\\\\s+\");\r\n        int count \u003d 0;\r\n        for (String word : words) {\r\n            if (!word.isEmpty()) {\r\n                count++;\r\n            }\r\n        }\r\n        \r\n        return count;\r\n    }",
          "javadoc": {
            "description": "Count the words in a markdown text.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content"
              },
              {
                "name": "return",
                "value": "The word count"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "int",
          "methodName": "calculateReadingTime",
          "parameters": [
            {
              "type": "int",
              "name": "wordCount"
            }
          ],
          "body": "{\r\n        // Average reading speed: 200-250 words per minute\r\n        final int wordsPerMinute \u003d 225;\r\n        int minutes \u003d wordCount / wordsPerMinute;\r\n        if (wordCount % wordsPerMinute \u003e 0) {\r\n            minutes++;\r\n        }\r\n        return Math.max(1, minutes);\r\n    }",
          "javadoc": {
            "description": "Calculate estimated reading time in minutes.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "wordCount The number of words"
              },
              {
                "name": "return",
                "value": "Estimated reading time in minutes"
              }
            ]
          },
          "comments": [
            "Average reading speed: 200-250"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "convertFrontMatter",
          "parameters": [
            {
              "type": "List\u003cString\u003e\u003e",
              "name": "frontMatterData"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n        \r\n        for (Map.Entry\u003cString, List\u003cString\u003e\u003e entry : frontMatterData.entrySet()) {\r\n            String key \u003d entry.getKey();\r\n            List\u003cString\u003e values \u003d entry.getValue();\r\n            \r\n            if (values.size() \u003d\u003d 1) {\r\n                // Single value\r\n                result.put(key, values.get(0));\r\n            } else {\r\n                // Multiple values\r\n                result.put(key, values);\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }",
          "javadoc": {
            "description": "Convert front matter data to a map of objects.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "frontMatterData The front matter data from the visitor"
              },
              {
                "name": "return",
                "value": "Converted front matter map"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "public",
          "methodName": "StructureCollector",
          "parameters": [
            {
              "type": "List\u003cMarkdownHeading\u003e",
              "name": "headings"
            },
            {
              "type": "List\u003cMarkdownLink\u003e",
              "name": "links"
            },
            {
              "type": "List\u003cMarkdownImage\u003e",
              "name": "images"
            },
            {
              "type": "List\u003cMarkdownCodeBlock\u003e",
              "name": "codeBlocks"
            }
          ],
          "body": "{\r\n            this.headings \u003d headings;\r\n            this.links \u003d links;\r\n            this.images \u003d images;\r\n            this.codeBlocks \u003d codeBlocks;\r\n        }",
          "javadoc": {
            "description": "A node visitor that collects structural elements from a markdown document.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "Heading",
              "name": "heading"
            }
          ],
          "body": "{\r\n            String id \u003d \"\";\r\n            // Get heading ID from attributes if available\r\n            if (heading.getFirstChild() instanceof Text) {\r\n                String text \u003d ((Text) heading.getFirstChild()).getLiteral();\r\n                // Generate simplified ID from heading text\r\n                id \u003d text.toLowerCase()\r\n                        .replaceAll(\"[^\\\\w\\\\s-]\", \"\")\r\n                        .replaceAll(\"\\\\s+\", \"-\");\r\n            }\r\n            \r\n            StringBuilder textBuilder \u003d new StringBuilder();\r\n            Node child \u003d heading.getFirstChild();\r\n            while (child !\u003d null) {\r\n                if (child instanceof Text) {\r\n                    textBuilder.append(((Text) child).getLiteral());\r\n                }\r\n                child \u003d child.getNext();\r\n            }\r\n            \r\n            MarkdownHeading mdHeading \u003d MarkdownHeading.builder()\r\n                    .level(heading.getLevel())\r\n                    .text(textBuilder.toString())\r\n                    .id(id)\r\n                    .position(nodePosition++)\r\n                    .build();\r\n            \r\n            headings.add(mdHeading);\r\n            visitChildren(heading);\r\n        }",
          "comments": [
            "Get heading ID fro"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                String text \u003d ((Text) heading.getFirstChild()).getLiteral();\r\n                // Generate simplified ID from heading text\r\n                id \u003d text.toLowerCase()\r\n                        .replaceAll(\"[^\\\\w\\\\s-]\", \"\")\r\n                        .replaceAll(\"\\\\s+\", \"-\");\r\n            }",
          "comments": [
            "Get heading ID from attributes if available"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StringBuilder",
          "parameters": [],
          "body": "{\r\n            sb.append(buffer, 0, n);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "Link",
              "name": "link"
            }
          ],
          "body": "{\r\n            String text \u003d \"\";\r\n            if (link.getFirstChild() instanceof Text) {\r\n                text \u003d ((Text) link.getFirstChild()).getLiteral();\r\n            }\r\n            \r\n            MarkdownLink mdLink \u003d MarkdownLink.builder()\r\n                    .text(text)\r\n                    .url(link.getDestination())\r\n                    .title(link.getTitle())\r\n                    .internal(link.getDestination().startsWith(\"#\"))\r\n                    .build();\r\n            \r\n            links.add(mdLink);\r\n            visitChildren(link);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "Image",
              "name": "image"
            }
          ],
          "body": "{\r\n            MarkdownImage mdImage \u003d MarkdownImage.builder()\r\n                    .altText(image.getTitle())\r\n                    .url(image.getDestination())\r\n                    .title(image.getTitle())\r\n                    .local(!image.getDestination().startsWith(\"http\"))\r\n                    .build();\r\n            \r\n            images.add(mdImage);\r\n            visitChildren(image);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "FencedCodeBlock",
              "name": "codeBlock"
            }
          ],
          "body": "{\r\n            MarkdownCodeBlock mdCodeBlock \u003d MarkdownCodeBlock.builder()\r\n                    .content(codeBlock.getLiteral())\r\n                    .language(codeBlock.getInfo())\r\n                    .fenced(true)\r\n                    .position(nodePosition++)\r\n                    .build();\r\n            \r\n            codeBlocks.add(mdCodeBlock);\r\n            visitChildren(codeBlock);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "IndentedCodeBlock",
              "name": "codeBlock"
            }
          ],
          "body": "{\r\n            MarkdownCodeBlock mdCodeBlock \u003d MarkdownCodeBlock.builder()\r\n                    .content(codeBlock.getLiteral())\r\n                    .language(null)\r\n                    .fenced(false)\r\n                    .position(nodePosition++)\r\n                    .build();\r\n            \r\n            codeBlocks.add(mdCodeBlock);\r\n            visitChildren(codeBlock);\r\n        }",
          "comments": []
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/parsers/GitParser.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "GitParser",
          "parameters": [],
          "body": "{\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Git repositories using JGit.\r\nThis class provides static methods to analyze Git repositories and extract structural information.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AssertionError",
          "parameters": [
            {
              "type": "\"Utility",
              "name": "class"
            }
          ],
          "body": "{\r\n        File gitDir \u003d new File(repoPath);\r\n        try (Git git \u003d Git.open(gitDir)) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Git repositories using JGit.\r\nThis class provides static methods to analyze Git repositories and extract structural information.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "GitRepositoryInfo",
          "methodName": "parseRepository",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            }
          ],
          "body": "{\r\n        File gitDir \u003d new File(repoPath);\r\n        try (Git git \u003d Git.open(gitDir)) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Parse a Git repository and extract comprehensive information.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "GitRepositoryInfo object containing repository information"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Parse a Git repository and extract comprehensive information.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "GitRepositoryInfo object containing repository information"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "RevCommit",
          "methodName": "getLatestCommit",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Iterable\u003cRevCommit\u003e commits \u003d git.log().setMaxCount(1).call();\r\n        return commits.iterator().hasNext() ? commits.iterator().next() : null;\r\n    }",
          "javadoc": {
            "description": "Get the latest commit in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "The latest RevCommit or null if the repository is empty"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "CommitInfo",
          "methodName": "convertToCommitInfo",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            },
            {
              "type": "Repository",
              "name": "repository"
            }
          ],
          "body": "{\r\n        PersonIdent authorIdent \u003d commit.getAuthorIdent();\r\n        PersonIdent committerIdent \u003d commit.getCommitterIdent();\r\n\r\n        // Get parent commits\r\n        List\u003cString\u003e parentIds \u003d new ArrayList\u003c\u003e();\r\n        for (RevCommit parent : commit.getParents()) {\r\n            parentIds.add(parent.getName());\r\n        }\r\n\r\n        // Get file changes\r\n        List\u003cFileChange\u003e fileChanges \u003d getFileChanges(commit, repository);\r\n\r\n        return CommitInfo.builder()\r\n                .id(commit.getName())\r\n                .shortId(commit.getName().substring(0, 7))\r\n                .message(commit.getFullMessage())\r\n                .authorName(authorIdent.getName())\r\n                .authorEmail(authorIdent.getEmailAddress())\r\n                .authorDate(authorIdent.getWhen())\r\n                .committerName(committerIdent.getName())\r\n                .committerEmail(committerIdent.getEmailAddress())\r\n                .commitDate(committerIdent.getWhen())\r\n                .parentIds(parentIds)\r\n                .changedFiles(fileChanges)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Convert a RevCommit to a CommitInfo object.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "commit     The RevCommit to convert"
              },
              {
                "name": "param",
                "value": "repository The repository containing the commit"
              },
              {
                "name": "return",
                "value": "A CommitInfo object"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cFileChange\u003e",
          "methodName": "getFileChanges",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            },
            {
              "type": "Repository",
              "name": "repository"
            }
          ],
          "body": "{\r\n        List\u003cFileChange\u003e changes \u003d new ArrayList\u003c\u003e();\r\n\r\n        // If this is the first commit, there\u0027s nothing to compare with\r\n        if (commit.getParentCount() \u003d\u003d 0) {\r\n            return changes;\r\n        }\r\n\r\n        RevCommit parent \u003d commit.getParent(0);\r\n\r\n        try (ObjectReader reader \u003d repository.newObjectReader();\r\n             DiffFormatter formatter \u003d new DiffFormatter(DisabledOutputStream.INSTANCE)) {\r\n\r\n            formatter.setRepository(repository);\r\n            formatter.setDiffComparator(RawTextComparator.DEFAULT);\r\n\r\n            CanonicalTreeParser oldTreeParser \u003d new CanonicalTreeParser();\r\n            oldTreeParser.reset(reader, parent.getTree());\r\n\r\n            CanonicalTreeParser newTreeParser \u003d new CanonicalTreeParser();\r\n            newTreeParser.reset(reader, commit.getTree());\r\n\r\n            List\u003cDiffEntry\u003e diffs \u003d formatter.scan(oldTreeParser, newTreeParser);\r\n\r\n            for (DiffEntry diff : diffs) {\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }\r\n        }\r\n\r\n        return changes;\r\n    }",
          "javadoc": {
            "description": "Get file changes for a commit.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "commit     The commit to analyze"
              },
              {
                "name": "param",
                "value": "repository The repository containing the commit"
              },
              {
                "name": "return",
                "value": "List of FileChange objects"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "with",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            return changes;\r\n        }",
          "comments": [
            "If this is the first commit, there\u0027s nothing to compare with"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "DiffFormatter",
          "parameters": [],
          "body": "{\r\n\r\n            formatter.setRepository(repository);\r\n            formatter.setDiffComparator(RawTextComparator.DEFAULT);\r\n\r\n            CanonicalTreeParser oldTreeParser \u003d new CanonicalTreeParser();\r\n            oldTreeParser.reset(reader, parent.getTree());\r\n\r\n            CanonicalTreeParser newTreeParser \u003d new CanonicalTreeParser();\r\n            newTreeParser.reset(reader, commit.getTree());\r\n\r\n            List\u003cDiffEntry\u003e diffs \u003d formatter.scan(oldTreeParser, newTreeParser);\r\n\r\n            for (DiffEntry diff : diffs) {\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "CanonicalTreeParser",
          "parameters": [],
          "body": "{\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "CanonicalTreeParser",
          "parameters": [],
          "body": "{\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "ChangeType",
          "methodName": "convertChangeType",
          "parameters": [
            {
              "type": "DiffEntry.ChangeType",
              "name": "jgitChangeType"
            }
          ],
          "body": "{\r\n        switch (jgitChangeType) {\r\n            case ADD:\r\n                return FileChange.ChangeType.ADD;\r\n            case MODIFY:\r\n                return FileChange.ChangeType.MODIFY;\r\n            case DELETE:\r\n                return FileChange.ChangeType.DELETE;\r\n            case RENAME:\r\n                return FileChange.ChangeType.RENAME;\r\n            case COPY:\r\n                return FileChange.ChangeType.COPY;\r\n            default:\r\n                return FileChange.ChangeType.MODIFY;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Convert JGit change type to our own ChangeType enum.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "jgitChangeType The JGit DiffEntry.ChangeType"
              },
              {
                "name": "return",
                "value": "Our FileChange.ChangeType"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cBranchInfo\u003e",
          "methodName": "getAllBranches",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        List\u003cBranchInfo\u003e branches \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Get current branch name\r\n        String currentBranch \u003d git.getRepository().getBranch();\r\n\r\n        // Get local branches\r\n        List\u003cRef\u003e localBranches \u003d git.branchList().call();\r\n        for (Ref branch : localBranches) {\r\n            String branchName \u003d branch.getName().substring(branch.getName().lastIndexOf(\"/\") + 1);\r\n\r\n            // Check if branch is merged\r\n            boolean merged \u003d false;\r\n            try {\r\n                List\u003cRef\u003e mergedBranches \u003d git.branchList().setContains(currentBranch).call();\r\n                for (Ref mergedBranch : mergedBranches) {\r\n                    if (mergedBranch.getName().equals(branch.getName())) {\r\n                        merged \u003d true;\r\n                        break;\r\n                    }\r\n                }\r\n            } catch (Exception e) {\r\n                // Ignore errors checking merged status\r\n            }\r\n\r\n            // Get tracking branch\r\n            String trackingBranch \u003d null;\r\n            try {\r\n                trackingBranch \u003d git.getRepository().getConfig().getString(\"branch\", branchName, \"merge\");\r\n                if (trackingBranch !\u003d null \u0026\u0026 trackingBranch.startsWith(\"refs/heads/\")) {\r\n                    trackingBranch \u003d trackingBranch.substring(\"refs/heads/\".length());\r\n                }\r\n            } catch (Exception e) {\r\n                // Ignore errors getting tracking branch\r\n            }\r\n\r\n            branches.add(BranchInfo.builder()\r\n                    .name(branchName)\r\n                    .current(branchName.equals(currentBranch))\r\n                    .remote(false)\r\n                    .commitId(branch.getObjectId().getName())\r\n                    .merged(merged)\r\n                    .trackingBranch(trackingBranch)\r\n                    .build());\r\n        }\r\n\r\n        // Get remote branches\r\n        List\u003cRef\u003e remoteBranches \u003d git.branchList().setListMode(ListBranchCommand.ListMode.REMOTE).call();\r\n        for (Ref branch : remoteBranches) {\r\n            String fullName \u003d branch.getName();\r\n            String remoteName \u003d fullName.substring(fullName.indexOf(\"/\") + 1, fullName.lastIndexOf(\"/\"));\r\n            String branchName \u003d fullName.substring(fullName.lastIndexOf(\"/\") + 1);\r\n            branches.add(BranchInfo.builder()\r\n                    .name(branchName)\r\n                    .current(false)\r\n                    .remote(true)\r\n                    .remoteName(remoteName)\r\n                    .commitId(branch.getObjectId().getName())\r\n                    .build());\r\n        }\r\n\r\n        return branches;\r\n    }",
          "javadoc": {
            "description": "Get all branches in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "List of BranchInfo objects"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cTagInfo\u003e",
          "methodName": "getAllTags",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        List\u003cTagInfo\u003e tags \u003d new ArrayList\u003c\u003e();\r\n        List\u003cRef\u003e tagRefs \u003d git.tagList().call();\r\n\r\n        try (RevWalk revWalk \u003d new RevWalk(git.getRepository())) {\r\n            for (Ref tagRef : tagRefs) {\r\n                String tagName \u003d tagRef.getName().substring(tagRef.getName().lastIndexOf(\"/\") + 1);\r\n                ObjectId objectId \u003d tagRef.getObjectId();\r\n\r\n                boolean isAnnotated \u003d false;\r\n                RevTag revTag \u003d null;\r\n                RevCommit commit \u003d null;\r\n\r\n                try {\r\n                    revTag \u003d revWalk.parseTag(objectId);\r\n                    isAnnotated \u003d true;\r\n                    commit \u003d revWalk.parseCommit(revTag.getObject());\r\n                } catch (IOException e) {\r\n                    // Not an annotated tag\r\n                    commit \u003d revWalk.parseCommit(objectId);\r\n                }\r\n\r\n                TagInfo.TagInfoBuilder builder \u003d TagInfo.builder()\r\n                        .name(tagName)\r\n                        .commitId(commit.getName())\r\n                        .annotated(isAnnotated);\r\n\r\n                if (isAnnotated \u0026\u0026 revTag !\u003d null) {\r\n                    PersonIdent taggerIdent \u003d revTag.getTaggerIdent();\r\n                    builder.message(revTag.getFullMessage())\r\n                            .taggerName(taggerIdent.getName())\r\n                            .taggerEmail(taggerIdent.getEmailAddress())\r\n                            .taggerDate(taggerIdent.getWhen());\r\n                }\r\n\r\n                tags.add(builder.build());\r\n            }\r\n        }\r\n\r\n        return tags;\r\n    }",
          "javadoc": {
            "description": "Get all tags in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "List of TagInfo objects"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "RevWalk",
          "parameters": [],
          "body": "{\r\n            for (Ref tagRef : tagRefs) {\r\n                String tagName \u003d tagRef.getName().substring(tagRef.getName().lastIndexOf(\"/\") + 1);\r\n                ObjectId objectId \u003d tagRef.getObjectId();\r\n\r\n                boolean isAnnotated \u003d false;\r\n                RevTag revTag \u003d null;\r\n                RevCommit commit \u003d null;\r\n\r\n                try {\r\n                    revTag \u003d revWalk.parseTag(objectId);\r\n                    isAnnotated \u003d true;\r\n                    commit \u003d revWalk.parseCommit(revTag.getObject());\r\n                } catch (IOException e) {\r\n                    // Not an annotated tag\r\n                    commit \u003d revWalk.parseCommit(objectId);\r\n                }\r\n\r\n                TagInfo.TagInfoBuilder builder \u003d TagInfo.builder()\r\n                        .name(tagName)\r\n                        .commitId(commit.getName())\r\n                        .annotated(isAnnotated);\r\n\r\n                if (isAnnotated \u0026\u0026 revTag !\u003d null) {\r\n                    PersonIdent taggerIdent \u003d revTag.getTaggerIdent();\r\n                    builder.message(revTag.getFullMessage())\r\n                            .taggerName(taggerIdent.getName())\r\n                            .taggerEmail(taggerIdent.getEmailAddress())\r\n                            .taggerDate(taggerIdent.getWhen());\r\n                }\r\n\r\n                tags.add(builder.build());\r\n            }\r\n        }",
          "javadoc": {
            "description": "Get all tags in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "List of TagInfo objects"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "hasUncommittedChanges",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Status status \u003d git.status().call();\r\n        return !status.isClean();\r\n    }",
          "javadoc": {
            "description": "Check if the repository has uncommitted changes.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "true if there are uncommitted changes, false otherwise"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "int",
          "methodName": "countCommits",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        LogCommand logCommand \u003d git.log();\r\n        Iterable\u003cRevCommit\u003e commits \u003d logCommand.call();\r\n        return (int) StreamSupport.stream(commits.spliterator(), false).count();\r\n    }",
          "javadoc": {
            "description": "Count the number of commits in the current branch.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "The number of commits"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cContributorInfo\u003e",
          "methodName": "getTopContributors",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            },
            {
              "type": "int",
              "name": "maxCount"
            }
          ],
          "body": "{\r\n        // Maps to track contributor statistics\r\n        Map\u003cString, ContributorInfo.ContributorInfoBuilder\u003e contributors \u003d new HashMap\u003c\u003e();\r\n        Map\u003cString, Date\u003e firstCommitDates \u003d new HashMap\u003c\u003e();\r\n        Map\u003cString, Date\u003e lastCommitDates \u003d new HashMap\u003c\u003e();\r\n\r\n        // Get all commits\r\n        Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n        for (RevCommit commit : commits) {\r\n            PersonIdent author \u003d commit.getAuthorIdent();\r\n            String authorEmail \u003d author.getEmailAddress();\r\n\r\n            // Initialize contributor if not exists\r\n            if (!contributors.containsKey(authorEmail)) {\r\n                contributors.put(authorEmail, ContributorInfo.builder()\r\n                        .name(author.getName())\r\n                        .email(authorEmail)\r\n                        .commitCount(0)\r\n                        .linesAdded(0)\r\n                        .linesDeleted(0));\r\n\r\n                firstCommitDates.put(authorEmail, author.getWhen());\r\n                lastCommitDates.put(authorEmail, author.getWhen());\r\n            }\r\n\r\n            // Update commit count\r\n            ContributorInfo.ContributorInfoBuilder contributor \u003d contributors.get(authorEmail);\r\n            contributor.commitCount(contributor.build().getCommitCount() + 1);\r\n\r\n            // Update dates\r\n            Date commitDate \u003d author.getWhen();\r\n            if (commitDate.before(firstCommitDates.get(authorEmail))) {\r\n                firstCommitDates.put(authorEmail, commitDate);\r\n            }\r\n            if (commitDate.after(lastCommitDates.get(authorEmail))) {\r\n                lastCommitDates.put(authorEmail, commitDate);\r\n            }\r\n\r\n            // Update line changes\r\n            if (commit.getParentCount() \u003e 0) {\r\n                List\u003cFileChange\u003e changes \u003d getFileChanges(commit, git.getRepository());\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                for (FileChange change : changes) {\r\n                    linesAdded +\u003d change.getLinesAdded();\r\n                    linesDeleted +\u003d change.getLinesDeleted();\r\n                }\r\n\r\n                contributor.linesAdded(contributor.build().getLinesAdded() + linesAdded);\r\n                contributor.linesDeleted(contributor.build().getLinesDeleted() + linesDeleted);\r\n            }\r\n        }\r\n\r\n        // Build final contributor list\r\n        List\u003cContributorInfo\u003e result \u003d new ArrayList\u003c\u003e();\r\n        for (String email : contributors.keySet()) {\r\n            ContributorInfo.ContributorInfoBuilder builder \u003d contributors.get(email);\r\n            builder.firstCommitDate(firstCommitDates.get(email));\r\n            builder.lastCommitDate(lastCommitDates.get(email));\r\n            result.add(builder.build());\r\n        }\r\n\r\n        // Sort by commit count and limit to maxCount\r\n        result.sort((c1, c2) -\u003e Integer.compare(c2.getCommitCount(), c1.getCommitCount()));\r\n        return result.stream().limit(maxCount).collect(Collectors.toList());\r\n    }",
          "javadoc": {
            "description": "Get the top contributors to the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git      The Git instance"
              },
              {
                "name": "param",
                "value": "maxCount Maximum number of contributors to return"
              },
              {
                "name": "return",
                "value": "List of ContributorInfo objects"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "exists",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                contributors.put(authorEmail, ContributorInfo.builder()\r\n                        .name(author.getName())\r\n                        .email(authorEmail)\r\n                        .commitCount(0)\r\n                        .linesAdded(0)\r\n                        .linesDeleted(0));\r\n\r\n                firstCommitDates.put(authorEmail, author.getWhen());\r\n                lastCommitDates.put(authorEmail, author.getWhen());\r\n            }",
          "comments": [
            "Initialize contributor if not exists"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "changes",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                List\u003cFileChange\u003e changes \u003d getFileChanges(commit, git.getRepository());\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                for (FileChange change : changes) {\r\n                    linesAdded +\u003d change.getLinesAdded();\r\n                    linesDeleted +\u003d change.getLinesDeleted();\r\n                }\r\n\r\n                contributor.linesAdded(contributor.build().getLinesAdded() + linesAdded);\r\n                contributor.linesDeleted(contributor.build().getLinesDeleted() + linesDeleted);\r\n            }",
          "comments": [
            "Update line changes"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "getRepositoryStatistics",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e statistics \u003d new HashMap\u003c\u003e();\r\n\r\n        // Get all commits\r\n        Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n        List\u003cRevCommit\u003e commitList \u003d StreamSupport.stream(commits.spliterator(), false)\r\n                .collect(Collectors.toList());\r\n\r\n        // Calculate commits per day of week\r\n        Map\u003cString, Integer\u003e commitsPerDayOfWeek \u003d new HashMap\u003c\u003e();\r\n        String[] daysOfWeek \u003d {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\r\n        for (String day : daysOfWeek) {\r\n            commitsPerDayOfWeek.put(day, 0);\r\n        }\r\n\r\n        SimpleDateFormat dayFormat \u003d new SimpleDateFormat(\"EEEE\");\r\n        for (RevCommit commit : commitList) {\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String dayOfWeek \u003d dayFormat.format(commitDate);\r\n            commitsPerDayOfWeek.put(dayOfWeek, commitsPerDayOfWeek.get(dayOfWeek) + 1);\r\n        }\r\n\r\n        // Calculate commits per hour\r\n        Map\u003cInteger, Integer\u003e commitsPerHour \u003d new HashMap\u003c\u003e();\r\n        for (int i \u003d 0; i \u003c 24; i++) {\r\n            commitsPerHour.put(i, 0);\r\n        }\r\n\r\n        Calendar calendar \u003d Calendar.getInstance();\r\n        for (RevCommit commit : commitList) {\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            calendar.setTime(commitDate);\r\n            int hour \u003d calendar.get(Calendar.HOUR_OF_DAY);\r\n            commitsPerHour.put(hour, commitsPerHour.get(hour) + 1);\r\n        }\r\n\r\n        // Calculate commits per month\r\n        Map\u003cString, Integer\u003e commitsPerMonth \u003d new HashMap\u003c\u003e();\r\n        String[] months \u003d {\"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\r\n                \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\r\n        for (String month : months) {\r\n            commitsPerMonth.put(month, 0);\r\n        }\r\n\r\n        SimpleDateFormat monthFormat \u003d new SimpleDateFormat(\"MMMM\");\r\n        for (RevCommit commit : commitList) {\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String month \u003d monthFormat.format(commitDate);\r\n            commitsPerMonth.put(month, commitsPerMonth.get(month) + 1);\r\n        }\r\n\r\n        // Calculate average commit size (in changed files)\r\n        int totalChangedFiles \u003d 0;\r\n        for (RevCommit commit : commitList) {\r\n            if (commit.getParentCount() \u003e 0) {\r\n                List\u003cFileChange\u003e changes \u003d getFileChanges(commit, git.getRepository());\r\n                totalChangedFiles +\u003d changes.size();\r\n            }\r\n        }\r\n\r\n        double avgChangedFiles \u003d commitList.isEmpty() ? 0 : (double) totalChangedFiles / commitList.size();\r\n\r\n        // Add statistics to the map\r\n        statistics.put(\"totalCommits\", commitList.size());\r\n        statistics.put(\"commitsPerDayOfWeek\", commitsPerDayOfWeek);\r\n        statistics.put(\"commitsPerHour\", commitsPerHour);\r\n        statistics.put(\"commitsPerMonth\", commitsPerMonth);\r\n        statistics.put(\"averageChangedFilesPerCommit\", avgChangedFiles);\r\n\r\n        return statistics;\r\n    }",
          "javadoc": {
            "description": "Get various statistics about the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "Map of statistics"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String dayOfWeek \u003d dayFormat.format(commitDate);\r\n            commitsPerDayOfWeek.put(dayOfWeek, commitsPerDayOfWeek.get(dayOfWeek) + 1);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String month \u003d monthFormat.format(commitDate);\r\n            commitsPerMonth.put(month, commitsPerMonth.get(month) + 1);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "commit",
          "methodName": "size",
          "parameters": [
            {
              "type": "in",
              "name": "changed"
            }
          ],
          "body": "{\r\n            if (commit.getParentCount() \u003e 0) {\r\n                List\u003cFileChange\u003e changes \u003d getFileChanges(commit, git.getRepository());\r\n                totalChangedFiles +\u003d changes.size();\r\n            }\r\n        }",
          "comments": [
            "Calculate average commit size (in changed files)"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Integer\u003e",
          "methodName": "getFileExtensionCounts",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Map\u003cString, Integer\u003e extensionCounts \u003d new HashMap\u003c\u003e();\r\n\r\n        RevCommit headCommit \u003d getLatestCommit(git);\r\n        if (headCommit \u003d\u003d null) {\r\n            return extensionCounts;\r\n        }\r\n\r\n        Repository repository \u003d git.getRepository();\r\n        try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\r\n            treeWalk.addTree(headCommit.getTree());\r\n            treeWalk.setRecursive(true);\r\n\r\n            while (treeWalk.next()) {\r\n                String path \u003d treeWalk.getPathString();\r\n                int dotIndex \u003d path.lastIndexOf(\u0027.\u0027);\r\n                if (dotIndex \u003e 0) {\r\n                    String extension \u003d path.substring(dotIndex + 1).toLowerCase();\r\n                    extensionCounts.put(extension, extensionCounts.getOrDefault(extension, 0) + 1);\r\n                } else {\r\n                    extensionCounts.put(\"(no extension)\", extensionCounts.getOrDefault(\"(no extension)\", 0) + 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        return extensionCounts;\r\n    }",
          "javadoc": {
            "description": "Get counts of files by extension in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "Map of file extensions to counts"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "TreeWalk",
          "parameters": [],
          "body": "{\r\n            treeWalk.addTree(headCommit.getTree());\r\n            treeWalk.setRecursive(true);\r\n\r\n            while (treeWalk.next()) {\r\n                String path \u003d treeWalk.getPathString();\r\n                int dotIndex \u003d path.lastIndexOf(\u0027.\u0027);\r\n                if (dotIndex \u003e 0) {\r\n                    String extension \u003d path.substring(dotIndex + 1).toLowerCase();\r\n                    extensionCounts.put(extension, extensionCounts.getOrDefault(extension, 0) + 1);\r\n                } else {\r\n                    extensionCounts.put(\"(no extension)\", extensionCounts.getOrDefault(\"(no extension)\", 0) + 1);\r\n                }\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "repository",
          "parameters": [
            {
              "type": "date",
              "name": "of"
            }
          ],
          "body": "{\r\n        Repository repository \u003d git.getRepository();\r\n\r\n        try (RevWalk revWalk \u003d new RevWalk(repository)) {\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Date",
          "methodName": "getRepositoryCreationDate",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Repository repository \u003d git.getRepository();\r\n\r\n        try (RevWalk revWalk \u003d new RevWalk(repository)) {\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }",
          "javadoc": {
            "description": "Get the creation date of the repository (date of the first commit).\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "The creation date or null if no commits exist"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "RevWalk",
          "parameters": [],
          "body": "{\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }",
          "javadoc": {
            "description": "Get the creation date of the repository (date of the first commit).\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "The creation date or null if no commits exist"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "findGitRepositories",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            }
          ],
          "body": "{\r\n        List\u003cFile\u003e repositories \u003d new ArrayList\u003c\u003e();\r\n        findGitRepositoriesRecursive(directory, repositories);\r\n        return repositories;\r\n    }",
          "javadoc": {
            "description": "Find all Git repositories in a directory and its subdirectories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "return",
                "value": "List of Git repository directories"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "findGitRepositoriesRecursive",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "List\u003cFile\u003e",
              "name": "repositories"
            }
          ],
          "body": "{\r\n        File[] files \u003d directory.listFiles();\r\n        if (files !\u003d null) {\r\n            for (File file : files) {\r\n                if (file.isDirectory()) {\r\n                    if (file.getName().equals(\".git\")) {\r\n                        repositories.add(directory);\r\n                    } else if (!file.getName().equals(\".git\")) {\r\n                        findGitRepositoriesRecursive(file, repositories);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Recursive helper method to find all Git repositories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory    The directory to search"
              },
              {
                "name": "param",
                "value": "repositories List to collect Git repository directories"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                        findGitRepositoriesRecursive(file, repositories);\r\n                    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "CommitInfo",
          "methodName": "getCommitInfo",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "commitId"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            try (RevWalk revWalk \u003d new RevWalk(repository)) {\r\n                ObjectId objectId \u003d repository.resolve(commitId);\r\n                if (objectId \u003d\u003d null) {\r\n                    return null;\r\n                }\r\n\r\n                RevCommit commit \u003d revWalk.parseCommit(objectId);\r\n                return convertToCommitInfo(commit, repository);\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get specific information about a commit.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "commitId The commit ID"
              },
              {
                "name": "return",
                "value": "CommitInfo object containing commit information"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get specific information about a commit.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "commitId The commit ID"
              },
              {
                "name": "return",
                "value": "CommitInfo object containing commit information"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "RevWalk",
          "parameters": [],
          "body": "{\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "convertToCommitInfo",
          "parameters": [],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().setMaxCount(maxCount).call();\r\n            List\u003cCommitInfo\u003e commitInfos \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                commitInfos.add(convertToCommitInfo(commit, repository));\r\n            }\r\n\r\n            return commitInfos;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getRecentCommits",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "int",
              "name": "maxCount"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().setMaxCount(maxCount).call();\r\n            List\u003cCommitInfo\u003e commitInfos \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                commitInfos.add(convertToCommitInfo(commit, repository));\r\n            }\r\n\r\n            return commitInfos;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get a list of recent commits.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "maxCount The maximum number of commits to retrieve"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get a list of recent commits.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "maxCount The maximum number of commits to retrieve"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getAllCommits",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e commitInfos \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                commitInfos.add(convertToCommitInfo(commit, repository));\r\n            }\r\n\r\n            return commitInfos;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get a list of all commits in a repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for all commits"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get a list of all commits in a repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for all commits"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getCommitsByAuthor",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "authorName"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e authorCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n                if (author.getName().contains(authorName) || author.getEmailAddress().contains(authorName)) {\r\n                    authorCommits.add(convertToCommitInfo(commit, repository));\r\n                }\r\n            }\r\n\r\n            return authorCommits;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get commits by a specific author.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "authorName The name or email of the author"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for commits by the author"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Start",
          "methodName": "date",
          "parameters": [],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e dateRangeCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.equals(since) || commitDate.after(since)) \u0026\u0026\r\n                        (commitDate.equals(until) || commitDate.before(until))) {\r\n                    dateRangeCommits.add(convertToCommitInfo(commit, repository));\r\n                }\r\n            }\r\n\r\n            return dateRangeCommits;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "End",
          "methodName": "date",
          "parameters": [],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e dateRangeCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.equals(since) || commitDate.after(since)) \u0026\u0026\r\n                        (commitDate.equals(until) || commitDate.before(until))) {\r\n                    dateRangeCommits.add(convertToCommitInfo(commit, repository));\r\n                }\r\n            }\r\n\r\n            return dateRangeCommits;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getCommitsByDateRange",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "Date",
              "name": "since"
            },
            {
              "type": "Date",
              "name": "until"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e dateRangeCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.equals(since) || commitDate.after(since)) \u0026\u0026\r\n                        (commitDate.equals(until) || commitDate.before(until))) {\r\n                    dateRangeCommits.add(convertToCommitInfo(commit, repository));\r\n                }\r\n            }\r\n\r\n            return dateRangeCommits;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get commits within a date range.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "since Start date (inclusive)"
              },
              {
                "name": "param",
                "value": "until End date (inclusive)"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for commits within the date range"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getFileHistory",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "filePath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().addPath(filePath).call();\r\n            List\u003cCommitInfo\u003e fileCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                fileCommits.add(convertToCommitInfo(commit, repository));\r\n            }\r\n\r\n            return fileCommits;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get the history of a specific file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "filePath The path to the file within the repository"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for commits that changed the file"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getFileBlame",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "filePath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            BlameResult blameResult \u003d git.blame()\r\n                    .setFilePath(filePath)\r\n                    .call();\r\n\r\n            StringBuilder result \u003d new StringBuilder();\r\n\r\n            int lineCount \u003d blameResult.getResultContents().size();\r\n            for (int i \u003d 0; i \u003c lineCount; i++) {\r\n                RevCommit commit \u003d blameResult.getSourceCommit(i);\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n                String shortCommitId \u003d commit.getName().substring(0, 7);\r\n                String line \u003d blameResult.getResultContents().getString(i);\r\n\r\n                result.append(String.format(\"%s (%s - %s): %s\\n\",\r\n                        shortCommitId,\r\n                        author.getName(),\r\n                        new SimpleDateFormat(\"yyyy-MM-dd\").format(author.getWhen()),\r\n                        line));\r\n            }\r\n\r\n            return result.toString();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get blame information for a specific file, showing who last modified each line.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "filePath The path to the file within the repository"
              },
              {
                "name": "return",
                "value": "String representing blame information"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StringBuilder",
          "parameters": [],
          "body": "{\r\n                RevCommit commit \u003d blameResult.getSourceCommit(i);\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n                String shortCommitId \u003d commit.getName().substring(0, 7);\r\n                String line \u003d blameResult.getResultContents().getString(i);\r\n\r\n                result.append(String.format(\"%s (%s - %s): %s\\n\",\r\n                        shortCommitId,\r\n                        author.getName(),\r\n                        new SimpleDateFormat(\"yyyy-MM-dd\").format(author.getWhen()),\r\n                        line));\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            ObjectId oldId \u003d repository.resolve(oldCommitId);\r\n            ObjectId newId \u003d repository.resolve(newCommitId);\r\n\r\n            if (oldId \u003d\u003d null || newId \u003d\u003d null) {\r\n                return \"Invalid commit IDs\";\r\n            }\r\n\r\n            ByteArrayOutputStream outputStream \u003d new ByteArrayOutputStream();\r\n            try (DiffFormatter formatter \u003d new DiffFormatter(outputStream)) {\r\n                formatter.setRepository(repository);\r\n\r\n                RevCommit oldCommit \u003d repository.parseCommit(oldId);\r\n                RevCommit newCommit \u003d repository.parseCommit(newId);\r\n\r\n                AbstractTreeIterator oldTreeIterator \u003d getCanonicalTreeParser(repository, oldCommit);\r\n                AbstractTreeIterator newTreeIterator \u003d getCanonicalTreeParser(repository, newCommit);\r\n\r\n                List\u003cDiffEntry\u003e diffs \u003d git.diff()\r\n                        .setOldTree(oldTreeIterator)\r\n                        .setNewTree(newTreeIterator)\r\n                        .call();\r\n\r\n                for (DiffEntry diff : diffs) {\r\n                    formatter.format(diff);\r\n                    formatter.flush();\r\n                }\r\n\r\n                return new String(outputStream.toByteArray(), StandardCharsets.UTF_8);\r\n            }\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getDiffBetweenCommits",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "oldCommitId"
            },
            {
              "type": "String",
              "name": "newCommitId"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            ObjectId oldId \u003d repository.resolve(oldCommitId);\r\n            ObjectId newId \u003d repository.resolve(newCommitId);\r\n\r\n            if (oldId \u003d\u003d null || newId \u003d\u003d null) {\r\n                return \"Invalid commit IDs\";\r\n            }\r\n\r\n            ByteArrayOutputStream outputStream \u003d new ByteArrayOutputStream();\r\n            try (DiffFormatter formatter \u003d new DiffFormatter(outputStream)) {\r\n                formatter.setRepository(repository);\r\n\r\n                RevCommit oldCommit \u003d repository.parseCommit(oldId);\r\n                RevCommit newCommit \u003d repository.parseCommit(newId);\r\n\r\n                AbstractTreeIterator oldTreeIterator \u003d getCanonicalTreeParser(repository, oldCommit);\r\n                AbstractTreeIterator newTreeIterator \u003d getCanonicalTreeParser(repository, newCommit);\r\n\r\n                List\u003cDiffEntry\u003e diffs \u003d git.diff()\r\n                        .setOldTree(oldTreeIterator)\r\n                        .setNewTree(newTreeIterator)\r\n                        .call();\r\n\r\n                for (DiffEntry diff : diffs) {\r\n                    formatter.format(diff);\r\n                    formatter.flush();\r\n                }\r\n\r\n                return new String(outputStream.toByteArray(), StandardCharsets.UTF_8);\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get diff between two commits.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "oldCommitId The ID of the old commit"
              },
              {
                "name": "param",
                "value": "newCommitId The ID of the new commit"
              },
              {
                "name": "return",
                "value": "String representing the diff"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ByteArrayOutputStream",
          "parameters": [],
          "body": "{\r\n                formatter.setRepository(repository);\r\n\r\n                RevCommit oldCommit \u003d repository.parseCommit(oldId);\r\n                RevCommit newCommit \u003d repository.parseCommit(newId);\r\n\r\n                AbstractTreeIterator oldTreeIterator \u003d getCanonicalTreeParser(repository, oldCommit);\r\n                AbstractTreeIterator newTreeIterator \u003d getCanonicalTreeParser(repository, newCommit);\r\n\r\n                List\u003cDiffEntry\u003e diffs \u003d git.diff()\r\n                        .setOldTree(oldTreeIterator)\r\n                        .setNewTree(newTreeIterator)\r\n                        .call();\r\n\r\n                for (DiffEntry diff : diffs) {\r\n                    formatter.format(diff);\r\n                    formatter.flush();\r\n                }\r\n\r\n                return new String(outputStream.toByteArray(), StandardCharsets.UTF_8);\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "DiffFormatter",
          "parameters": [],
          "body": "{\r\n                formatter.setRepository(repository);\r\n\r\n                RevCommit oldCommit \u003d repository.parseCommit(oldId);\r\n                RevCommit newCommit \u003d repository.parseCommit(newId);\r\n\r\n                AbstractTreeIterator oldTreeIterator \u003d getCanonicalTreeParser(repository, oldCommit);\r\n                AbstractTreeIterator newTreeIterator \u003d getCanonicalTreeParser(repository, newCommit);\r\n\r\n                List\u003cDiffEntry\u003e diffs \u003d git.diff()\r\n                        .setOldTree(oldTreeIterator)\r\n                        .setNewTree(newTreeIterator)\r\n                        .call();\r\n\r\n                for (DiffEntry diff : diffs) {\r\n                    formatter.format(diff);\r\n                    formatter.flush();\r\n                }\r\n\r\n                return new String(outputStream.toByteArray(), StandardCharsets.UTF_8);\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "String",
          "parameters": [],
          "body": "{\r\n        try (RevWalk walk \u003d new RevWalk(repository)) {\r\n            RevCommit commitTree \u003d walk.parseCommit(commit.getId());\r\n            try (ObjectReader reader \u003d repository.newObjectReader()) {\r\n                CanonicalTreeParser treeParser \u003d new CanonicalTreeParser();\r\n                treeParser.reset(reader, commitTree.getTree().getId());\r\n                return treeParser;\r\n            }\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "AbstractTreeIterator",
          "methodName": "getCanonicalTreeParser",
          "parameters": [
            {
              "type": "Repository",
              "name": "repository"
            },
            {
              "type": "RevCommit",
              "name": "commit"
            }
          ],
          "body": "{\r\n        try (RevWalk walk \u003d new RevWalk(repository)) {\r\n            RevCommit commitTree \u003d walk.parseCommit(commit.getId());\r\n            try (ObjectReader reader \u003d repository.newObjectReader()) {\r\n                CanonicalTreeParser treeParser \u003d new CanonicalTreeParser();\r\n                treeParser.reset(reader, commitTree.getTree().getId());\r\n                return treeParser;\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to get a tree parser for a commit.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "RevWalk",
          "parameters": [],
          "body": "{\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }",
          "javadoc": {
            "description": "Helper method to get a tree parser for a commit.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "CanonicalTreeParser",
          "parameters": [],
          "body": "{\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }",
          "javadoc": {
            "description": "Helper method to get a tree parser for a commit.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Integer\u003e",
          "methodName": "getContributionsByDayOfWeek",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            // Initialize days of week map\r\n            Map\u003cString, Integer\u003e daysOfWeek \u003d new LinkedHashMap\u003c\u003e();\r\n            daysOfWeek.put(\"Monday\", 0);\r\n            daysOfWeek.put(\"Tuesday\", 0);\r\n            daysOfWeek.put(\"Wednesday\", 0);\r\n            daysOfWeek.put(\"Thursday\", 0);\r\n            daysOfWeek.put(\"Friday\", 0);\r\n            daysOfWeek.put(\"Saturday\", 0);\r\n            daysOfWeek.put(\"Sunday\", 0);\r\n\r\n            // Get all commits\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            SimpleDateFormat dayFormat \u003d new SimpleDateFormat(\"EEEE\");\r\n\r\n            // Count commits by day of week\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                String dayOfWeek \u003d dayFormat.format(commitDate);\r\n                daysOfWeek.put(dayOfWeek, daysOfWeek.get(dayOfWeek) + 1);\r\n            }\r\n\r\n            return daysOfWeek;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get a summary of contributions by day of week.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "Map with days of week as keys and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get a summary of contributions by day of week.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "Map with days of week as keys and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": [
            "Initialize days of week map"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String dayOfWeek \u003d dayFormat.format(commitDate);\r\n            commitsPerDayOfWeek.put(dayOfWeek, commitsPerDayOfWeek.get(dayOfWeek) + 1);\r\n        }",
          "comments": [
            "Get all commits",
            "Count commits by day of week"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "week",
          "methodName": "for",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            }
          ],
          "body": "{\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                String dayOfWeek \u003d dayFormat.format(commitDate);\r\n                daysOfWeek.put(dayOfWeek, daysOfWeek.get(dayOfWeek) + 1);\r\n            }",
          "comments": [
            "Get all commits",
            "Count commits by day of week"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cInteger, Integer\u003e",
          "methodName": "getContributionsByHourOfDay",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            // Initialize hours map (0-23)\r\n            Map\u003cInteger, Integer\u003e hourMap \u003d new LinkedHashMap\u003c\u003e();\r\n            for (int i \u003d 0; i \u003c 24; i++) {\r\n                hourMap.put(i, 0);\r\n            }\r\n\r\n            // Get all commits\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            Calendar calendar \u003d Calendar.getInstance();\r\n\r\n            // Count commits by hour\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                calendar.setTime(commitDate);\r\n                int hour \u003d calendar.get(Calendar.HOUR_OF_DAY);\r\n                hourMap.put(hour, hourMap.get(hour) + 1);\r\n            }\r\n\r\n            return hourMap;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get a summary of contributions by hour of day.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "Map with hours as keys and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get a summary of contributions by hour of day.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "Map with hours as keys and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": [
            "Initialize hours map (0-23)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "hours",
          "methodName": "map",
          "parameters": [],
          "body": "{\r\n                hourMap.put(i, 0);\r\n            }",
          "comments": [
            "Initialize hours map (0-23)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "hour",
          "methodName": "for",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            }
          ],
          "body": "{\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                calendar.setTime(commitDate);\r\n                int hour \u003d calendar.get(Calendar.HOUR_OF_DAY);\r\n                hourMap.put(hour, hourMap.get(hour) + 1);\r\n            }",
          "comments": [
            "Get all commits",
            "Count commits by hour"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "as",
          "methodName": "keys",
          "parameters": [
            {
              "type": "format:",
              "name": "yyyy-MM-dd"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            // Create a calendar for the requested year\r\n            Calendar startCalendar \u003d Calendar.getInstance();\r\n            startCalendar.set(year, Calendar.JANUARY, 1, 0, 0, 0);\r\n            Date startDate \u003d startCalendar.getTime();\r\n\r\n            Calendar endCalendar \u003d Calendar.getInstance();\r\n            endCalendar.set(year, Calendar.DECEMBER, 31, 23, 59, 59);\r\n            Date endDate \u003d endCalendar.getTime();\r\n\r\n            // Initialize heat map\r\n            Map\u003cString, Integer\u003e heatMap \u003d new LinkedHashMap\u003c\u003e();\r\n            SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd\");\r\n\r\n            // Initialize all days of the year with zero counts\r\n            Calendar calendar \u003d Calendar.getInstance();\r\n            calendar.setTime(startDate);\r\n            while (calendar.getTime().before(endDate) || calendar.getTime().equals(endDate)) {\r\n                heatMap.put(dateFormat.format(calendar.getTime()), 0);\r\n                calendar.add(Calendar.DAY_OF_YEAR, 1);\r\n            }\r\n\r\n            // Get commits for the year\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n            // Count commits by day\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.after(startDate) || commitDate.equals(startDate)) \u0026\u0026\r\n                        (commitDate.before(endDate) || commitDate.equals(endDate))) {\r\n\r\n                    String dateStr \u003d dateFormat.format(commitDate);\r\n                    if (heatMap.containsKey(dateStr)) {\r\n                        heatMap.put(dateStr, heatMap.get(dateStr) + 1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return heatMap;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Integer\u003e",
          "methodName": "getContributionHeatMap",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "int",
              "name": "year"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            // Create a calendar for the requested year\r\n            Calendar startCalendar \u003d Calendar.getInstance();\r\n            startCalendar.set(year, Calendar.JANUARY, 1, 0, 0, 0);\r\n            Date startDate \u003d startCalendar.getTime();\r\n\r\n            Calendar endCalendar \u003d Calendar.getInstance();\r\n            endCalendar.set(year, Calendar.DECEMBER, 31, 23, 59, 59);\r\n            Date endDate \u003d endCalendar.getTime();\r\n\r\n            // Initialize heat map\r\n            Map\u003cString, Integer\u003e heatMap \u003d new LinkedHashMap\u003c\u003e();\r\n            SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd\");\r\n\r\n            // Initialize all days of the year with zero counts\r\n            Calendar calendar \u003d Calendar.getInstance();\r\n            calendar.setTime(startDate);\r\n            while (calendar.getTime().before(endDate) || calendar.getTime().equals(endDate)) {\r\n                heatMap.put(dateFormat.format(calendar.getTime()), 0);\r\n                calendar.add(Calendar.DAY_OF_YEAR, 1);\r\n            }\r\n\r\n            // Get commits for the year\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n            // Count commits by day\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.after(startDate) || commitDate.equals(startDate)) \u0026\u0026\r\n                        (commitDate.before(endDate) || commitDate.equals(endDate))) {\r\n\r\n                    String dateStr \u003d dateFormat.format(commitDate);\r\n                    if (heatMap.containsKey(dateStr)) {\r\n                        heatMap.put(dateStr, heatMap.get(dateStr) + 1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return heatMap;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Generate a monthly contribution heat map.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "year The year to analyze"
              },
              {
                "name": "return",
                "value": "Map with days as keys (format: yyyy-MM-dd) and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": [
            "Create a calendar for the requested year"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            ObjectId oldId \u003d repository.resolve(oldCommitId);\r\n            ObjectId newId \u003d repository.resolve(newCommitId);\r\n\r\n            if (oldId \u003d\u003d null || newId \u003d\u003d null) {\r\n                return \"Invalid commit IDs\";\r\n            }\r\n\r\n            ByteArrayOutputStream outputStream \u003d new ByteArrayOutputStream();\r\n            try (DiffFormatter formatter \u003d new DiffFormatter(outputStream)) {\r\n                formatter.setRepository(repository);\r\n\r\n                RevCommit oldCommit \u003d repository.parseCommit(oldId);\r\n                RevCommit newCommit \u003d repository.parseCommit(newId);\r\n\r\n                AbstractTreeIterator oldTreeIterator \u003d getCanonicalTreeParser(repository, oldCommit);\r\n                AbstractTreeIterator newTreeIterator \u003d getCanonicalTreeParser(repository, newCommit);\r\n\r\n                List\u003cDiffEntry\u003e diffs \u003d git.diff()\r\n                        .setOldTree(oldTreeIterator)\r\n                        .setNewTree(newTreeIterator)\r\n                        .call();\r\n\r\n                for (DiffEntry diff : diffs) {\r\n                    formatter.format(diff);\r\n                    formatter.flush();\r\n                }\r\n\r\n                return new String(outputStream.toByteArray(), StandardCharsets.UTF_8);\r\n            }\r\n        }\r\n    }",
          "comments": [
            "Initialize heat map",
            "Initialize all days of the year with zero cou"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "day",
          "methodName": "for",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            }
          ],
          "body": "{\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.after(startDate) || commitDate.equals(startDate)) \u0026\u0026\r\n                        (commitDate.before(endDate) || commitDate.equals(endDate))) {\r\n\r\n                    String dateStr \u003d dateFormat.format(commitDate);\r\n                    if (heatMap.containsKey(dateStr)) {\r\n                        heatMap.put(dateStr, heatMap.get(dateStr) + 1);\r\n                    }\r\n                }\r\n            }",
          "comments": [
            "Get commits for the year",
            "Count commits by day"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "repository",
          "parameters": [
            {
              "type": "most",
              "name": "frequently"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get all commits\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n            // Count changes by file path\r\n            Map\u003cString, Integer\u003e fileChangeCounts \u003d new HashMap\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                if (commit.getParentCount() \u003e 0) {\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n                    for (FileChange change : changes) {\r\n                        String path \u003d change.getPath();\r\n                        if (path !\u003d null \u0026\u0026 !path.equals(\"/dev/null\")) {\r\n                            fileChangeCounts.put(path, fileChangeCounts.getOrDefault(path, 0) + 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Sort files by change count and limit results\r\n            return fileChangeCounts.entrySet().stream()\r\n                    .sorted(Map.Entry.\u003cString, Integer\u003ecomparingByValue().reversed())\r\n                    .limit(limit)\r\n                    .collect(Collectors.toMap(\r\n                            Map.Entry::getKey,\r\n                            Map.Entry::getValue,\r\n                            (e1, e2) -\u003e e1,\r\n                            LinkedHashMap::new\r\n                    ));\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Integer\u003e",
          "methodName": "getMostActiveFiles",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "int",
              "name": "limit"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get all commits\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n            // Count changes by file path\r\n            Map\u003cString, Integer\u003e fileChangeCounts \u003d new HashMap\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                if (commit.getParentCount() \u003e 0) {\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n                    for (FileChange change : changes) {\r\n                        String path \u003d change.getPath();\r\n                        if (path !\u003d null \u0026\u0026 !path.equals(\"/dev/null\")) {\r\n                            fileChangeCounts.put(path, fileChangeCounts.getOrDefault(path, 0) + 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Sort files by change count and limit results\r\n            return fileChangeCounts.entrySet().stream()\r\n                    .sorted(Map.Entry.\u003cString, Integer\u003ecomparingByValue().reversed())\r\n                    .limit(limit)\r\n                    .collect(Collectors.toMap(\r\n                            Map.Entry::getKey,\r\n                            Map.Entry::getValue,\r\n                            (e1, e2) -\u003e e1,\r\n                            LinkedHashMap::new\r\n                    ));\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get the most active files in the repository (most frequently changed).\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "limit Maximum number of files to return"
              },
              {
                "name": "return",
                "value": "Map with file paths as keys and change counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": [
            "G"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getFormattedCommitLog",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "int",
              "name": "maxCount"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().setMaxCount(maxCount).call();\r\n            StringBuilder log \u003d new StringBuilder();\r\n            SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n            for (RevCommit commit : commits) {\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n\r\n                log.append(\"Commit: \").append(commit.getName()).append(\"\\n\");\r\n                log.append(\"Author: \").append(author.getName())\r\n                        .append(\" \u003c\").append(author.getEmailAddress()).append(\"\u003e\\n\");\r\n                log.append(\"Date:   \").append(dateFormat.format(author.getWhen())).append(\"\\n\\n\");\r\n                log.append(\"    \").append(commit.getFullMessage().replace(\"\\n\", \"\\n    \")).append(\"\\n\\n\");\r\n\r\n                // Add file changes if not the first commit\r\n                if (commit.getParentCount() \u003e 0) {\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n\r\n                    if (!changes.isEmpty()) {\r\n                        log.append(\"    Changed files:\\n\");\r\n                        for (FileChange change : changes) {\r\n                            String prefix \u003d \"\";\r\n                            switch (change.getType()) {\r\n                                case ADD:\r\n                                    prefix \u003d \"A\";\r\n                                    break;\r\n                                case MODIFY:\r\n                                    prefix \u003d \"M\";\r\n                                    break;\r\n                                case DELETE:\r\n                                    prefix \u003d \"D\";\r\n                                    break;\r\n                                case RENAME:\r\n                                    prefix \u003d \"R\";\r\n                                    break;\r\n                                case COPY:\r\n                                    prefix \u003d \"C\";\r\n                                    break;\r\n                            }\r\n\r\n                            log.append(\"      \").append(prefix).append(\" \").append(change.getPath()).append(\"\\n\");\r\n                        }\r\n                        log.append(\"\\n\");\r\n                    }\r\n                }\r\n\r\n                log.append(\"-------------------------------------------------------------------------------\\n\\n\");\r\n            }\r\n\r\n            return log.toString();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Generate a commit log in a readable format.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "maxCount Maximum number of commits to include"
              },
              {
                "name": "return",
                "value": "String representing the commit log"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StringBuilder",
          "parameters": [],
          "body": "{\r\n                RevCommit commit \u003d blameResult.getSourceCommit(i);\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n                String shortCommitId \u003d commit.getName().substring(0, 7);\r\n                String line \u003d blameResult.getResultContents().getString(i);\r\n\r\n                result.append(String.format(\"%s (%s - %s): %s\\n\",\r\n                        shortCommitId,\r\n                        author.getName(),\r\n                        new SimpleDateFormat(\"yyyy-MM-dd\").format(author.getWhen()),\r\n                        line));\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [
            {
              "type": "\"yyyy-MM-dd",
              "name": "HH:mm:ss\""
            }
          ],
          "body": "{\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n\r\n                log.append(\"Commit: \").append(commit.getName()).append(\"\\n\");\r\n                log.append(\"Author: \").append(author.getName())\r\n                        .append(\" \u003c\").append(author.getEmailAddress()).append(\"\u003e\\n\");\r\n                log.append(\"Date:   \").append(dateFormat.format(author.getWhen())).append(\"\\n\\n\");\r\n                log.append(\"    \").append(commit.getFullMessage().replace(\"\\n\", \"\\n    \")).append(\"\\n\\n\");\r\n\r\n                // Add file changes if not the first commit\r\n                if (commit.getParentCount() \u003e 0) {\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n\r\n                    if (!changes.isEmpty()) {\r\n                        log.append(\"    Changed files:\\n\");\r\n                        for (FileChange change : changes) {\r\n                            String prefix \u003d \"\";\r\n                            switch (change.getType()) {\r\n                                case ADD:\r\n                                    prefix \u003d \"A\";\r\n                                    break;\r\n                                case MODIFY:\r\n                                    prefix \u003d \"M\";\r\n                                    break;\r\n                                case DELETE:\r\n                                    prefix \u003d \"D\";\r\n                                    break;\r\n                                case RENAME:\r\n                                    prefix \u003d \"R\";\r\n                                    break;\r\n                                case COPY:\r\n                                    prefix \u003d \"C\";\r\n                                    break;\r\n                            }\r\n\r\n                            log.append(\"      \").append(prefix).append(\" \").append(change.getPath()).append(\"\\n\");\r\n                        }\r\n                        log.append(\"\\n\");\r\n                    }\r\n                }\r\n\r\n                log.append(\"-------------------------------------------------------------------------------\\n\\n\");\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "commit",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n\r\n                    if (!changes.isEmpty()) {\r\n                        log.append(\"    Changed files:\\n\");\r\n                        for (FileChange change : changes) {\r\n                            String prefix \u003d \"\";\r\n                            switch (change.getType()) {\r\n                                case ADD:\r\n                                    prefix \u003d \"A\";\r\n                                    break;\r\n                                case MODIFY:\r\n                                    prefix \u003d \"M\";\r\n                                    break;\r\n                                case DELETE:\r\n                                    prefix \u003d \"D\";\r\n                                    break;\r\n                                case RENAME:\r\n                                    prefix \u003d \"R\";\r\n                                    break;\r\n                                case COPY:\r\n                                    prefix \u003d \"C\";\r\n                                    break;\r\n                            }\r\n\r\n                            log.append(\"      \").append(prefix).append(\" \").append(change.getPath()).append(\"\\n\");\r\n                        }\r\n                        log.append(\"\\n\");\r\n                    }\r\n                }",
          "comments": [
            "Add file changes if not the first commit"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "isValidRepository",
          "parameters": [
            {
              "type": "String",
              "name": "path"
            }
          ],
          "body": "{\r\n        File gitDir \u003d new File(path);\r\n        try {\r\n            FileRepositoryBuilder builder \u003d new FileRepositoryBuilder()\r\n                    .setGitDir(new File(gitDir, \".git\"))\r\n                    .readEnvironment()\r\n                    .findGitDir();\r\n\r\n            if (builder.getGitDir() \u003d\u003d null) {\r\n                return false;\r\n            }\r\n\r\n            try (Repository repository \u003d builder.build()) {\r\n                return repository.getObjectDatabase().exists();\r\n            }\r\n        } catch (IOException e) {\r\n            return false;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Check if a path is a valid Git repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to check"
              },
              {
                "name": "return",
                "value": "true if the path is a valid Git repository, false otherwise"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            FileRepositoryBuilder builder \u003d new FileRepositoryBuilder()\r\n                    .setGitDir(new File(gitDir, \".git\"))\r\n                    .readEnvironment()\r\n                    .findGitDir();\r\n\r\n            if (builder.getGitDir() \u003d\u003d null) {\r\n                return false;\r\n            }\r\n\r\n            try (Repository repository \u003d builder.build()) {\r\n                return repository.getObjectDatabase().exists();\r\n            }\r\n        }",
          "javadoc": {
            "description": "Check if a path is a valid Git repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to check"
              },
              {
                "name": "return",
                "value": "true if the path is a valid Git repository, false otherwise"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "FileRepositoryBuilder",
          "parameters": [],
          "body": "{\r\n                return false;\r\n            }",
          "javadoc": {
            "description": "Check if a path is a valid Git repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to check"
              },
              {
                "name": "return",
                "value": "true if the path is a valid Git repository, false otherwise"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                return false;\r\n            }",
          "javadoc": {
            "description": "Check if a path is a valid Git repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to check"
              },
              {
                "name": "return",
                "value": "true if the path is a valid Git repository, false otherwise"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "listFilesRespectingGitignore",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n        Path dirPath \u003d Paths.get(directory);\r\n        File gitignoreFile \u003d new File(directory, \".gitignore\");\r\n\r\n        // List to store ignore patterns\r\n        List\u003cString\u003e ignorePatterns \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Load .gitignore patterns if the file exists\r\n        if (gitignoreFile.exists() \u0026\u0026 gitignoreFile.isFile()) {\r\n            try {\r\n                List\u003cString\u003e lines \u003d Files.readAllLines(gitignoreFile.toPath(), StandardCharsets.UTF_8);\r\n                for (String line : lines) {\r\n                    // Skip empty lines and comments\r\n                    if (line.trim().isEmpty() || line.startsWith(\"#\")) {\r\n                        continue;\r\n                    }\r\n                    ignorePatterns.add(line.trim());\r\n                }\r\n            } catch (IOException e) {\r\n                // If there\u0027s an error reading .gitignore, log it but continue without ignore rules\r\n                System.err.println(\"Error reading .gitignore file: \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        List\u003cFile\u003e result \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Walk the directory tree\r\n        try (Stream\u003cPath\u003e paths \u003d Files.walk(dirPath)) {\r\n            paths.filter(Files::isRegularFile)\r\n                 .forEach(path -\u003e {\r\n                     // Get the relative path from the base directory\r\n                     Path relativePath \u003d dirPath.relativize(path);\r\n                     String pathStr \u003d relativePath.toString().replace(\u0027\\\\\u0027, \u0027/\u0027);\r\n\r\n                     // Check if the file matches any ignore pattern\r\n                     boolean isIgnored \u003d false;\r\n                     for (String pattern : ignorePatterns) {\r\n                         if (matchesGitignorePattern(pathStr, pattern)) {\r\n                             isIgnored \u003d true;\r\n                             break;\r\n                         }\r\n                     }\r\n\r\n                     // Add the file to the result if it\u0027s not ignored\r\n                     if (!isIgnored) {\r\n                         result.add(path.toFile());\r\n                     }\r\n                 });\r\n        }\r\n\r\n        return result;\r\n    }",
          "javadoc": {
            "description": "List all files in a directory, respecting .gitignore rules if present.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to list files from"
              },
              {
                "name": "return",
                "value": "List of files, excluding those matched by .gitignore rules"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            try {\r\n                List\u003cString\u003e lines \u003d Files.readAllLines(gitignoreFile.toPath(), StandardCharsets.UTF_8);\r\n                for (String line : lines) {\r\n                    // Skip empty lines and comments\r\n                    if (line.trim().isEmpty() || line.startsWith(\"#\")) {\r\n                        continue;\r\n                    }\r\n                    ignorePatterns.add(line.trim());\r\n                }\r\n            } catch (IOException e) {\r\n                // If there\u0027s an error reading .gitignore, log it but continue without ignore rules\r\n                System.err.println(\"Error reading .gitignore file: \" + e.getMessage());\r\n            }\r\n        }",
          "javadoc": {
            "description": "List all files in a directory, respecting .gitignore rules if present.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to list files from"
              },
              {
                "name": "return",
                "value": "List of files, excluding those matched by .gitignore rules"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": [
            "List to store ignore patterns"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "exists",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            try {\r\n                List\u003cString\u003e lines \u003d Files.readAllLines(gitignoreFile.toPath(), StandardCharsets.UTF_8);\r\n                for (String line : lines) {\r\n                    // Skip empty lines and comments\r\n                    if (line.trim().isEmpty() || line.startsWith(\"#\")) {\r\n                        continue;\r\n                    }\r\n                    ignorePatterns.add(line.trim());\r\n                }\r\n            } catch (IOException e) {\r\n                // If there\u0027s an error reading .gitignore, log it but continue without ignore rules\r\n                System.err.println(\"Error reading .gitignore file: \" + e.getMessage());\r\n            }\r\n        }",
          "comments": [
            "List to store ignore patterns",
            "Load .gitignore patterns if the file exists"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "comments",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                        continue;\r\n                    }",
          "comments": [
            "Skip empty lines and comments"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "tree",
          "methodName": "try",
          "parameters": [
            {
              "type": "Stream\u003cPath\u003e",
              "name": "paths"
            }
          ],
          "body": "{\r\n            paths.filter(Files::isRegularFile)\r\n                 .forEach(path -\u003e {\r\n                     // Get the relative path from the base directory\r\n                     Path relativePath \u003d dirPath.relativize(path);\r\n                     String pathStr \u003d relativePath.toString().replace(\u0027\\\\\u0027, \u0027/\u0027);\r\n\r\n                     // Check if the file matches any ignore pattern\r\n                     boolean isIgnored \u003d false;\r\n                     for (String pattern : ignorePatterns) {\r\n                         if (matchesGitignorePattern(pathStr, pattern)) {\r\n                             isIgnored \u003d true;\r\n                             break;\r\n                         }\r\n                     }\r\n\r\n                     // Add the file to the result if it\u0027s not ignored\r\n                     if (!isIgnored) {\r\n                         result.add(path.toFile());\r\n                     }\r\n                 });\r\n        }",
          "comments": [
            "Walk the directory tree"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "ignored",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                         result.add(path.toFile());\r\n                     }",
          "comments": [
            "Add the file to the result if it\u0027s not ignored"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "matchesGitignorePattern",
          "parameters": [
            {
              "type": "String",
              "name": "path"
            },
            {
              "type": "String",
              "name": "pattern"
            }
          ],
          "body": "{\r\n        // Handle negation (patterns starting with !)\r\n        boolean negate \u003d pattern.startsWith(\"!\");\r\n        if (negate) {\r\n            pattern \u003d pattern.substring(1);\r\n        }\r\n\r\n        // Handle directory-only patterns (ending with /)\r\n        boolean dirOnly \u003d pattern.endsWith(\"/\");\r\n        if (dirOnly) {\r\n            pattern \u003d pattern.substring(0, pattern.length() - 1);\r\n        }\r\n\r\n        // Convert gitignore glob pattern to regex\r\n        pattern \u003d pattern\r\n            .replace(\".\", \"\\\\.\")   // Escape dots\r\n            .replace(\"*\", \".*\")    // * becomes .*\r\n            .replace(\"?\", \".\");    // ? becomes .\r\n\r\n        // Match the pattern against the path\r\n        boolean matches \u003d path.matches(pattern);\r\n\r\n        // Return the result, taking negation into account\r\n        return negate ? !matches : matches;\r\n    }",
          "javadoc": {
            "description": "Check if a file path matches a gitignore pattern.\r\nThis is a simplified implementation and doesn\u0027t handle all gitignore pattern features.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The file path to check"
              },
              {
                "name": "param",
                "value": "pattern The gitignore pattern"
              },
              {
                "name": "return",
                "value": "true if the path matches the pattern, false otherwise"
              }
            ]
          },
          "comments": [
            "Handle neg"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Handle",
          "methodName": "negation",
          "parameters": [
            {
              "type": "patterns",
              "name": "starting"
            }
          ],
          "body": "{\r\n            pattern \u003d pattern.substring(1);\r\n        }",
          "javadoc": {
            "description": "Check if a file path matches a gitignore pattern.\r\nThis is a simplified implementation and doesn\u0027t handle all gitignore pattern features.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The file path to check"
              },
              {
                "name": "param",
                "value": "pattern The gitignore pattern"
              },
              {
                "name": "return",
                "value": "true if the path matches the pattern, false otherwise"
              }
            ]
          },
          "comments": [
            "Handle negation (patterns starting with !)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "only",
          "methodName": "patterns",
          "parameters": [
            {
              "type": "ending",
              "name": "with"
            }
          ],
          "body": "{\r\n            pattern \u003d pattern.substring(0, pattern.length() - 1);\r\n        }",
          "comments": [
            "Handle directory-only patterns (ending with /)"
          ]
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/parsers/PomParser.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Maven",
          "methodName": "POM",
          "parameters": [],
          "body": "{\r\n\r\n    // Prevent instantiation\r\n    private PomParser() {\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }\r\n\r\n    /**\r\n     * Parse a POM file and extract its Maven Model.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return Model object representing the POM file\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static Model parsePom(File pomFile) throws IOException {\r\n        try (FileInputStream inputStream \u003d new FileInputStream(pomFile)) {\r\n            MavenStaxReader mavenReader \u003d new MavenStaxReader();\r\n            try {\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Error parsing POM file: \" + e.getMessage(), e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract project coordinates (groupId, artifactId, version) from a POM file.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return PomCoordinates object with the project coordinates\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static PomCoordinates extractCoordinates(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        String groupId \u003d model.getGroupId();\r\n        String artifactId \u003d model.getArtifactId();\r\n        String version \u003d model.getVersion();\r\n\r\n        // If coordinates are not directly specified, they might be inherited from parent\r\n        if (groupId \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }\r\n\r\n        if (version \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            version \u003d model.getParent().getVersion();\r\n        }\r\n\r\n        return PomCoordinates.builder()\r\n                .groupId(groupId)\r\n                .artifactId(artifactId)\r\n                .version(version)\r\n                .build();\r\n    }\r\n\r\n    /**\r\n     * Extract all dependencies from a POM file.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return List of Dependency objects\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static List\u003cDependency\u003e extractDependencies(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n        return model.getDependencies();\r\n    }\r\n\r\n    /**\r\n     * Extract parent POM information if available.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return Parent object or null if no parent exists\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static Parent extractParentInfo(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n        return model.getParent();\r\n    }\r\n\r\n    /**\r\n     * Extract build plugins from a POM file.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return List of Plugin objects or empty list if no plugins exist\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static List\u003cPlugin\u003e extractPlugins(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        if (model.getBuild() \u003d\u003d null || model.getBuild().getPlugins() \u003d\u003d null) {\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n\r\n        return model.getBuild().getPlugins();\r\n    }\r\n\r\n    /**\r\n     * Extract module names for multi-module projects.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return List of module names or empty list if not a multi-module project\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static List\u003cString\u003e extractModules(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        if (model \u003d\u003d null) {\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n\r\n        return model.getSubprojects();\r\n    }\r\n\r\n    /**\r\n     * Find all POM files in a directory and its subdirectories.\r\n     * \r\n     * @param directory The directory to search\r\n     * @return List of POM files\r\n     */\r\n    public static List\u003cFile\u003e findPomFiles(File directory) {\r\n        List\u003cFile\u003e pomFiles \u003d new ArrayList\u003c\u003e();\r\n        findPomFilesRecursive(directory, pomFiles);\r\n        return pomFiles;\r\n    }\r\n\r\n    /**\r\n     * Recursive helper method to find all POM files.\r\n     * \r\n     * @param directory The directory to search\r\n     * @param pomFiles List to collect POM files\r\n     */\r\n    private static void findPomFilesRecursive(File directory, List\u003cFile\u003e pomFiles) {\r\n        File[] files \u003d directory.listFiles();\r\n        if (files !\u003d null) {\r\n            for (File file : files) {\r\n                if (file.isDirectory()) {\r\n                    findPomFilesRecursive(file, pomFiles);\r\n                } else if (file.getName().equals(\"pom.xml\")) {\r\n                    pomFiles.add(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "PomParser",
          "parameters": [],
          "body": "{\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Maven POM (pom.xml) files using the official Maven Model API.\r\nThis class provides static methods to analyze Maven project files and extract structural information.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AssertionError",
          "parameters": [
            {
              "type": "\"Utility",
              "name": "class"
            }
          ],
          "body": "{\r\n        try (FileInputStream inputStream \u003d new FileInputStream(pomFile)) {\r\n            MavenStaxReader mavenReader \u003d new MavenStaxReader();\r\n            try {\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Error parsing POM file: \" + e.getMessage(), e);\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Maven POM (pom.xml) files using the official Maven Model API.\r\nThis class provides static methods to analyze Maven project files and extract structural information.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Model",
          "methodName": "parsePom",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        try (FileInputStream inputStream \u003d new FileInputStream(pomFile)) {\r\n            MavenStaxReader mavenReader \u003d new MavenStaxReader();\r\n            try {\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Error parsing POM file: \" + e.getMessage(), e);\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Parse a POM file and extract its Maven Model.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "Model object representing the POM file"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "FileInputStream",
          "parameters": [],
          "body": "{\r\n            MavenStaxReader mavenReader \u003d new MavenStaxReader();\r\n            try {\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Error parsing POM file: \" + e.getMessage(), e);\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse a POM file and extract its Maven Model.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "Model object representing the POM file"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "MavenStaxReader",
          "parameters": [],
          "body": "{\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            }",
          "javadoc": {
            "description": "Parse a POM file and extract its Maven Model.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "Model object representing the POM file"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": [
            "Use the MavenStaxReader to read the P"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "IOException",
          "parameters": [
            {
              "type": "\"Error",
              "name": "parsing"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        String groupId \u003d model.getGroupId();\r\n        String artifactId \u003d model.getArtifactId();\r\n        String version \u003d model.getVersion();\r\n\r\n        // If coordinates are not directly specified, they might be inherited from parent\r\n        if (groupId \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }\r\n\r\n        if (version \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            version \u003d model.getParent().getVersion();\r\n        }\r\n\r\n        return PomCoordinates.builder()\r\n                .groupId(groupId)\r\n                .artifactId(artifactId)\r\n                .version(version)\r\n                .build();\r\n    }",
          "comments": [
            "Return the model as is - no conversion needed"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "project",
          "methodName": "coordinates",
          "parameters": [],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        String groupId \u003d model.getGroupId();\r\n        String artifactId \u003d model.getArtifactId();\r\n        String version \u003d model.getVersion();\r\n\r\n        // If coordinates are not directly specified, they might be inherited from parent\r\n        if (groupId \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }\r\n\r\n        if (version \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            version \u003d model.getParent().getVersion();\r\n        }\r\n\r\n        return PomCoordinates.builder()\r\n                .groupId(groupId)\r\n                .artifactId(artifactId)\r\n                .version(version)\r\n                .build();\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "PomCoordinates",
          "methodName": "extractCoordinates",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        String groupId \u003d model.getGroupId();\r\n        String artifactId \u003d model.getArtifactId();\r\n        String version \u003d model.getVersion();\r\n\r\n        // If coordinates are not directly specified, they might be inherited from parent\r\n        if (groupId \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }\r\n\r\n        if (version \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            version \u003d model.getParent().getVersion();\r\n        }\r\n\r\n        return PomCoordinates.builder()\r\n                .groupId(groupId)\r\n                .artifactId(artifactId)\r\n                .version(version)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Extract project coordinates (groupId, artifactId, version) from a POM file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "PomCoordinates object with the project coordinates"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parent",
          "methodName": "if",
          "parameters": [
            {
              "type": "groupId",
              "name": "\u003d\u003d"
            }
          ],
          "body": "{\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }",
          "comments": [
            "If coordinates are not directly specified, they might be inherited from parent"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cDependency\u003e",
          "methodName": "extractDependencies",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n        return model.getDependencies();\r\n    }",
          "javadoc": {
            "description": "Extract all dependencies from a POM file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "List of Dependency objects"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Parent",
          "methodName": "extractParentInfo",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n        return model.getParent();\r\n    }",
          "javadoc": {
            "description": "Extract parent POM information if available.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "Parent object or null if no parent exists"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cPlugin\u003e",
          "methodName": "extractPlugins",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        if (model.getBuild() \u003d\u003d null || model.getBuild().getPlugins() \u003d\u003d null) {\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n\r\n        return model.getBuild().getPlugins();\r\n    }",
          "javadoc": {
            "description": "Extract build plugins from a POM file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "List of Plugin objects or empty list if no plugins exist"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cString\u003e",
          "methodName": "extractModules",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        if (model \u003d\u003d null) {\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n\r\n        return model.getSubprojects();\r\n    }",
          "javadoc": {
            "description": "Extract module names for multi-module projects.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "List of module names or empty list if not a multi-module project"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "findPomFiles",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            }
          ],
          "body": "{\r\n        List\u003cFile\u003e pomFiles \u003d new ArrayList\u003c\u003e();\r\n        findPomFilesRecursive(directory, pomFiles);\r\n        return pomFiles;\r\n    }",
          "javadoc": {
            "description": "Find all POM files in a directory and its subdirectories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "return",
                "value": "List of POM files"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "findPomFilesRecursive",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "List\u003cFile\u003e",
              "name": "pomFiles"
            }
          ],
          "body": "{\r\n        File[] files \u003d directory.listFiles();\r\n        if (files !\u003d null) {\r\n            for (File file : files) {\r\n                if (file.isDirectory()) {\r\n                    findPomFilesRecursive(file, pomFiles);\r\n                } else if (file.getName().equals(\"pom.xml\")) {\r\n                    pomFiles.add(file);\r\n                }\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Recursive helper method to find all POM files.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "param",
                "value": "pomFiles List to collect POM files"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    pomFiles.add(file);\r\n                }",
          "javadoc": {
            "description": "Recursive helper method to find all POM files.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "param",
                "value": "pomFiles List to collect POM files"
              }
            ]
          },
          "comments": []
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/parsers/Parser.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "all",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Check if directory exists\r\n                File dir \u003d new File(directory);\r\n                if (!validateDirectory(dir, result)) {\r\n                    return result;\r\n                }\r\n\r\n                // Parse Git repository if it\u0027s a valid Git repository\r\n                parseGitRepository(directory, result);\r\n\r\n                // List all files in the directory respecting .gitignore\r\n                List\u003cFile\u003e files \u003d listAllFiles(directory, dir);\r\n\r\n                // Parse different file types\r\n                Map\u003cString, List\u003cFile\u003e\u003e filesByType \u003d categorizeFiles(files);\r\n\r\n                List\u003cFile\u003e pomFiles \u003d filesByType.getOrDefault(\"pom\", new ArrayList\u003c\u003e());\r\n                List\u003cFile\u003e javaFiles \u003d filesByType.getOrDefault(\"java\", new ArrayList\u003c\u003e());\r\n                List\u003cFile\u003e htmlFiles \u003d filesByType.getOrDefault(\"html\", new ArrayList\u003c\u003e());\r\n                List\u003cFile\u003e markdownFiles \u003d filesByType.getOrDefault(\"markdown\", new ArrayList\u003c\u003e());\r\n\r\n                // Parse each file type\r\n                result.putAll(parsePomFiles(pomFiles));\r\n                result.putAll(parseJavaFiles(javaFiles));\r\n                result.putAll(parseHtmlFiles(htmlFiles));\r\n                result.putAll(parseMarkdownFiles(markdownFiles));\r\n\r\n                // Add file statistics\r\n                Map\u003cString, Object\u003e fileStats \u003d new HashMap\u003c\u003e();\r\n                fileStats.put(\"totalFiles\", files.size());\r\n                fileStats.put(\"pomFiles\", pomFiles.size());\r\n                fileStats.put(\"javaFiles\", javaFiles.size());\r\n                fileStats.put(\"htmlFiles\", htmlFiles.size());\r\n                fileStats.put(\"markdownFiles\", markdownFiles.size());\r\n                result.put(\"fileStatistics\", fileStats);\r\n\r\n                return result;\r\n            } catch (Exception e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse directory: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse a directory and extract all available information using all parsers.\r\nThis method respects .gitignore rules when listing files.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory to parse"
              },
              {
                "name": "return",
                "value": "Map containing all parsed information"
              }
            ]
          },
          "comments": [
            "Cre"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Check if directory exists"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "repository",
          "methodName": "parseGitRepository",
          "parameters": [],
          "body": "{\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse directory: \" + e.getMessage());\r\n                return error;\r\n            }",
          "comments": [
            "Parse Git repository if it\u0027s a valid Git repository",
            "List all f"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "git",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Parse Git repository\r\n                File dir \u003d new File(directory);\r\n                if (dir.exists() \u0026\u0026 dir.isDirectory()) {\r\n                    boolean isValidRepo \u003d parseGitRepository(directory, result);\r\n                    if (!isValidRepo) {\r\n                        result.put(\"error\", \"Not a valid Git repository: \" + directory);\r\n                    }\r\n                } else {\r\n                    result.put(\"error\", \"Directory does not exist: \" + directory);\r\n                }\r\n\r\n                return result;\r\n            } catch (IOException | GitAPIException e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse Git repository: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse a Git repository and return a Map containing the repository information.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory containing the Git repository"
              },
              {
                "name": "return",
                "value": "Map containing the parsed Git repository information"
              }
            ]
          },
          "comments": [
            "Cre"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Parse Git repository"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "java",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Find all Java files in the directory\r\n                File dir \u003d new File(directory);\r\n                if (!validateDirectory(dir, result)) {\r\n                    return result;\r\n                }\r\n\r\n                List\u003cFile\u003e javaFiles \u003d new ArrayList\u003c\u003e();\r\n                JavaParser.findJavaFiles(dir).forEach(javaFiles::add);\r\n\r\n                result.putAll(parseJavaFiles(javaFiles));\r\n                return result;\r\n            } catch (Exception e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse Java files: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse Java files in a directory and return a Map containing the Java code structure.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory containing Java files"
              },
              {
                "name": "return",
                "value": "Map containing the parsed Java files information"
              }
            ]
          },
          "comments": [
            "Cr"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Find all Java files in the directory"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "pom",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Find all POM files in the directory\r\n                File dir \u003d new File(directory);\r\n                if (!validateDirectory(dir, result)) {\r\n                    return result;\r\n                }\r\n\r\n                List\u003cFile\u003e pomFiles \u003d PomParser.findPomFiles(dir);\r\n                result.putAll(parsePomFiles(pomFiles));\r\n                return result;\r\n            } catch (Exception e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse POM files: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse POM files in a directory and return a Map containing the Maven project information.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory containing POM files"
              },
              {
                "name": "return",
                "value": "Map containing the parsed POM files information"
              }
            ]
          },
          "comments": [
            "Cre"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Find all POM files in the directory"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "html",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Find all HTML files in the directory\r\n                File dir \u003d new File(directory);\r\n                if (!validateDirectory(dir, result)) {\r\n                    return result;\r\n                }\r\n\r\n                List\u003cFile\u003e htmlFiles \u003d new ArrayList\u003c\u003e();\r\n                listFilesRecursive(dir, htmlFiles, \".html\", \".htm\");\r\n\r\n                result.putAll(parseHtmlFiles(htmlFiles));\r\n                return result;\r\n            } catch (Exception e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse HTML files: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse HTML files in a directory and return a Map containing the HTML structure.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory containing HTML files"
              },
              {
                "name": "return",
                "value": "Map containing the parsed HTML files information"
              }
            ]
          },
          "comments": [
            "Cr"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Find all HTML files in the directory"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "markdown",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Find all Markdown files in the directory\r\n                File dir \u003d new File(directory);\r\n                if (!validateDirectory(dir, result)) {\r\n                    return result;\r\n                }\r\n\r\n                List\u003cFile\u003e markdownFiles \u003d new ArrayList\u003c\u003e();\r\n                listFilesRecursive(dir, markdownFiles, \".md\", \".markdown\");\r\n\r\n                result.putAll(parseMarkdownFiles(markdownFiles));\r\n                return result;\r\n            } catch (Exception e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse Markdown files: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse Markdown files in a directory and return a Map containing Markdown content information.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory containing Markdown files"
              },
              {
                "name": "return",
                "value": "Map containing the parsed Markdown files information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Find all Markdown files in the directory"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "validateDirectory",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "Object\u003e",
              "name": "result"
            }
          ],
          "body": "{\r\n        if (!directory.exists() || !directory.isDirectory()) {\r\n            result.put(\"error\", \"Directory does not exist or is not a directory: \" + directory);\r\n            return false;\r\n        }\r\n        return true;\r\n    }",
          "javadoc": {
            "description": "Validates if a directory exists and is actually a directory.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to validate"
              },
              {
                "name": "param",
                "value": "result The result map to store error if validation fails"
              },
              {
                "name": "return",
                "value": "boolean indicating whether the directory is valid"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "parseGitRepository",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            },
            {
              "type": "Object\u003e",
              "name": "result"
            }
          ],
          "body": "{\r\n        if (GitParser.isValidRepository(directory)) {\r\n            GitRepositoryInfo repoInfo \u003d GitParser.parseRepository(directory);\r\n            result.put(\"gitRepository\", repoInfo);\r\n            return true;\r\n        }\r\n        return false;\r\n    }",
          "javadoc": {
            "description": "Parse Git repository information and add it to the result map.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory path of the Git repository"
              },
              {
                "name": "param",
                "value": "result The result map to store the Git repository information"
              },
              {
                "name": "return",
                "value": "boolean indicating whether the repository was successfully parsed"
              },
              {
                "name": "throws",
                "value": "IOException If an I/O error occurs"
              },
              {
                "name": "throws",
                "value": "GitAPIException If a Git operation fails"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "listAllFiles",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            },
            {
              "type": "File",
              "name": "dir"
            }
          ],
          "body": "{\r\n        List\u003cFile\u003e files;\r\n        try {\r\n            files \u003d GitParser.listFilesRespectingGitignore(directory);\r\n        } catch (IOException e) {\r\n            // If there\u0027s an error listing files with .gitignore, fall back to listing all files\r\n            files \u003d new ArrayList\u003c\u003e();\r\n            listFilesRecursive(dir, files);\r\n        }\r\n        return files;\r\n    }",
          "javadoc": {
            "description": "List all files in a directory, respecting .gitignore rules if possible.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory path to search"
              },
              {
                "name": "param",
                "value": "dir The directory File object"
              },
              {
                "name": "return",
                "value": "List of files found"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, List\u003cFile\u003e\u003e",
          "methodName": "categorizeFiles",
          "parameters": [
            {
              "type": "List\u003cFile\u003e",
              "name": "files"
            }
          ],
          "body": "{\r\n        Map\u003cString, List\u003cFile\u003e\u003e filesByType \u003d new HashMap\u003c\u003e();\r\n        filesByType.put(\"pom\", new ArrayList\u003c\u003e());\r\n        filesByType.put(\"java\", new ArrayList\u003c\u003e());\r\n        filesByType.put(\"html\", new ArrayList\u003c\u003e());\r\n        filesByType.put(\"markdown\", new ArrayList\u003c\u003e());\r\n\r\n        for (File file : files) {\r\n            String name \u003d file.getName().toLowerCase();\r\n            if (file.getName().equals(\"pom.xml\")) {\r\n                filesByType.get(\"pom\").add(file);\r\n            } else if (name.endsWith(\".java\")) {\r\n                filesByType.get(\"java\").add(file);\r\n            } else if (name.endsWith(\".html\") || name.endsWith(\".htm\")) {\r\n                filesByType.get(\"html\").add(file);\r\n            } else if (name.endsWith(\".md\") || name.endsWith(\".markdown\")) {\r\n                filesByType.get(\"markdown\").add(file);\r\n            }\r\n        }\r\n        return filesByType;\r\n    }",
          "javadoc": {
            "description": "Categorize files by type for further processing.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "files List of files to categorize"
              },
              {
                "name": "return",
                "value": "Map of file lists by type"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                filesByType.get(\"java\").add(file);\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                filesByType.get(\"html\").add(file);\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                filesByType.get(\"markdown\").add(file);\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "parsePomFiles",
          "parameters": [
            {
              "type": "List\u003cFile\u003e",
              "name": "pomFiles"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n        if (pomFiles.isEmpty()) {\r\n            return result;\r\n        }\r\n\r\n        List\u003cMap\u003cString, Object\u003e\u003e pomResults \u003d new ArrayList\u003c\u003e();\r\n\r\n        for (File pomFile : pomFiles) {\r\n            try {\r\n                Model model \u003d PomParser.parsePom(pomFile);\r\n                Map\u003cString, Object\u003e pomInfo \u003d new HashMap\u003c\u003e();\r\n                pomInfo.put(\"path\", pomFile.getAbsolutePath());\r\n                pomInfo.put(\"groupId\", model.getGroupId());\r\n                pomInfo.put(\"artifactId\", model.getArtifactId());\r\n                pomInfo.put(\"version\", model.getVersion());\r\n                pomInfo.put(\"name\", model.getName());\r\n                pomInfo.put(\"description\", model.getDescription());\r\n\r\n                // Add dependencies\r\n                List\u003cMap\u003cString, String\u003e\u003e dependencies \u003d new ArrayList\u003c\u003e();\r\n                for (org.apache.maven.api.model.Dependency dependency : model.getDependencies()) {\r\n                    Map\u003cString, String\u003e dep \u003d new HashMap\u003c\u003e();\r\n                    dep.put(\"groupId\", dependency.getGroupId());\r\n                    dep.put(\"artifactId\", dependency.getArtifactId());\r\n                    dep.put(\"version\", dependency.getVersion());\r\n                    dep.put(\"scope\", dependency.getScope());\r\n                    dependencies.add(dep);\r\n                }\r\n                pomInfo.put(\"dependencies\", dependencies);\r\n\r\n                pomResults.add(pomInfo);\r\n            } catch (Exception e) {\r\n                // Skip this POM file if there\u0027s an error\r\n                addErrorInfo(pomResults, pomFile, \"Failed to parse POM file: \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        if (!pomResults.isEmpty()) {\r\n            result.put(\"pomFiles\", pomResults);\r\n        }\r\n        return result;\r\n    }",
          "javadoc": {
            "description": "Parse POM files and create a map of results.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFiles List of POM files to parse"
              },
              {
                "name": "return",
                "value": "Map containing parsed POM files information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "error",
          "methodName": "addErrorInfo",
          "parameters": [
            {
              "type": "\"Failed",
              "name": "to"
            }
          ],
          "body": "{\r\n            result.put(\"pomFiles\", pomResults);\r\n        }",
          "comments": [
            "Skip this POM file if there\u0027s an error"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "parseJavaFiles",
          "parameters": [
            {
              "type": "List\u003cFile\u003e",
              "name": "javaFiles"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n        if (javaFiles.isEmpty()) {\r\n            return result;\r\n        }\r\n\r\n        List\u003cMap\u003cString, Object\u003e\u003e javaResults \u003d new ArrayList\u003c\u003e();\r\n\r\n        for (File javaFile : javaFiles) {\r\n            try {\r\n                String content \u003d new String(Files.readAllBytes(javaFile.toPath()));\r\n                ClassStructure classStructure \u003d JavaParser.extractClassStructure(javaFile.getName(), content);\r\n\r\n                Map\u003cString, Object\u003e javaInfo \u003d new HashMap\u003c\u003e();\r\n                javaInfo.put(\"path\", javaFile.getAbsolutePath());\r\n                javaInfo.put(\"packageName\", classStructure.getPackageName());\r\n                javaInfo.put(\"className\", classStructure.getClassName());\r\n                javaInfo.put(\"methods\", classStructure.getMethods());\r\n\r\n                javaResults.add(javaInfo);\r\n            } catch (Exception e) {\r\n                // Skip this Java file if there\u0027s an error\r\n                addErrorInfo(javaResults, javaFile, \"Failed to parse Java file: \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        if (!javaResults.isEmpty()) {\r\n            result.put(\"javaFiles\", javaResults);\r\n        }\r\n        return result;\r\n    }",
          "javadoc": {
            "description": "Parse Java files and create a map of results.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "javaFiles List of Java files to parse"
              },
              {
                "name": "return",
                "value": "Map containing parsed Java files information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "String",
          "parameters": [],
          "body": "{\r\n                // Skip this Java file if there\u0027s an error\r\n                addErrorInfo(javaResults, javaFile, \"Failed to parse Java file: \" + e.getMessage());\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "error",
          "methodName": "addErrorInfo",
          "parameters": [
            {
              "type": "\"Failed",
              "name": "to"
            }
          ],
          "body": "{\r\n            result.put(\"javaFiles\", javaResults);\r\n        }",
          "comments": [
            "Skip this Java file if there\u0027s an error"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "parseHtmlFiles",
          "parameters": [
            {
              "type": "List\u003cFile\u003e",
              "name": "htmlFiles"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n        if (htmlFiles.isEmpty()) {\r\n            return result;\r\n        }\r\n\r\n        List\u003cMap\u003cString, Object\u003e\u003e htmlResults \u003d new ArrayList\u003c\u003e();\r\n\r\n        for (File htmlFile : htmlFiles) {\r\n            try {\r\n                Document document \u003d HtmlParser.parse(htmlFile, \"UTF-8\", \"\");\r\n\r\n                Map\u003cString, Object\u003e htmlInfo \u003d new HashMap\u003c\u003e();\r\n                htmlInfo.put(\"path\", htmlFile.getAbsolutePath());\r\n                htmlInfo.put(\"title\", document.title());\r\n                htmlInfo.put(\"headings\", HtmlParser.getHeadings(document).size());\r\n                htmlInfo.put(\"links\", HtmlParser.getLinks(document).size());\r\n                htmlInfo.put(\"images\", HtmlParser.getImages(document).size());\r\n                htmlInfo.put(\"metadata\", HtmlParser.getMetadata(document));\r\n\r\n                htmlResults.add(htmlInfo);\r\n            } catch (Exception e) {\r\n                // Skip this HTML file if there\u0027s an error\r\n                addErrorInfo(htmlResults, htmlFile, \"Failed to parse HTML file: \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        if (!htmlResults.isEmpty()) {\r\n            result.put(\"htmlFiles\", htmlResults);\r\n        }\r\n        return result;\r\n    }",
          "javadoc": {
            "description": "Parse HTML files and create a map of results.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "htmlFiles List of HTML files to parse"
              },
              {
                "name": "return",
                "value": "Map containing parsed HTML files information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "error",
          "methodName": "addErrorInfo",
          "parameters": [
            {
              "type": "\"Failed",
              "name": "to"
            }
          ],
          "body": "{\r\n            result.put(\"htmlFiles\", htmlResults);\r\n        }",
          "comments": [
            "Skip this HTML file if there\u0027s an error"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "parseMarkdownFiles",
          "parameters": [
            {
              "type": "List\u003cFile\u003e",
              "name": "markdownFiles"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n        if (markdownFiles.isEmpty()) {\r\n            return result;\r\n        }\r\n\r\n        List\u003cMap\u003cString, Object\u003e\u003e markdownResults \u003d new ArrayList\u003c\u003e();\r\n\r\n        for (File markdownFile : markdownFiles) {\r\n            try {\r\n                String content \u003d new String(Files.readAllBytes(markdownFile.toPath()));\r\n                MarkdownContent parsedContent \u003d MarkdownParser.parseMarkdown(content);\r\n\r\n                Map\u003cString, Object\u003e mdInfo \u003d createMarkdownInfo(markdownFile, parsedContent);\r\n                markdownResults.add(mdInfo);\r\n            } catch (Exception e) {\r\n                // Skip this Markdown file if there\u0027s an error\r\n                addErrorInfo(markdownResults, markdownFile, \"Failed to parse Markdown file: \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        if (!markdownResults.isEmpty()) {\r\n            result.put(\"markdownFiles\", markdownResults);\r\n        }\r\n        return result;\r\n    }",
          "javadoc": {
            "description": "Parse Markdown files and create a map of results.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdownFiles List of Markdown files to parse"
              },
              {
                "name": "return",
                "value": "Map containing parsed Markdown files information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "String",
          "parameters": [],
          "body": "{\r\n                // Skip this Markdown file if there\u0027s an error\r\n                addErrorInfo(markdownResults, markdownFile, \"Failed to parse Markdown file: \" + e.getMessage());\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "error",
          "methodName": "addErrorInfo",
          "parameters": [
            {
              "type": "\"Failed",
              "name": "to"
            }
          ],
          "body": "{\r\n            result.put(\"markdownFiles\", markdownResults);\r\n        }",
          "comments": [
            "Skip this Markdown file if there\u0027s an error"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "createMarkdownInfo",
          "parameters": [
            {
              "type": "File",
              "name": "markdownFile"
            },
            {
              "type": "MarkdownContent",
              "name": "parsedContent"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e mdInfo \u003d new HashMap\u003c\u003e();\r\n        mdInfo.put(\"path\", markdownFile.getAbsolutePath());\r\n        mdInfo.put(\"title\", parsedContent.getTitle());\r\n        mdInfo.put(\"wordCount\", parsedContent.getWordCount());\r\n        mdInfo.put(\"readingTimeMinutes\", parsedContent.getReadingTimeMinutes());\r\n\r\n        // Add headings\r\n        List\u003cMap\u003cString, Object\u003e\u003e headings \u003d new ArrayList\u003c\u003e();\r\n        for (MarkdownHeading heading : parsedContent.getHeadings()) {\r\n            Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\r\n            h.put(\"level\", heading.getLevel());\r\n            h.put(\"text\", heading.getText());\r\n            h.put(\"id\", heading.getId());\r\n            headings.add(h);\r\n        }\r\n        mdInfo.put(\"headings\", headings);\r\n\r\n        // Add links\r\n        List\u003cMap\u003cString, Object\u003e\u003e links \u003d new ArrayList\u003c\u003e();\r\n        for (MarkdownLink link : parsedContent.getLinks()) {\r\n            Map\u003cString, Object\u003e l \u003d new HashMap\u003c\u003e();\r\n            l.put(\"text\", link.getText());\r\n            l.put(\"url\", link.getUrl());\r\n            l.put(\"title\", link.getTitle());\r\n            l.put(\"internal\", link.isInternal());\r\n            links.add(l);\r\n        }\r\n        mdInfo.put(\"links\", links);\r\n\r\n        // Add images\r\n        List\u003cMap\u003cString, Object\u003e\u003e images \u003d new ArrayList\u003c\u003e();\r\n        for (MarkdownImage image : parsedContent.getImages()) {\r\n            Map\u003cString, Object\u003e img \u003d new HashMap\u003c\u003e();\r\n            img.put(\"altText\", image.getAltText());\r\n            img.put(\"url\", image.getUrl());\r\n            img.put(\"title\", image.getTitle());\r\n            img.put(\"local\", image.isLocal());\r\n            images.add(img);\r\n        }\r\n        mdInfo.put(\"images\", images);\r\n\r\n        // Add code blocks\r\n        List\u003cMap\u003cString, Object\u003e\u003e codeBlocks \u003d new ArrayList\u003c\u003e();\r\n        for (MarkdownCodeBlock codeBlock : parsedContent.getCodeBlocks()) {\r\n            Map\u003cString, Object\u003e cb \u003d new HashMap\u003c\u003e();\r\n            cb.put(\"language\", codeBlock.getLanguage());\r\n            cb.put(\"content\", codeBlock.getContent());\r\n            cb.put(\"fenced\", codeBlock.isFenced());\r\n            codeBlocks.add(cb);\r\n        }\r\n        mdInfo.put(\"codeBlocks\", codeBlocks);\r\n\r\n        // Add front matter if available\r\n        if (parsedContent.getFrontMatter() !\u003d null \u0026\u0026 !parsedContent.getFrontMatter().isEmpty()) {\r\n            mdInfo.put(\"frontMatter\", parsedContent.getFrontMatter());\r\n        }\r\n\r\n        return mdInfo;\r\n    }",
          "javadoc": {
            "description": "Create a map of Markdown file information from parsed content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdownFile The Markdown file"
              },
              {
                "name": "param",
                "value": "parsedContent The parsed Markdown content"
              },
              {
                "name": "return",
                "value": "Map containing the Markdown file information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            mdInfo.put(\"frontMatter\", parsedContent.getFrontMatter());\r\n        }",
          "comments": [
            "Add front matter if available"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "addErrorInfo",
          "parameters": [
            {
              "type": "Object\u003e\u003e",
              "name": "resultsList"
            },
            {
              "type": "File",
              "name": "file"
            },
            {
              "type": "String",
              "name": "errorMessage"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n        errorInfo.put(\"path\", file.getAbsolutePath());\r\n        errorInfo.put(\"error\", errorMessage);\r\n        resultsList.add(errorInfo);\r\n    }",
          "javadoc": {
            "description": "Add error information to a list of results.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "resultsList The list to add error information to"
              },
              {
                "name": "param",
                "value": "file The file that caused the error"
              },
              {
                "name": "param",
                "value": "errorMessage The error message"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "listFilesRecursive",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "List\u003cFile\u003e",
              "name": "files"
            }
          ],
          "body": "{\r\n        File[] fileList \u003d directory.listFiles();\r\n        if (fileList !\u003d null) {\r\n            for (File file : fileList) {\r\n                if (file.isDirectory()) {\r\n                    listFilesRecursive(file, files);\r\n                } else {\r\n                    files.add(file);\r\n                }\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to recursively list all files in a directory.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "param",
                "value": "files List to collect files"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "listFilesRecursive",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "List\u003cFile\u003e",
              "name": "files"
            },
            {
              "type": "String...",
              "name": "extensions"
            }
          ],
          "body": "{\r\n        File[] fileList \u003d directory.listFiles();\r\n        if (fileList !\u003d null) {\r\n            for (File file : fileList) {\r\n                if (file.isDirectory()) {\r\n                    listFilesRecursive(file, files, extensions);\r\n                } else {\r\n                    String name \u003d file.getName().toLowerCase();\r\n                    for (String extension : extensions) {\r\n                        if (name.endsWith(extension.toLowerCase())) {\r\n                            files.add(file);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to recursively list files with specific extensions in a directory.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "param",
                "value": "files List to collect files"
              },
              {
                "name": "param",
                "value": "extensions File extensions to include"
              }
            ]
          },
          "comments": []
        }
      ],
      "className": "that",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/parsers/JavaParser.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "JavaParser",
          "parameters": [],
          "body": "{\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Java files and extracting structural information.\r\nThis class provides static methods to analyze Java source code.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AssertionError",
          "parameters": [
            {
              "type": "\"Utility",
              "name": "class"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Utility class for parsing Java files and extracting structural information.\r\nThis class provides static methods to analyze Java source code.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation",
            "Regular expression"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "findJavaFiles",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            }
          ],
          "body": "{\r\n        List\u003cFile\u003e javaFiles \u003d new ArrayList\u003c\u003e();\r\n        findJavaFilesRecursive(directory, javaFiles);\r\n        return javaFiles;\r\n    }",
          "javadoc": {
            "description": "Find all Java files in a directory and its subdirectories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "return",
                "value": "List of Java files"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "findJavaFilesRecursive",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "List\u003cFile\u003e",
              "name": "javaFiles"
            }
          ],
          "body": "{\r\n        File[] files \u003d directory.listFiles();\r\n        if (files !\u003d null) {\r\n            for (File file : files) {\r\n                if (file.isDirectory()) {\r\n                    findJavaFilesRecursive(file, javaFiles);\r\n                } else if (file.getName().endsWith(\".java\")) {\r\n                    javaFiles.add(file);\r\n                }\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Recursive helper method to find all Java files.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "param",
                "value": "javaFiles List to collect Java files"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    javaFiles.add(file);\r\n                }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "extractPackageName",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n        Matcher matcher \u003d PACKAGE_PATTERN.matcher(content);\r\n        return matcher.find() ? matcher.group(1) : \"default\";\r\n    }",
          "javadoc": {
            "description": "Extract the package name from Java file content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "The package name or \"default\" if not found"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "JavadocStructure",
          "methodName": "extractClassJavadoc",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n        // Find class declaration position\r\n        Matcher classMatcher \u003d CLASS_PATTERN.matcher(content);\r\n        if (!classMatcher.find()) {\r\n            return null;\r\n        }\r\n\r\n        // Get position of class declaration\r\n        int classPosition \u003d classMatcher.start();\r\n\r\n        // Search for JavaDoc before class declaration\r\n        String contentBeforeClass \u003d content.substring(0, classPosition);\r\n        Matcher javadocMatcher \u003d JAVADOC_PATTERN.matcher(contentBeforeClass);\r\n\r\n        // Find the last JavaDoc before class declaration\r\n        JavadocStructure javadoc \u003d null;\r\n        while (javadocMatcher.find()) {\r\n            String javadocText \u003d javadocMatcher.group(1).trim();\r\n            javadoc \u003d parseJavadoc(javadocText);\r\n        }\r\n\r\n        return javadoc;\r\n    }",
          "javadoc": {
            "description": "Extract the class JavaDoc from Java file content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "JavadocStructure object or null if not found"
              }
            ]
          },
          "comments": [
            "Find class declarat"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cString\u003e",
          "methodName": "extractClassComments",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n        List\u003cString\u003e comments \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Find class declaration position\r\n        Matcher classMatcher \u003d CLASS_PATTERN.matcher(content);\r\n        if (!classMatcher.find()) {\r\n            return comments;\r\n        }\r\n\r\n        // Get position of class declaration\r\n        int classPosition \u003d classMatcher.start();\r\n\r\n        // Define a window around the class declaration (200 chars before and after)\r\n        int startPos \u003d Math.max(0, classPosition - 200);\r\n        int endPos \u003d Math.min(content.length(), classPosition + 200);\r\n        String windowContent \u003d content.substring(startPos, endPos);\r\n\r\n        // Extract single-line comments\r\n        Matcher singleLineCommentMatcher \u003d SINGLE_LINE_COMMENT_PATTERN.matcher(windowContent);\r\n        while (singleLineCommentMatcher.find()) {\r\n            comments.add(singleLineCommentMatcher.group(1).trim());\r\n        }\r\n\r\n        // Extract multi-line comments (excluding JavaDoc)\r\n        Matcher multiLineCommentMatcher \u003d MULTI_LINE_COMMENT_PATTERN.matcher(windowContent);\r\n        while (multiLineCommentMatcher.find()) {\r\n            String commentText \u003d multiLineCommentMatcher.group(1).trim();\r\n            // If it doesn\u0027t start with *, it\u0027s not a JavaDoc\r\n            if (!commentText.startsWith(\"*\")) {\r\n                comments.add(commentText);\r\n            }\r\n        }\r\n\r\n        return comments;\r\n    }",
          "javadoc": {
            "description": "Extract all non-JavaDoc comments around the class declaration.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "List of comments"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "class",
          "methodName": "declaration",
          "parameters": [
            {
              "type": "200",
              "name": "chars"
            }
          ],
          "body": "{\r\n            comments.add(singleLineCommentMatcher.group(1).trim());\r\n        }",
          "comments": [
            "Get position of class declaration",
            "Define a window around the class declaration (200 chars before and after)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "line",
          "methodName": "comments",
          "parameters": [
            {
              "type": "excluding",
              "name": "JavaDoc"
            }
          ],
          "body": "{\r\n            String commentText \u003d multiLineCommentMatcher.group(1).trim();\r\n            // If it doesn\u0027t start with *, it\u0027s not a JavaDoc\r\n            if (!commentText.startsWith(\"*\")) {\r\n                comments.add(commentText);\r\n            }\r\n        }",
          "comments": [
            "Extract multi-line comments (excluding JavaDoc)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "JavaDoc",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                comments.add(commentText);\r\n            }",
          "comments": [
            "If it doesn\u0027t start with *, it\u0027s not a JavaDoc"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "ClassStructure",
          "methodName": "extractClassStructure",
          "parameters": [
            {
              "type": "String",
              "name": "fileName"
            },
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n        String packageName \u003d extractPackageName(content);\r\n\r\n        // Extract class name and type\r\n        String className \u003d fileName.replace(\".java\", \"\");\r\n        String classType \u003d \"class\";\r\n\r\n        Matcher classMatcher \u003d CLASS_PATTERN.matcher(content);\r\n        if (classMatcher.find()) {\r\n            className \u003d classMatcher.group(4);\r\n            classType \u003d classMatcher.group(3); // class, interface, or enum\r\n        }\r\n\r\n        // Extract methods\r\n        List\u003cMethodStructure\u003e methods \u003d extractMethods(content);\r\n\r\n        // Extract JavaDoc and comments\r\n        JavadocStructure javadoc \u003d extractClassJavadoc(content);\r\n        List\u003cString\u003e comments \u003d extractClassComments(content);\r\n\r\n        // Assuming you\u0027ve built a proper ClassStructure builder elsewhere\r\n        return ClassStructure.builder()\r\n                .fileName(fileName)\r\n                .packageName(packageName)\r\n                .className(className)\r\n                .classType(classType)\r\n                .methods(methods)\r\n                .javadoc(javadoc)\r\n                .comments(comments)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Extract the class structure from Java file content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "fileName The Java file name"
              },
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "ClassStructure object"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMethodStructure\u003e",
          "methodName": "extractMethods",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Extract all methods from a Java file content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "List of MethodStructure objects"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "signature",
          "methodName": "if",
          "parameters": [],
          "body": "{\")) {\r\n                    bodyStart \u003d content.indexOf(\"{\", bodyStart);\r\n                    if (bodyStart \u003e\u003d 0) {\r\n                        // Find the matching closing brace\r\n                        int bodyEnd \u003d findMatchingBrace(content, bodyStart);\r\n                        if (bodyEnd \u003e bodyStart) {\r\n                            // Extract the method body including braces\r\n                            body \u003d content.substring(bodyStart, bodyEnd + 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Assuming you\u0027ve built a proper MethodStructure builder elsewhere\r\n            MethodStructure method \u003d  MethodStructure.builder()\r\n                    .accessModifier(accessModifier !\u003d null ? accessModifier : \"\")\r\n                    .isStatic(staticModifier !\u003d null)\r\n                    .returnType(returnType)\r\n                    .methodName(methodName)\r\n                    .parameters(parseParameters(parameters))\r\n                    .body(body)\r\n                    .javadoc(javadoc)\r\n                    .comments(comments)\r\n                    .build();\r\n\r\n            methods.add(method);\r\n        }",
          "comments": [
            "Position after the method signature",
            "Search for the opening brace if not part of the signature"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "JavadocStructure",
          "methodName": "extractMethodJavadoc",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            },
            {
              "type": "int",
              "name": "methodPosition"
            }
          ],
          "body": "{\r\n        // Search for JavaDoc before method\r\n        int searchStart \u003d Math.max(0, methodPosition - 500); // Look up to 500 chars before method\r\n        String contentBefore \u003d content.substring(searchStart, methodPosition);\r\n\r\n        Matcher javadocMatcher \u003d JAVADOC_PATTERN.matcher(contentBefore);\r\n\r\n        // Find the last JavaDoc before method\r\n        JavadocStructure javadoc \u003d null;\r\n        while (javadocMatcher.find()) {\r\n            String javadocText \u003d javadocMatcher.group(1).trim();\r\n            javadoc \u003d parseJavadoc(javadocText);\r\n        }\r\n\r\n        return javadoc;\r\n    }",
          "javadoc": {
            "description": "Extract JavaDoc for a method.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "param",
                "value": "methodPosition Position of method in content"
              },
              {
                "name": "return",
                "value": "JavadocStructure object or null if not found"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cString\u003e",
          "methodName": "extractMethodComments",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            },
            {
              "type": "int",
              "name": "methodPosition"
            }
          ],
          "body": "{\r\n        List\u003cString\u003e comments \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Define a window around the method declaration\r\n        int startPos \u003d Math.max(0, methodPosition - 200);\r\n        int endPos \u003d Math.min(content.length(), methodPosition + 100);\r\n        String windowContent \u003d content.substring(startPos, endPos);\r\n\r\n        // Extract single-line comments\r\n        Matcher singleLineCommentMatcher \u003d SINGLE_LINE_COMMENT_PATTERN.matcher(windowContent);\r\n        while (singleLineCommentMatcher.find()) {\r\n            comments.add(singleLineCommentMatcher.group(1).trim());\r\n        }\r\n\r\n        // Extract multi-line comments (excluding JavaDoc)\r\n        Matcher multiLineCommentMatcher \u003d MULTI_LINE_COMMENT_PATTERN.matcher(windowContent);\r\n        while (multiLineCommentMatcher.find()) {\r\n            String commentText \u003d multiLineCommentMatcher.group(1).trim();\r\n            // If it doesn\u0027t start with *, it\u0027s not a JavaDoc\r\n            if (!commentText.startsWith(\"*\")) {\r\n                comments.add(commentText);\r\n            }\r\n        }\r\n\r\n        return comments;\r\n    }",
          "javadoc": {
            "description": "Extract non-JavaDoc comments for a method.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "param",
                "value": "methodPosition Position of method in content"
              },
              {
                "name": "return",
                "value": "List of comments"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "line",
          "methodName": "comments",
          "parameters": [
            {
              "type": "excluding",
              "name": "JavaDoc"
            }
          ],
          "body": "{\r\n            String commentText \u003d multiLineCommentMatcher.group(1).trim();\r\n            // If it doesn\u0027t start with *, it\u0027s not a JavaDoc\r\n            if (!commentText.startsWith(\"*\")) {\r\n                comments.add(commentText);\r\n            }\r\n        }",
          "comments": [
            "Extract multi-line comments (excluding JavaDoc)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "JavaDoc",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                comments.add(commentText);\r\n            }",
          "comments": [
            "If it doesn\u0027t start with *, it\u0027s not a JavaDoc"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "JavadocStructure",
          "methodName": "parseJavadoc",
          "parameters": [
            {
              "type": "String",
              "name": "javadocText"
            }
          ],
          "body": "{\r\n        // Clean up the JavaDoc text by removing leading asterisks and extra whitespace\r\n        String cleanJavadoc \u003d javadocText.replaceAll(\"^\\\\s*\\\\*\\\\s*\", \"\")\r\n                .replaceAll(\"\\\\n\\\\s*\\\\*\\\\s*\", \"\\n\")\r\n                .trim();\r\n\r\n        // Split into main description and tags\r\n        int firstTagIndex \u003d cleanJavadoc.indexOf(\"@\");\r\n        String description \u003d \"\";\r\n\r\n        if (firstTagIndex \u003d\u003d -1) {\r\n            // No tags, whole text is description\r\n            description \u003d cleanJavadoc;\r\n        } else {\r\n            // Extract description (text before first @tag)\r\n            description \u003d cleanJavadoc.substring(0, firstTagIndex).trim();\r\n        }\r\n\r\n        // Extract tags\r\n        List\u003cJavadocTag\u003e tags \u003d new ArrayList\u003c\u003e();\r\n        if (firstTagIndex !\u003d -1) {\r\n            Matcher tagMatcher \u003d JAVADOC_TAG_PATTERN.matcher(cleanJavadoc);\r\n\r\n            while (tagMatcher.find()) {\r\n                String tagName \u003d tagMatcher.group(1);\r\n                String tagValue \u003d tagMatcher.group(2).trim();\r\n\r\n                // Assuming you\u0027ve built a proper JavadocTag builder elsewhere\r\n                JavadocTag tag \u003d  JavadocTag.builder()\r\n                        .name(tagName)\r\n                        .value(tagValue)\r\n                        .build();\r\n\r\n                tags.add(tag);\r\n            }\r\n        }\r\n\r\n        // Assuming you\u0027ve built a proper JavadocStructure builder elsewhere\r\n        return  JavadocStructure.builder()\r\n                .description(description)\r\n                .tags(tags)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Parse a JavaDoc comment text into a structured representation.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "javadocText The JavaDoc text to parse"
              },
              {
                "name": "return",
                "value": "JavadocStructure object"
              }
            ]
          },
          "comments": [
            "Clean up the JavaDoc t"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Extract",
          "methodName": "description",
          "parameters": [
            {
              "type": "text",
              "name": "before"
            }
          ],
          "body": "{\r\n            Matcher tagMatcher \u003d JAVADOC_TAG_PATTERN.matcher(cleanJavadoc);\r\n\r\n            while (tagMatcher.find()) {\r\n                String tagName \u003d tagMatcher.group(1);\r\n                String tagValue \u003d tagMatcher.group(2).trim();\r\n\r\n                // Assuming you\u0027ve built a proper JavadocTag builder elsewhere\r\n                JavadocTag tag \u003d  JavadocTag.builder()\r\n                        .name(tagName)\r\n                        .value(tagValue)\r\n                        .build();\r\n\r\n                tags.add(tag);\r\n            }\r\n        }",
          "comments": [
            "No tags, whole text is description",
            "Extract description (text before first @tag)"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "int",
          "methodName": "findMatchingBrace",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            },
            {
              "type": "int",
              "name": "openingBracePos"
            }
          ],
          "body": "{\r\n        int count \u003d 1;\r\n        for (int i \u003d openingBracePos + 1; i \u003c content.length(); i++) {\r\n            char c \u003d content.charAt(i);\r\n            if (c \u003d\u003d \u0027{\u0027) {\r\n                count++;\r\n            } else if (c \u003d\u003d \u0027}\u0027) {\r\n                count--;\r\n                if (count \u003d\u003d 0) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1; // No matching brace found\r\n    }",
          "javadoc": {
            "description": "Find the position of the matching closing brace for an opening brace.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The text to search in"
              },
              {
                "name": "param",
                "value": "openingBracePos Position of the opening brace"
              },
              {
                "name": "return",
                "value": "Position of the matching closing brace or -1 if not found"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [
            {
              "type": "c",
              "name": "\u003d\u003d"
            }
          ],
          "body": "{\r\n                count--;\r\n                if (count \u003d\u003d 0) {\r\n                    return i;\r\n                }\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parameter",
          "methodName": "string",
          "parameters": [
            {
              "type": "\"String",
              "name": "name\""
            }
          ],
          "body": "{\r\n            if (parameterString \u003d\u003d null || parameterString.trim().isEmpty()) {\r\n                return null;\r\n            }\r\n\r\n            String cleanParam \u003d parameterString.trim();\r\n            String[] parts \u003d cleanParam.split(\"\\\\s+\");\r\n\r\n            if (parts.length \u003e\u003d 2) {\r\n                return Parameter.builder()\r\n                        .type(parts[0])\r\n                        .name(parts[1].replace(\")\", \"\"))\r\n                        .build();\r\n            }\r\n\r\n            return null;\r\n        }",
          "comments": [
            "No matching brace found"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Parameter",
          "methodName": "parseParameter",
          "parameters": [
            {
              "type": "String",
              "name": "parameterString"
            }
          ],
          "body": "{\r\n            if (parameterString \u003d\u003d null || parameterString.trim().isEmpty()) {\r\n                return null;\r\n            }\r\n\r\n            String cleanParam \u003d parameterString.trim();\r\n            String[] parts \u003d cleanParam.split(\"\\\\s+\");\r\n\r\n            if (parts.length \u003e\u003d 2) {\r\n                return Parameter.builder()\r\n                        .type(parts[0])\r\n                        .name(parts[1].replace(\")\", \"\"))\r\n                        .build();\r\n            }\r\n\r\n            return null;\r\n        }",
          "javadoc": {
            "description": "Parse a single parameter string into a Parameter object.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "parameterString The single parameter string (e.g., \"String name\")"
              },
              {
                "name": "return",
                "value": "Parameter object or null if parsing fails"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cParameter\u003e",
          "methodName": "parseParameters",
          "parameters": [
            {
              "type": "String",
              "name": "parameterString"
            }
          ],
          "body": "{\r\n            List\u003cParameter\u003e parameters \u003d new ArrayList\u003c\u003e();\r\n\r\n            if (parameterString \u003d\u003d null || parameterString.trim().isEmpty()) {\r\n                return parameters;\r\n            }\r\n\r\n            String[] paramArray \u003d parameterString.split(\",\");\r\n            for (String param : paramArray) {\r\n                Parameter parameter \u003d parseParameter(param);\r\n                if (parameter !\u003d null) {\r\n                    parameters.add(parameter);\r\n                }\r\n            }\r\n\r\n            return parameters;\r\n        }",
          "javadoc": {
            "description": "Parse method parameters into a list of Parameter objects.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "parameterString The parameter string from the method signature"
              },
              {
                "name": "return",
                "value": "List of Parameter objects"
              }
            ]
          },
          "comments": []
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/parsers/HtmlParser.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "HtmlParser",
          "parameters": [],
          "body": "{\r\n        // Utility class, prevent instantiation\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing HTML documents using JSoup.",
            "tags": []
          },
          "comments": [
            "Utility class, prevent instantiation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parse",
          "parameters": [
            {
              "type": "String",
              "name": "html"
            },
            {
              "type": "String",
              "name": "baseUri"
            }
          ],
          "body": "{\r\n        return Jsoup.parse(html, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from a string.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "html    The HTML content"
              },
              {
                "name": "param",
                "value": "baseUri The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parse",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            },
            {
              "type": "String",
              "name": "charset"
            },
            {
              "type": "String",
              "name": "baseUri"
            }
          ],
          "body": "{\r\n        return Jsoup.parse(file, charset, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from a file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file    The HTML file"
              },
              {
                "name": "param",
                "value": "charset The character set of the file"
              },
              {
                "name": "param",
                "value": "baseUri The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parse",
          "parameters": [
            {
              "type": "Path",
              "name": "path"
            },
            {
              "type": "String",
              "name": "baseUri"
            }
          ],
          "body": "{\r\n        String html \u003d Files.readString(path, StandardCharsets.UTF_8);\r\n        return parse(html, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from a Path.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path    The path to the HTML file"
              },
              {
                "name": "param",
                "value": "baseUri The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "parse",
          "parameters": [],
          "body": "{\r\n        return Jsoup.parse(inputStream, charset, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from a Path.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path    The path to the HTML file"
              },
              {
                "name": "param",
                "value": "baseUri The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parse",
          "parameters": [
            {
              "type": "InputStream",
              "name": "inputStream"
            },
            {
              "type": "String",
              "name": "charset"
            },
            {
              "type": "String",
              "name": "baseUri"
            }
          ],
          "body": "{\r\n        return Jsoup.parse(inputStream, charset, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from an InputStream.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "inputStream The input stream containing HTML content"
              },
              {
                "name": "param",
                "value": "charset     The character set of the stream"
              },
              {
                "name": "param",
                "value": "baseUri     The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parseUrl",
          "parameters": [
            {
              "type": "String",
              "name": "url"
            }
          ],
          "body": "{\r\n        return Jsoup.connect(url)\r\n                .userAgent(\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\")\r\n                .get();\r\n    }",
          "javadoc": {
            "description": "Connect to a URL and parse the returned HTML.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "url The URL to connect to"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "all",
          "methodName": "headings",
          "parameters": [],
          "body": "{\r\n        return document.select(\"h1, h2, h3, h4, h5, h6\");\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getHeadings",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"h1, h2, h3, h4, h5, h6\");\r\n    }",
          "javadoc": {
            "description": "Get all headings (h1-h6) from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all headings"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getLinks",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"a[href]\");\r\n    }",
          "javadoc": {
            "description": "Get all links from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all links"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getImages",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"img\");\r\n    }",
          "javadoc": {
            "description": "Get all images from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all images"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getTables",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"table\");\r\n    }",
          "javadoc": {
            "description": "Get all tables from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all tables"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getForms",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"form\");\r\n    }",
          "javadoc": {
            "description": "Get all forms from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all forms"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "list",
          "methodName": "elements",
          "parameters": [],
          "body": "{\r\n        return document.select(\"ul, ol\");\r\n    }",
          "javadoc": {
            "description": "Get all forms from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all forms"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getLists",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"ul, ol\");\r\n    }",
          "javadoc": {
            "description": "Get all list elements (ul, ol) from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all lists"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getElementsByClass",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "className"
            }
          ],
          "body": "{\r\n        return document.getElementsByClass(className);\r\n    }",
          "javadoc": {
            "description": "Get all elements with the specified class name.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document  The JSoup Document"
              },
              {
                "name": "param",
                "value": "className The class name to search for"
              },
              {
                "name": "return",
                "value": "Elements containing all matching elements"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Element",
          "methodName": "getElementById",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "id"
            }
          ],
          "body": "{\r\n        return document.getElementById(id);\r\n    }",
          "javadoc": {
            "description": "Get the element with the specified ID.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "param",
                "value": "id       The ID to search for"
              },
              {
                "name": "return",
                "value": "The element with the specified ID, or null if not found"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "select",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "cssSelector"
            }
          ],
          "body": "{\r\n        return document.select(cssSelector);\r\n    }",
          "javadoc": {
            "description": "Get all elements matching the specified CSS selector.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document    The JSoup Document"
              },
              {
                "name": "param",
                "value": "cssSelector The CSS selector to match"
              },
              {
                "name": "return",
                "value": "Elements containing all matching elements"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, String\u003e",
          "methodName": "getMetadata",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        Map\u003cString, String\u003e metadata \u003d new HashMap\u003c\u003e();\r\n\r\n        // Title\r\n        metadata.put(\"title\", document.title());\r\n\r\n        // Meta tags\r\n        Elements metaTags \u003d document.select(\"meta\");\r\n        for (Element metaTag : metaTags) {\r\n            if (metaTag.hasAttr(\"name\") \u0026\u0026 metaTag.hasAttr(\"content\")) {\r\n                metadata.put(metaTag.attr(\"name\"), metaTag.attr(\"content\"));\r\n            } else if (metaTag.hasAttr(\"property\") \u0026\u0026 metaTag.hasAttr(\"content\")) {\r\n                metadata.put(metaTag.attr(\"property\"), metaTag.attr(\"content\"));\r\n            }\r\n        }\r\n\r\n        return metadata;\r\n    }",
          "javadoc": {
            "description": "Extract all metadata from the document head.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Map of metadata key-value pairs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                metadata.put(metaTag.attr(\"property\"), metaTag.attr(\"content\"));\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getTextContent",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.text();\r\n    }",
          "javadoc": {
            "description": "Extract text content from a document, removing all HTML tags.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Plain text content"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    data[i][j] \u003d element.html();\r\n                }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    data[i][j] \u003d element.outerHtml();\r\n                }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "exists",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "selector"
            }
          ],
          "body": "{\r\n        return !document.select(selector).isEmpty();\r\n    }",
          "javadoc": {
            "description": "Check if elements matching a selector exist in the document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "param",
                "value": "selector CSS selector to check"
              },
              {
                "name": "return",
                "value": "true if at least one matching element exists"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getText",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "selector"
            }
          ],
          "body": "{\r\n        Element element \u003d document.select(selector).first();\r\n        return element !\u003d null ? element.text() : \"\";\r\n    }",
          "javadoc": {
            "description": "Get text content of an element, or empty string if the selector doesn\u0027t match any elements.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "param",
                "value": "selector CSS selector to find element"
              },
              {
                "name": "return",
                "value": "Text content of the first matching element, or empty string if none match"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getAttr",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "selector"
            },
            {
              "type": "String",
              "name": "attribute"
            }
          ],
          "body": "{\r\n        Element element \u003d document.select(selector).first();\r\n        return element !\u003d null ? element.attr(attribute) : \"\";\r\n    }",
          "javadoc": {
            "description": "Get attribute value of an element, or empty string if the selector doesn\u0027t match any elements.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document  The JSoup Document"
              },
              {
                "name": "param",
                "value": "selector  CSS selector to find element"
              },
              {
                "name": "param",
                "value": "attribute Attribute name to get"
              },
              {
                "name": "return",
                "value": "Attribute value of the first matching element, or empty string if none match"
              }
            ]
          },
          "comments": []
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/src/main/java/io/joshuasalcedo/KeyMappingDisplay.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "public",
          "methodName": "KeyMappingDisplay",
          "parameters": [],
          "body": "{\r\n        setTitle(\"IntelliJ Key Mappings\");\r\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n        setAlwaysOnTop(true);\r\n        setSize(450, 350);\r\n        \r\n        // Load initial data\r\n        initializeShortcuts();\r\n        \r\n        // Create the main panel with a border\r\n        mainPanel \u003d new JPanel(new BorderLayout());\r\n        mainPanel.setBorder(new EmptyBorder(10, 10, 10, 10));\r\n        \r\n        // Add control panel at the top\r\n        JPanel controlPanel \u003d new JPanel(new FlowLayout(FlowLayout.LEFT));\r\n        \r\n        // Create category selector\r\n        categoryComboBox \u003d new JComboBox\u003c\u003e(categoryShortcuts.keySet().toArray(new String[0]));\r\n        categoryComboBox.addActionListener(e -\u003e refreshTable());\r\n        controlPanel.add(new JLabel(\"Category:\"));\r\n        controlPanel.add(categoryComboBox);\r\n        \r\n        // Create edit mode toggle\r\n        editModeCheckBox \u003d new JCheckBox(\"Edit Mode\");\r\n        editModeCheckBox.addActionListener(e -\u003e refreshTable());\r\n        controlPanel.add(editModeCheckBox);\r\n        \r\n        // Add save button\r\n        JButton saveButton \u003d new JButton(\"Save\");\r\n        saveButton.addActionListener(e -\u003e saveShortcuts());\r\n        controlPanel.add(saveButton);\r\n        \r\n        mainPanel.add(controlPanel, BorderLayout.NORTH);\r\n        \r\n        // Create table for shortcuts\r\n        String[] columnNames \u003d {\"Shortcut\", \"Action\"};\r\n        tableModel \u003d new DefaultTableModel(columnNames, 0) {\r\n            @Override\r\n            public boolean isCellEditable(int row, int column) {\r\n                return editModeCheckBox.isSelected();\r\n            }\r\n        };\r\n        \r\n        shortcutsTable \u003d new JTable(tableModel);\r\n        shortcutsTable.setRowHeight(25);\r\n        shortcutsTable.getTableHeader().setReorderingAllowed(false);\r\n        \r\n        // Set column widths\r\n        shortcutsTable.getColumnModel().getColumn(0).setPreferredWidth(120);\r\n        shortcutsTable.getColumnModel().getColumn(1).setPreferredWidth(280);\r\n        \r\n        JScrollPane scrollPane \u003d new JScrollPane(shortcutsTable);\r\n        mainPanel.add(scrollPane, BorderLayout.CENTER);\r\n        \r\n        // Add a panel for the button at the bottom\r\n        JPanel bottomPanel \u003d new JPanel(new FlowLayout(FlowLayout.LEFT));\r\n        \r\n        JLabel opacityLabel \u003d new JLabel(\"Opacity:\");\r\n        bottomPanel.add(opacityLabel);\r\n        \r\n        // Add opacity slider\r\n        JSlider opacitySlider \u003d new JSlider(JSlider.HORIZONTAL, 10, 100, (int)(TRANSPARENCY * 100));\r\n        opacitySlider.addChangeListener(e -\u003e {\r\n            float opacity \u003d opacitySlider.getValue() / 100.0f;\r\n            setOpacity(opacity);\r\n        });\r\n        bottomPanel.add(opacitySlider);\r\n        \r\n        // Add control to add new entry\r\n        JButton addButton \u003d new JButton(\"Add Entry\");\r\n        addButton.addActionListener(e -\u003e addNewEntry());\r\n        bottomPanel.add(addButton);\r\n        \r\n        // Add to main panel\r\n        mainPanel.add(bottomPanel, BorderLayout.SOUTH);\r\n        \r\n        setContentPane(mainPanel);\r\n        \r\n        // Make window draggable\r\n        DragWindowListener dragListener \u003d new DragWindowListener();\r\n        addMouseListener(dragListener);\r\n        addMouseMotionListener(dragListener);\r\n        \r\n        // Refresh table with initial data\r\n        refreshTable();\r\n        \r\n        // Set transparency of the window\r\n        setOpacity(TRANSPARENCY);\r\n        \r\n        // Center on screen\r\n        setLocationRelativeTo(null);\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "data",
          "methodName": "initializeShortcuts",
          "parameters": [],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Load initial data",
            "Create the main panel with a border"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JPanel",
          "parameters": [
            {
              "type": "new",
              "name": "BorderLayout("
            }
          ],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Load initial data",
            "Create the main panel with a border"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "EmptyBorder",
          "parameters": [],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Load initial data",
            "Create the main panel with a border",
            "Add control panel at the top"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JPanel",
          "parameters": [
            {
              "type": "new",
              "name": "FlowLayout(FlowLayout.LEFT"
            }
          ],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Add control panel at the top",
            "Create category selector"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JLabel",
          "parameters": [],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Create"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JCheckBox",
          "parameters": [
            {
              "type": "\"Edit",
              "name": "Mode\""
            }
          ],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Create edit mode toggle"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JButton",
          "parameters": [],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Add save button"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "DefaultTableModel",
          "parameters": [],
          "body": "{\r\n            @Override\r\n            public boolean isCellEditable(int row, int column) {\r\n                return editModeCheckBox.isSelected();\r\n            }\r\n        }",
          "comments": [
            "Create table for shortcuts"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "boolean",
          "methodName": "isCellEditable",
          "parameters": [
            {
              "type": "int",
              "name": "row"
            },
            {
              "type": "int",
              "name": "column"
            }
          ],
          "body": "{\r\n                return editModeCheckBox.isSelected();\r\n            }",
          "comments": [
            "Create table for shortcuts"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JTable",
          "parameters": [],
          "body": "{\r\n            float opacity \u003d opacitySlider.getValue() / 100.0f;\r\n            setOpacity(opacity);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JScrollPane",
          "parameters": [],
          "body": "{\r\n            float opacity \u003d opacitySlider.getValue() / 100.0f;\r\n            setOpacity(opacity);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JPanel",
          "parameters": [
            {
              "type": "new",
              "name": "FlowLayout(FlowLayout.LEFT"
            }
          ],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Add a panel for the button at the bottom"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JLabel",
          "parameters": [],
          "body": "{\r\n            float opacity \u003d opacitySlider.getValue() / 100.0f;\r\n            setOpacity(opacity);\r\n        }",
          "comments": [
            "Add a panel for the button at the bottom",
            "Add opacity s"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JSlider",
          "parameters": [],
          "body": "{\r\n            float opacity \u003d opacitySlider.getValue() / 100.0f;\r\n            setOpacity(opacity);\r\n        }",
          "comments": [
            "Add opacity slider"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JButton",
          "parameters": [
            {
              "type": "\"Add",
              "name": "Entry\""
            }
          ],
          "body": "{\r\n        try {\r\n            File configFile \u003d new File(CONFIG_FILE);\r\n            if (configFile.exists()) {\r\n                loadFromFile();\r\n                return;\r\n            }\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error loading config: \" + e.getMessage());\r\n        }\r\n        \r\n        // Default shortcuts if file doesn\u0027t exist\r\n        List\u003cShortcutEntry\u003e navigationShortcuts \u003d new ArrayList\u003c\u003e();\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 1\", \"Toggle Project view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 2\", \"Toggle Bookmarks\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 3\", \"Toggle Structure view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 4\", \"Toggle Run/Debug tool window\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 5\", \"Toggle Terminal\"));\r\n        categoryShortcuts.put(\"Navigation\", navigationShortcuts);\r\n        \r\n        List\u003cShortcutEntry\u003e codeOperations \u003d new ArrayList\u003c\u003e();\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 7\", \"Generate Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 8\", \"Reformat Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 9\", \"Optimize Imports\"));\r\n        categoryShortcuts.put(\"Code Operations\", codeOperations);\r\n        \r\n        List\u003cShortcutEntry\u003e refactoring \u003d new ArrayList\u003c\u003e();\r\n        refactoring.add(new ShortcutEntry(\"ALT + 4\", \"Rename\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 5\", \"Extract Method\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 6\", \"Extract Variable/Constant\"));\r\n        categoryShortcuts.put(\"Refactoring\", refactoring);\r\n        \r\n        List\u003cShortcutEntry\u003e runDebug \u003d new ArrayList\u003c\u003e();\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad 0\", \"Run current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad .\", \"Debug current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad Enter\", \"Run with Coverage\"));\r\n        categoryShortcuts.put(\"Run \u0026 Debug\", runDebug);\r\n        \r\n        List\u003cShortcutEntry\u003e versionControl \u003d new ArrayList\u003c\u003e();\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad +\", \"Show diff\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad -\", \"Show history\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad *\", \"Commit changes\"));\r\n        categoryShortcuts.put(\"Version Control\", versionControl);\r\n        \r\n        List\u003cShortcutEntry\u003e codeAnalysis \u003d new ArrayList\u003c\u003e();\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad /\", \"Find Usages\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 1\", \"Go to Implementation\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 3\", \"Show quick documentation\"));\r\n        categoryShortcuts.put(\"Code Analysis\", codeAnalysis);\r\n    }",
          "comments": [
            "Add control to add new entry"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "DragWindowListener",
          "parameters": [],
          "body": "{\r\n        try {\r\n            File configFile \u003d new File(CONFIG_FILE);\r\n            if (configFile.exists()) {\r\n                loadFromFile();\r\n                return;\r\n            }\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error loading config: \" + e.getMessage());\r\n        }\r\n        \r\n        // Default shortcuts if file doesn\u0027t exist\r\n        List\u003cShortcutEntry\u003e navigationShortcuts \u003d new ArrayList\u003c\u003e();\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 1\", \"Toggle Project view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 2\", \"Toggle Bookmarks\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 3\", \"Toggle Structure view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 4\", \"Toggle Run/Debug tool window\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 5\", \"Toggle Terminal\"));\r\n        categoryShortcuts.put(\"Navigation\", navigationShortcuts);\r\n        \r\n        List\u003cShortcutEntry\u003e codeOperations \u003d new ArrayList\u003c\u003e();\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 7\", \"Generate Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 8\", \"Reformat Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 9\", \"Optimize Imports\"));\r\n        categoryShortcuts.put(\"Code Operations\", codeOperations);\r\n        \r\n        List\u003cShortcutEntry\u003e refactoring \u003d new ArrayList\u003c\u003e();\r\n        refactoring.add(new ShortcutEntry(\"ALT + 4\", \"Rename\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 5\", \"Extract Method\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 6\", \"Extract Variable/Constant\"));\r\n        categoryShortcuts.put(\"Refactoring\", refactoring);\r\n        \r\n        List\u003cShortcutEntry\u003e runDebug \u003d new ArrayList\u003c\u003e();\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad 0\", \"Run current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad .\", \"Debug current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad Enter\", \"Run with Coverage\"));\r\n        categoryShortcuts.put(\"Run \u0026 Debug\", runDebug);\r\n        \r\n        List\u003cShortcutEntry\u003e versionControl \u003d new ArrayList\u003c\u003e();\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad +\", \"Show diff\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad -\", \"Show history\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad *\", \"Commit changes\"));\r\n        categoryShortcuts.put(\"Version Control\", versionControl);\r\n        \r\n        List\u003cShortcutEntry\u003e codeAnalysis \u003d new ArrayList\u003c\u003e();\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad /\", \"Find Usages\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 1\", \"Go to Implementation\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 3\", \"Show quick documentation\"));\r\n        categoryShortcuts.put(\"Code Analysis\", codeAnalysis);\r\n    }",
          "comments": [
            "Make window draggable"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "data",
          "methodName": "refreshTable",
          "parameters": [],
          "body": "{\r\n        try {\r\n            File configFile \u003d new File(CONFIG_FILE);\r\n            if (configFile.exists()) {\r\n                loadFromFile();\r\n                return;\r\n            }\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error loading config: \" + e.getMessage());\r\n        }\r\n        \r\n        // Default shortcuts if file doesn\u0027t exist\r\n        List\u003cShortcutEntry\u003e navigationShortcuts \u003d new ArrayList\u003c\u003e();\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 1\", \"Toggle Project view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 2\", \"Toggle Bookmarks\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 3\", \"Toggle Structure view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 4\", \"Toggle Run/Debug tool window\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 5\", \"Toggle Terminal\"));\r\n        categoryShortcuts.put(\"Navigation\", navigationShortcuts);\r\n        \r\n        List\u003cShortcutEntry\u003e codeOperations \u003d new ArrayList\u003c\u003e();\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 7\", \"Generate Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 8\", \"Reformat Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 9\", \"Optimize Imports\"));\r\n        categoryShortcuts.put(\"Code Operations\", codeOperations);\r\n        \r\n        List\u003cShortcutEntry\u003e refactoring \u003d new ArrayList\u003c\u003e();\r\n        refactoring.add(new ShortcutEntry(\"ALT + 4\", \"Rename\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 5\", \"Extract Method\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 6\", \"Extract Variable/Constant\"));\r\n        categoryShortcuts.put(\"Refactoring\", refactoring);\r\n        \r\n        List\u003cShortcutEntry\u003e runDebug \u003d new ArrayList\u003c\u003e();\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad 0\", \"Run current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad .\", \"Debug current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad Enter\", \"Run with Coverage\"));\r\n        categoryShortcuts.put(\"Run \u0026 Debug\", runDebug);\r\n        \r\n        List\u003cShortcutEntry\u003e versionControl \u003d new ArrayList\u003c\u003e();\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad +\", \"Show diff\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad -\", \"Show history\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad *\", \"Commit changes\"));\r\n        categoryShortcuts.put(\"Version Control\", versionControl);\r\n        \r\n        List\u003cShortcutEntry\u003e codeAnalysis \u003d new ArrayList\u003c\u003e();\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad /\", \"Find Usages\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 1\", \"Go to Implementation\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 3\", \"Show quick documentation\"));\r\n        categoryShortcuts.put(\"Code Analysis\", codeAnalysis);\r\n    }",
          "comments": [
            "Refresh table with initial data",
            "Set transparency of the window"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "window",
          "methodName": "setOpacity",
          "parameters": [],
          "body": "{\r\n        try {\r\n            File configFile \u003d new File(CONFIG_FILE);\r\n            if (configFile.exists()) {\r\n                loadFromFile();\r\n                return;\r\n            }\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error loading config: \" + e.getMessage());\r\n        }\r\n        \r\n        // Default shortcuts if file doesn\u0027t exist\r\n        List\u003cShortcutEntry\u003e navigationShortcuts \u003d new ArrayList\u003c\u003e();\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 1\", \"Toggle Project view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 2\", \"Toggle Bookmarks\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 3\", \"Toggle Structure view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 4\", \"Toggle Run/Debug tool window\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 5\", \"Toggle Terminal\"));\r\n        categoryShortcuts.put(\"Navigation\", navigationShortcuts);\r\n        \r\n        List\u003cShortcutEntry\u003e codeOperations \u003d new ArrayList\u003c\u003e();\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 7\", \"Generate Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 8\", \"Reformat Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 9\", \"Optimize Imports\"));\r\n        categoryShortcuts.put(\"Code Operations\", codeOperations);\r\n        \r\n        List\u003cShortcutEntry\u003e refactoring \u003d new ArrayList\u003c\u003e();\r\n        refactoring.add(new ShortcutEntry(\"ALT + 4\", \"Rename\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 5\", \"Extract Method\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 6\", \"Extract Variable/Constant\"));\r\n        categoryShortcuts.put(\"Refactoring\", refactoring);\r\n        \r\n        List\u003cShortcutEntry\u003e runDebug \u003d new ArrayList\u003c\u003e();\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad 0\", \"Run current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad .\", \"Debug current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad Enter\", \"Run with Coverage\"));\r\n        categoryShortcuts.put(\"Run \u0026 Debug\", runDebug);\r\n        \r\n        List\u003cShortcutEntry\u003e versionControl \u003d new ArrayList\u003c\u003e();\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad +\", \"Show diff\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad -\", \"Show history\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad *\", \"Commit changes\"));\r\n        categoryShortcuts.put(\"Version Control\", versionControl);\r\n        \r\n        List\u003cShortcutEntry\u003e codeAnalysis \u003d new ArrayList\u003c\u003e();\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad /\", \"Find Usages\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 1\", \"Go to Implementation\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 3\", \"Show quick documentation\"));\r\n        categoryShortcuts.put(\"Code Analysis\", codeAnalysis);\r\n    }",
          "comments": [
            "Refresh table with initial data",
            "Set transparency of the window",
            "Center on screen"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "screen",
          "methodName": "setLocationRelativeTo",
          "parameters": [],
          "body": "{\r\n        try {\r\n            File configFile \u003d new File(CONFIG_FILE);\r\n            if (configFile.exists()) {\r\n                loadFromFile();\r\n                return;\r\n            }\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error loading config: \" + e.getMessage());\r\n        }\r\n        \r\n        // Default shortcuts if file doesn\u0027t exist\r\n        List\u003cShortcutEntry\u003e navigationShortcuts \u003d new ArrayList\u003c\u003e();\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 1\", \"Toggle Project view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 2\", \"Toggle Bookmarks\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 3\", \"Toggle Structure view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 4\", \"Toggle Run/Debug tool window\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 5\", \"Toggle Terminal\"));\r\n        categoryShortcuts.put(\"Navigation\", navigationShortcuts);\r\n        \r\n        List\u003cShortcutEntry\u003e codeOperations \u003d new ArrayList\u003c\u003e();\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 7\", \"Generate Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 8\", \"Reformat Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 9\", \"Optimize Imports\"));\r\n        categoryShortcuts.put(\"Code Operations\", codeOperations);\r\n        \r\n        List\u003cShortcutEntry\u003e refactoring \u003d new ArrayList\u003c\u003e();\r\n        refactoring.add(new ShortcutEntry(\"ALT + 4\", \"Rename\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 5\", \"Extract Method\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 6\", \"Extract Variable/Constant\"));\r\n        categoryShortcuts.put(\"Refactoring\", refactoring);\r\n        \r\n        List\u003cShortcutEntry\u003e runDebug \u003d new ArrayList\u003c\u003e();\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad 0\", \"Run current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad .\", \"Debug current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad Enter\", \"Run with Coverage\"));\r\n        categoryShortcuts.put(\"Run \u0026 Debug\", runDebug);\r\n        \r\n        List\u003cShortcutEntry\u003e versionControl \u003d new ArrayList\u003c\u003e();\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad +\", \"Show diff\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad -\", \"Show history\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad *\", \"Commit changes\"));\r\n        categoryShortcuts.put(\"Version Control\", versionControl);\r\n        \r\n        List\u003cShortcutEntry\u003e codeAnalysis \u003d new ArrayList\u003c\u003e();\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad /\", \"Find Usages\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 1\", \"Go to Implementation\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 3\", \"Show quick documentation\"));\r\n        categoryShortcuts.put(\"Code Analysis\", codeAnalysis);\r\n    }",
          "comments": [
            "Refresh table with initial data",
            "Set transparency of the window",
            "Center on screen"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "initializeShortcuts",
          "parameters": [],
          "body": "{\r\n        try {\r\n            File configFile \u003d new File(CONFIG_FILE);\r\n            if (configFile.exists()) {\r\n                loadFromFile();\r\n                return;\r\n            }\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error loading config: \" + e.getMessage());\r\n        }\r\n        \r\n        // Default shortcuts if file doesn\u0027t exist\r\n        List\u003cShortcutEntry\u003e navigationShortcuts \u003d new ArrayList\u003c\u003e();\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 1\", \"Toggle Project view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 2\", \"Toggle Bookmarks\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 3\", \"Toggle Structure view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 4\", \"Toggle Run/Debug tool window\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 5\", \"Toggle Terminal\"));\r\n        categoryShortcuts.put(\"Navigation\", navigationShortcuts);\r\n        \r\n        List\u003cShortcutEntry\u003e codeOperations \u003d new ArrayList\u003c\u003e();\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 7\", \"Generate Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 8\", \"Reformat Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 9\", \"Optimize Imports\"));\r\n        categoryShortcuts.put(\"Code Operations\", codeOperations);\r\n        \r\n        List\u003cShortcutEntry\u003e refactoring \u003d new ArrayList\u003c\u003e();\r\n        refactoring.add(new ShortcutEntry(\"ALT + 4\", \"Rename\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 5\", \"Extract Method\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 6\", \"Extract Variable/Constant\"));\r\n        categoryShortcuts.put(\"Refactoring\", refactoring);\r\n        \r\n        List\u003cShortcutEntry\u003e runDebug \u003d new ArrayList\u003c\u003e();\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad 0\", \"Run current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad .\", \"Debug current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad Enter\", \"Run with Coverage\"));\r\n        categoryShortcuts.put(\"Run \u0026 Debug\", runDebug);\r\n        \r\n        List\u003cShortcutEntry\u003e versionControl \u003d new ArrayList\u003c\u003e();\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad +\", \"Show diff\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad -\", \"Show history\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad *\", \"Commit changes\"));\r\n        categoryShortcuts.put(\"Version Control\", versionControl);\r\n        \r\n        List\u003cShortcutEntry\u003e codeAnalysis \u003d new ArrayList\u003c\u003e();\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad /\", \"Find Usages\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 1\", \"Go to Implementation\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 3\", \"Show quick documentation\"));\r\n        categoryShortcuts.put(\"Code Analysis\", codeAnalysis);\r\n    }",
          "comments": [
            "Set transparency of the window",
            "Center on screen"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                loadFromFile();\r\n                return;\r\n            }",
          "comments": [
            "Center on screen"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Toggle",
              "name": "Project"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": [
            "Default shortcuts if file doesn\u0027t exist"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Toggle",
              "name": "Bookmarks\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Toggle",
              "name": "Structure"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Toggle",
              "name": "Run/Debug"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Toggle",
              "name": "Terminal\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Generate",
              "name": "Code\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Reformat",
              "name": "Code\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Optimize",
              "name": "Imports\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Extract",
              "name": "Method\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Extract",
              "name": "Variable/Constant\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Run",
              "name": "current"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Debug",
              "name": "current"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Run",
              "name": "with"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Show",
              "name": "diff\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Show",
              "name": "history\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Commit",
              "name": "changes\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Find",
              "name": "Usages\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Go",
              "name": "to"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Show",
              "name": "quick"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "refreshTable",
          "parameters": [],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "addNewEntry",
          "parameters": [],
          "body": "{\r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        entries.add(new ShortcutEntry(\"New Shortcut\", \"New Action\"));\r\n        refreshTable();\r\n        \r\n        // Set focus on the new row for editing\r\n        int lastRow \u003d tableModel.getRowCount() - 1;\r\n        shortcutsTable.editCellAt(lastRow, 0);\r\n        shortcutsTable.getEditorComponent().requestFocus();\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"New",
              "name": "Shortcut\""
            },
            {
              "type": "\"New",
              "name": "Action\""
            }
          ],
          "body": "{\r\n        // First update the current category from the table\r\n        updateCurrentCategoryFromTable();\r\n        \r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(CONFIG_FILE))) {\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                writer.println(\"[\" + category + \"]\");\r\n                \r\n                List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(category);\r\n                for (ShortcutEntry entry : entries) {\r\n                    writer.println(entry.shortcut + \"\u003d\" + entry.action);\r\n                }\r\n                \r\n                writer.println(); // Empty line between categories\r\n            }\r\n            JOptionPane.showMessageDialog(this, \"Settings saved successfully!\", \r\n                    \"Save Complete\", JOptionPane.INFORMATION_MESSAGE);\r\n        } catch (IOException e) {\r\n            JOptionPane.showMessageDialog(this, \"Error saving settings: \" + e.getMessage(), \r\n                    \"Save Error\", JOptionPane.ERROR_MESSAGE);\r\n        }\r\n    }",
          "comments": [
            "Set"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "saveShortcuts",
          "parameters": [],
          "body": "{\r\n        // First update the current category from the table\r\n        updateCurrentCategoryFromTable();\r\n        \r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(CONFIG_FILE))) {\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                writer.println(\"[\" + category + \"]\");\r\n                \r\n                List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(category);\r\n                for (ShortcutEntry entry : entries) {\r\n                    writer.println(entry.shortcut + \"\u003d\" + entry.action);\r\n                }\r\n                \r\n                writer.println(); // Empty line between categories\r\n            }\r\n            JOptionPane.showMessageDialog(this, \"Settings saved successfully!\", \r\n                    \"Save Complete\", JOptionPane.INFORMATION_MESSAGE);\r\n        } catch (IOException e) {\r\n            JOptionPane.showMessageDialog(this, \"Error saving settings: \" + e.getMessage(), \r\n                    \"Save Error\", JOptionPane.ERROR_MESSAGE);\r\n        }\r\n    }",
          "comments": [
            "First update the current category from the table"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "table",
          "methodName": "updateCurrentCategoryFromTable",
          "parameters": [],
          "body": "{\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                writer.println(\"[\" + category + \"]\");\r\n                \r\n                List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(category);\r\n                for (ShortcutEntry entry : entries) {\r\n                    writer.println(entry.shortcut + \"\u003d\" + entry.action);\r\n                }\r\n                \r\n                writer.println(); // Empty line between categories\r\n            }\r\n            JOptionPane.showMessageDialog(this, \"Settings saved successfully!\", \r\n                    \"Save Complete\", JOptionPane.INFORMATION_MESSAGE);\r\n        }",
          "comments": [
            "First update the current category from the table"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(CONFIG_FILE"
            }
          ],
          "body": "{\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                writer.println(\"[\" + category + \"]\");\r\n                \r\n                List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(category);\r\n                for (ShortcutEntry entry : entries) {\r\n                    writer.println(entry.shortcut + \"\u003d\" + entry.action);\r\n                }\r\n                \r\n                writer.println(); // Empty line between categories\r\n            }\r\n            JOptionPane.showMessageDialog(this, \"Settings saved successfully!\", \r\n                    \"Save Complete\", JOptionPane.INFORMATION_MESSAGE);\r\n        }",
          "comments": [
            "First update the current category from the table"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "updateCurrentCategoryFromTable",
          "parameters": [],
          "body": "{\r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d new ArrayList\u003c\u003e();\r\n        for (int i \u003d 0; i \u003c tableModel.getRowCount(); i++) {\r\n            String shortcut \u003d (String) tableModel.getValueAt(i, 0);\r\n            String action \u003d (String) tableModel.getValueAt(i, 1);\r\n            entries.add(new ShortcutEntry(shortcut, action));\r\n        }\r\n        \r\n        categoryShortcuts.put(selectedCategory, entries);\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [],
          "body": "{\r\n        categoryShortcuts.clear();\r\n        \r\n        try (BufferedReader reader \u003d new BufferedReader(new FileReader(CONFIG_FILE))) {\r\n            String line;\r\n            String currentCategory \u003d null;\r\n            List\u003cShortcutEntry\u003e currentEntries \u003d null;\r\n            \r\n            while ((line \u003d reader.readLine()) !\u003d null) {\r\n                line \u003d line.trim();\r\n                if (line.isEmpty()) continue;\r\n                \r\n                if (line.startsWith(\"[\") \u0026\u0026 line.endsWith(\"]\")) {\r\n                    // Save previous category if needed\r\n                    if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                        categoryShortcuts.put(currentCategory, currentEntries);\r\n                    }\r\n                    \r\n                    // Start new category\r\n                    currentCategory \u003d line.substring(1, line.length() - 1);\r\n                    currentEntries \u003d new ArrayList\u003c\u003e();\r\n                } else if (currentCategory !\u003d null \u0026\u0026 line.contains(\"\u003d\")) {\r\n                    // Parse shortcut entry\r\n                    int separatorIndex \u003d line.indexOf(\u0027\u003d\u0027);\r\n                    String shortcut \u003d line.substring(0, separatorIndex);\r\n                    String action \u003d line.substring(separatorIndex + 1);\r\n                    currentEntries.add(new ShortcutEntry(shortcut, action));\r\n                }\r\n            }\r\n            \r\n            // Save last category\r\n            if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                categoryShortcuts.put(currentCategory, currentEntries);\r\n            }\r\n            \r\n            // Update combo box with loaded categories\r\n            categoryComboBox.removeAllItems();\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                categoryComboBox.addItem(category);\r\n            }\r\n        } catch (IOException e) {\r\n            System.err.println(\"Error reading config file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "loadFromFile",
          "parameters": [],
          "body": "{\r\n        categoryShortcuts.clear();\r\n        \r\n        try (BufferedReader reader \u003d new BufferedReader(new FileReader(CONFIG_FILE))) {\r\n            String line;\r\n            String currentCategory \u003d null;\r\n            List\u003cShortcutEntry\u003e currentEntries \u003d null;\r\n            \r\n            while ((line \u003d reader.readLine()) !\u003d null) {\r\n                line \u003d line.trim();\r\n                if (line.isEmpty()) continue;\r\n                \r\n                if (line.startsWith(\"[\") \u0026\u0026 line.endsWith(\"]\")) {\r\n                    // Save previous category if needed\r\n                    if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                        categoryShortcuts.put(currentCategory, currentEntries);\r\n                    }\r\n                    \r\n                    // Start new category\r\n                    currentCategory \u003d line.substring(1, line.length() - 1);\r\n                    currentEntries \u003d new ArrayList\u003c\u003e();\r\n                } else if (currentCategory !\u003d null \u0026\u0026 line.contains(\"\u003d\")) {\r\n                    // Parse shortcut entry\r\n                    int separatorIndex \u003d line.indexOf(\u0027\u003d\u0027);\r\n                    String shortcut \u003d line.substring(0, separatorIndex);\r\n                    String action \u003d line.substring(separatorIndex + 1);\r\n                    currentEntries.add(new ShortcutEntry(shortcut, action));\r\n                }\r\n            }\r\n            \r\n            // Save last category\r\n            if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                categoryShortcuts.put(currentCategory, currentEntries);\r\n            }\r\n            \r\n            // Update combo box with loaded categories\r\n            categoryComboBox.removeAllItems();\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                categoryComboBox.addItem(category);\r\n            }\r\n        } catch (IOException e) {\r\n            System.err.println(\"Error reading config file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "BufferedReader",
          "parameters": [
            {
              "type": "new",
              "name": "FileReader(CONFIG_FILE"
            }
          ],
          "body": "{\r\n            String line;\r\n            String currentCategory \u003d null;\r\n            List\u003cShortcutEntry\u003e currentEntries \u003d null;\r\n            \r\n            while ((line \u003d reader.readLine()) !\u003d null) {\r\n                line \u003d line.trim();\r\n                if (line.isEmpty()) continue;\r\n                \r\n                if (line.startsWith(\"[\") \u0026\u0026 line.endsWith(\"]\")) {\r\n                    // Save previous category if needed\r\n                    if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                        categoryShortcuts.put(currentCategory, currentEntries);\r\n                    }\r\n                    \r\n                    // Start new category\r\n                    currentCategory \u003d line.substring(1, line.length() - 1);\r\n                    currentEntries \u003d new ArrayList\u003c\u003e();\r\n                } else if (currentCategory !\u003d null \u0026\u0026 line.contains(\"\u003d\")) {\r\n                    // Parse shortcut entry\r\n                    int separatorIndex \u003d line.indexOf(\u0027\u003d\u0027);\r\n                    String shortcut \u003d line.substring(0, separatorIndex);\r\n                    String action \u003d line.substring(separatorIndex + 1);\r\n                    currentEntries.add(new ShortcutEntry(shortcut, action));\r\n                }\r\n            }\r\n            \r\n            // Save last category\r\n            if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                categoryShortcuts.put(currentCategory, currentEntries);\r\n            }\r\n            \r\n            // Update combo box with loaded categories\r\n            categoryComboBox.removeAllItems();\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                categoryComboBox.addItem(category);\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "needed",
          "methodName": "if",
          "parameters": [
            {
              "type": "currentCategory",
              "name": "!\u003d"
            }
          ],
          "body": "{\r\n                        categoryShortcuts.put(currentCategory, currentEntries);\r\n                    }",
          "comments": [
            "Save previous category if needed"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [
            {
              "type": "currentCategory",
              "name": "!\u003d"
            }
          ],
          "body": "{\r\n                    // Parse shortcut entry\r\n                    int separatorIndex \u003d line.indexOf(\u0027\u003d\u0027);\r\n                    String shortcut \u003d line.substring(0, separatorIndex);\r\n                    String action \u003d line.substring(separatorIndex + 1);\r\n                    currentEntries.add(new ShortcutEntry(shortcut, action));\r\n                }",
          "comments": [
            "Start new category",
            "Parse shortcut en"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [],
          "body": "{\r\n        categoryShortcuts.clear();\r\n        \r\n        try (BufferedReader reader \u003d new BufferedReader(new FileReader(CONFIG_FILE))) {\r\n            String line;\r\n            String currentCategory \u003d null;\r\n            List\u003cShortcutEntry\u003e currentEntries \u003d null;\r\n            \r\n            while ((line \u003d reader.readLine()) !\u003d null) {\r\n                line \u003d line.trim();\r\n                if (line.isEmpty()) continue;\r\n                \r\n                if (line.startsWith(\"[\") \u0026\u0026 line.endsWith(\"]\")) {\r\n                    // Save previous category if needed\r\n                    if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                        categoryShortcuts.put(currentCategory, currentEntries);\r\n                    }\r\n                    \r\n                    // Start new category\r\n                    currentCategory \u003d line.substring(1, line.length() - 1);\r\n                    currentEntries \u003d new ArrayList\u003c\u003e();\r\n                } else if (currentCategory !\u003d null \u0026\u0026 line.contains(\"\u003d\")) {\r\n                    // Parse shortcut entry\r\n                    int separatorIndex \u003d line.indexOf(\u0027\u003d\u0027);\r\n                    String shortcut \u003d line.substring(0, separatorIndex);\r\n                    String action \u003d line.substring(separatorIndex + 1);\r\n                    currentEntries.add(new ShortcutEntry(shortcut, action));\r\n                }\r\n            }\r\n            \r\n            // Save last category\r\n            if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                categoryShortcuts.put(currentCategory, currentEntries);\r\n            }\r\n            \r\n            // Update combo box with loaded categories\r\n            categoryComboBox.removeAllItems();\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                categoryComboBox.addItem(category);\r\n            }\r\n        } catch (IOException e) {\r\n            System.err.println(\"Error reading config file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "category",
          "methodName": "if",
          "parameters": [
            {
              "type": "currentCategory",
              "name": "!\u003d"
            }
          ],
          "body": "{\r\n                categoryShortcuts.put(currentCategory, currentEntries);\r\n            }",
          "comments": [
            "Save last category"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "mousePressed",
          "parameters": [
            {
              "type": "MouseEvent",
              "name": "e"
            }
          ],
          "body": "{\r\n            dragStart \u003d e.getPoint();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "mouseDragged",
          "parameters": [
            {
              "type": "MouseEvent",
              "name": "e"
            }
          ],
          "body": "{\r\n            if (dragStart !\u003d null) {\r\n                Point currentLocation \u003d getLocation();\r\n                setLocation(\r\n                    currentLocation.x + e.getX() - dragStart.x,\r\n                    currentLocation.y + e.getY() - dragStart.y\r\n                );\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "mouseReleased",
          "parameters": [
            {
              "type": "MouseEvent",
              "name": "e"
            }
          ],
          "body": "{\r\n            dragStart \u003d null;\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "main",
          "parameters": [
            {
              "type": "String[]",
              "name": "args"
            }
          ],
          "body": "{\r\n        // Set look and feel to system default\r\n        try {\r\n            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        \r\n        // Enable anti-aliased text\r\n        System.setProperty(\"awt.useSystemAAFontSettings\", \"on\");\r\n        System.setProperty(\"swing.aatext\", \"true\");\r\n        \r\n        SwingUtilities.invokeLater(() -\u003e {\r\n            KeyMappingDisplay display \u003d new KeyMappingDisplay();\r\n            display.setVisible(true);\r\n        });\r\n    }",
          "comments": [
            "Set look and feel to system default"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "KeyMappingDisplay",
          "parameters": [],
          "body": "",
          "comments": []
        }
      ],
      "className": "KeyMappingDisplay",
      "packageName": "io.joshuasalcedo"
    }
  ]
}