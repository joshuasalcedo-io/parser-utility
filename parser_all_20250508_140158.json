{
  "gitRepository": {
    "name": ".",
    "path": "/home/joshuasalcedo-io/parser-utility/.",
    "currentBranch": "main",
    "remoteUrl": "git@github.com:joshuasalcedo-io/parser-utility.git",
    "branches": [
      {
        "name": "main",
        "current": true,
        "remote": false,
        "commitId": "8aa2d9c9edcb5a23dc3080c1d67c038729156a9f",
        "merged": true
      },
      {
        "name": "main",
        "current": false,
        "remote": true,
        "remoteName": "remotes/origin",
        "commitId": "8aa2d9c9edcb5a23dc3080c1d67c038729156a9f",
        "merged": false
      }
    ],
    "tags": [],
    "hasUncommittedChanges": true,
    "commitCount": 7,
    "statistics": {
      "commitsPerDayOfWeek": {
        "Monday": 0,
        "Thursday": 0,
        "Friday": 0,
        "Sunday": 0,
        "Wednesday": 7,
        "Tuesday": 0,
        "Saturday": 0
      },
      "totalCommits": 7,
      "commitsPerHour": {
        "0": 0,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 0,
        "5": 0,
        "6": 0,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0,
        "12": 5,
        "13": 0,
        "14": 0,
        "15": 0,
        "16": 0,
        "17": 0,
        "18": 0,
        "19": 0,
        "20": 0,
        "21": 0,
        "22": 0,
        "23": 2
      },
      "averageChangedFilesPerCommit": 5.142857142857143,
      "commitsPerMonth": {
        "June": 0,
        "October": 0,
        "December": 0,
        "May": 7,
        "September": 0,
        "March": 0,
        "July": 0,
        "January": 0,
        "February": 0,
        "April": 0,
        "August": 0,
        "November": 0
      }
    },
    "topContributors": [
      {
        "name": "joshuasalcedo-dev",
        "email": "dev@joshuasalcedo.io",
        "commitCount": 7,
        "linesAdded": 5455,
        "linesDeleted": 847,
        "firstCommitDate": "May 7, 2025, 12:24:30 PM",
        "lastCommitDate": "May 7, 2025, 11:55:09 PM"
      }
    ],
    "creationDate": "May 7, 2025, 11:55:09 PM",
    "fileExtensionCounts": {}
  },
  "fileStatistics": {
    "pomFiles": 2,
    "totalFiles": 363,
    "javaFiles": 43,
    "htmlFiles": 1
  },
  "pomFiles": [
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./pom.xml",
      "groupId": "io.joshuasalcedo",
      "name": "Java Structure Analyzer",
      "description": "A utility to analyze Java source files and output their structure in JSON format",
      "artifactId": "parser-utility",
      "version": "1.0.0",
      "dependencies": [
        {
          "groupId": "org.junit.jupiter",
          "scope": "test",
          "artifactId": "junit-jupiter",
          "version": "5.10.2"
        },
        {
          "groupId": "com.google.code.gson",
          "artifactId": "gson",
          "version": "2.13.1"
        },
        {
          "groupId": "commons-io",
          "artifactId": "commons-io",
          "version": "2.19.0"
        },
        {
          "groupId": "org.apache.maven",
          "artifactId": "maven-model",
          "version": "4.0.0-rc-3"
        },
        {
          "groupId": "org.apache.maven",
          "artifactId": "maven-api-model",
          "version": "4.0.0-rc-3"
        },
        {
          "groupId": "org.eclipse.jgit",
          "artifactId": "org.eclipse.jgit",
          "version": "7.2.0.202503040940-r"
        },
        {
          "groupId": "org.commonmark",
          "artifactId": "commonmark",
          "version": "0.24.0"
        },
        {
          "groupId": "org.projectlombok",
          "scope": "provided",
          "artifactId": "lombok",
          "version": "1.18.38"
        },
        {
          "groupId": "org.commonmark",
          "artifactId": "commonmark-ext-autolink",
          "version": "0.24.0"
        },
        {
          "groupId": "org.commonmark",
          "artifactId": "commonmark-ext-gfm-tables",
          "version": "0.24.0"
        },
        {
          "groupId": "org.jsoup",
          "artifactId": "jsoup",
          "version": "1.20.1"
        },
        {
          "groupId": "org.commonmark",
          "artifactId": "commonmark-ext-gfm-strikethrough",
          "version": "0.24.0"
        },
        {
          "groupId": "org.commonmark",
          "artifactId": "commonmark-ext-heading-anchor",
          "version": "0.24.0"
        },
        {
          "groupId": "org.commonmark",
          "artifactId": "commonmark-ext-yaml-front-matter",
          "version": "0.24.0"
        },
        {
          "groupId": "org.commonmark",
          "artifactId": "commonmark-ext-ins",
          "version": "0.24.0"
        },
        {
          "groupId": "io.joshuasalcedo",
          "artifactId": "boot-utility-starter",
          "version": "1.0-SNAPSHOT"
        }
      ]
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/test/resources/test/pom/sample-project/pom.xml",
      "groupId": "com.example",
      "artifactId": "multi-module-parent",
      "version": "1.0.0",
      "dependencies": []
    }
  ],
  "javaFiles": [
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/ParserRunner.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "main",
          "parameters": [
            {
              "type": "String[]",
              "name": "args"
            }
          ],
          "body": "{\r\n        if (args.length \u003d\u003d 0) {\r\n            System.out.println(ConsoleFormatterFactory.createMessage(\"No arguments provided. Use \u0027help\u0027 for usage information.\", MessageType.WARNING));\r\n            help();\r\n            return;\r\n        }\r\n\r\n        String command \u003d args[0];\r\n\r\n        switch (command) {\r\n            case \"help\":\r\n                help();\r\n                break;\r\n            case \"all\":\r\n                if (args.length \u003c 2) {\r\n                    System.out.println(ConsoleFormatterFactory.createMessage(\"Please provide a directory path.\", MessageType.ERROR));\r\n                    return;\r\n                }\r\n                parseAll(args[1]);\r\n                break;\r\n            case \"java\":\r\n                if (args.length \u003c 2) {\r\n                    System.out.println(ConsoleFormatterFactory.createMessage(\"Please provide a directory path.\", MessageType.ERROR));\r\n                    return;\r\n                }\r\n                parseJava(args[1]);\r\n                break;\r\n            case \"git\":\r\n                if (args.length \u003c 2) {\r\n                    System.out.println(ConsoleFormatterFactory.createMessage(\"Please provide a directory path.\", MessageType.ERROR));\r\n                    return;\r\n                }\r\n                parseGit(args[1]);\r\n                break;\r\n            case \"pom\":\r\n                if (args.length \u003c 2) {\r\n                    System.out.println(ConsoleFormatterFactory.createMessage(\"Please provide a directory path.\", MessageType.ERROR));\r\n                    return;\r\n                }\r\n                parsePom(args[1]);\r\n                break;\r\n            case \"html\":\r\n                if (args.length \u003c 2) {\r\n                    System.out.println(ConsoleFormatterFactory.createMessage(\"Please provide a directory path.\", MessageType.ERROR));\r\n                    return;\r\n                }\r\n                parseHtml(args[1]);\r\n                break;\r\n            case \"version\":\r\n                showVersion();\r\n                break;\r\n            default:\r\n                // Assume it\u0027s a file path and try to parse it based on extension\r\n                parseFile(command);\r\n                break;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "extension",
          "methodName": "parseFile",
          "parameters": [],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"PARSING ALL\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Parsing directory: \" + directory, MessageType.INFO));\r\n\r\n        try {\r\n            File dir \u003d new File(directory);\r\n            if (!dir.exists() || !dir.isDirectory()) {\r\n                System.out.println(ConsoleFormatterFactory.createMessage(\"Directory does not exist: \" + directory, MessageType.ERROR));\r\n                return;\r\n            }\r\n\r\n            Map\u003cString, Object\u003e result \u003d Parser.parse.all(directory);\r\n            String outputPath \u003d saveResultToJsonFile(result, directory, \"all\");\r\n            outputResult(result, outputPath);\r\n\r\n        } catch (Exception e) {\r\n            System.out.println(ConsoleFormatterFactory.createMessage(\"Error parsing directory: \" + e.getMessage(), MessageType.ERROR));\r\n            e.printStackTrace();\r\n        }\r\n    }",
          "comments": [
            "Assume it\u0027s a file path and try to parse it based on extension"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "parseAll",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"PARSING ALL\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Parsing directory: \" + directory, MessageType.INFO));\r\n\r\n        try {\r\n            File dir \u003d new File(directory);\r\n            if (!dir.exists() || !dir.isDirectory()) {\r\n                System.out.println(ConsoleFormatterFactory.createMessage(\"Directory does not exist: \" + directory, MessageType.ERROR));\r\n                return;\r\n            }\r\n\r\n            Map\u003cString, Object\u003e result \u003d Parser.parse.all(directory);\r\n            String outputPath \u003d saveResultToJsonFile(result, directory, \"all\");\r\n            outputResult(result, outputPath);\r\n\r\n        } catch (Exception e) {\r\n            System.out.println(ConsoleFormatterFactory.createMessage(\"Error parsing directory: \" + e.getMessage(), MessageType.ERROR));\r\n            e.printStackTrace();\r\n        }\r\n    }",
          "comments": [
            "Assume it\u0027s a file path and try to parse it based on extension"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                System.out.println(ConsoleFormatterFactory.createMessage(\"Directory does not exist: \" + directory, MessageType.ERROR));\r\n                return;\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "parseJava",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"PARSING JAVA FILES\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Parsing Java files in: \" + directory, MessageType.INFO));\r\n\r\n        try {\r\n            Map\u003cString, Object\u003e result \u003d Parser.parse.java(directory);\r\n            String outputPath \u003d saveResultToJsonFile(result, directory, \"java\");\r\n            outputResult(result, outputPath);\r\n        } catch (Exception e) {\r\n            System.out.println(ConsoleFormatterFactory.createMessage(\"Error parsing Java files: \" + e.getMessage(), MessageType.ERROR));\r\n            e.printStackTrace();\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "parseGit",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"PARSING GIT REPOSITORY\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Parsing Git repository in: \" + directory, MessageType.INFO));\r\n\r\n        try {\r\n            Map\u003cString, Object\u003e result \u003d Parser.parse.git(directory);\r\n            String outputPath \u003d saveResultToJsonFile(result, directory, \"git\");\r\n            outputResult(result, outputPath);\r\n        } catch (Exception e) {\r\n            System.out.println(ConsoleFormatterFactory.createMessage(\"Error parsing Git repository: \" + e.getMessage(), MessageType.ERROR));\r\n            e.printStackTrace();\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "parsePom",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"PARSING POM FILES\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Parsing POM files in: \" + directory, MessageType.INFO));\r\n\r\n        try {\r\n            Map\u003cString, Object\u003e result \u003d Parser.parse.pom(directory);\r\n            String outputPath \u003d saveResultToJsonFile(result, directory, \"pom\");\r\n            outputResult(result, outputPath);\r\n        } catch (Exception e) {\r\n            System.out.println(ConsoleFormatterFactory.createMessage(\"Error parsing POM files: \" + e.getMessage(), MessageType.ERROR));\r\n            e.printStackTrace();\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "parseHtml",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"PARSING HTML FILES\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Parsing HTML files in: \" + directory, MessageType.INFO));\r\n\r\n        try {\r\n            Map\u003cString, Object\u003e result \u003d Parser.parse.html(directory);\r\n            String outputPath \u003d saveResultToJsonFile(result, directory, \"html\");\r\n            outputResult(result, outputPath);\r\n        } catch (Exception e) {\r\n            System.out.println(ConsoleFormatterFactory.createMessage(\"Error parsing HTML files: \" + e.getMessage(), MessageType.ERROR));\r\n            e.printStackTrace();\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "parseFile",
          "parameters": [
            {
              "type": "String",
              "name": "filePath"
            }
          ],
          "body": "{\r\n        File file \u003d new File(filePath);\r\n        if (!file.exists()) {\r\n            System.out.println(ConsoleFormatterFactory.createMessage(\"File does not exist: \" + filePath, MessageType.ERROR));\r\n            return;\r\n        }\r\n\r\n        String fileName \u003d file.getName().toLowerCase();\r\n\r\n        try {\r\n            if (fileName.endsWith(\".java\")) {\r\n                System.out.println(ConsoleFormatterFactory.createDivider(\"PARSING JAVA FILE\"));\r\n                // For single file parsing, you might need to add a method in your Parser class\r\n                System.out.println(ConsoleFormatterFactory.createMessage(\"Java file parsing not implemented for single files yet.\", MessageType.WARNING));\r\n            } else if (fileName.endsWith(\".html\") || fileName.endsWith(\".htm\")) {\r\n                System.out.println(ConsoleFormatterFactory.createDivider(\"PARSING HTML FILE\"));\r\n                // For single file parsing, you might need to add a method in your Parser class\r\n                System.out.println(ConsoleFormatterFactory.createMessage(\"HTML file parsing not implemented for single files yet.\", MessageType.WARNING));\r\n            } else if (fileName.equals(\"pom.xml\")) {\r\n                System.out.println(ConsoleFormatterFactory.createDivider(\"PARSING POM FILE\"));\r\n                // For single file parsing, you might need to add a method in your Parser class\r\n                System.out.println(ConsoleFormatterFactory.createMessage(\"POM file parsing not implemented for single files yet.\", MessageType.WARNING));\r\n            } else {\r\n                System.out.println(ConsoleFormatterFactory.createMessage(\"Unsupported file type: \" + fileName, MessageType.ERROR));\r\n            }\r\n        } catch (Exception e) {\r\n            System.out.println(ConsoleFormatterFactory.createMessage(\"Error parsing file: \" + e.getMessage(), MessageType.ERROR));\r\n            e.printStackTrace();\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            System.out.println(ConsoleFormatterFactory.createMessage(\"File does not exist: \" + filePath, MessageType.ERROR));\r\n            return;\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                System.out.println(ConsoleFormatterFactory.createDivider(\"PARSING HTML FILE\"));\r\n                // For single file parsing, you might need to add a method in your Parser class\r\n                System.out.println(ConsoleFormatterFactory.createMessage(\"HTML file parsing not implemented for single files yet.\", MessageType.WARNING));\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                System.out.println(ConsoleFormatterFactory.createDivider(\"PARSING POM FILE\"));\r\n                // For single file parsing, you might need to add a method in your Parser class\r\n                System.out.println(ConsoleFormatterFactory.createMessage(\"POM file parsing not implemented for single files yet.\", MessageType.WARNING));\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parser",
          "methodName": "used",
          "parameters": [],
          "body": "{\r\n        Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n        String json \u003d gson.toJson(result);\r\n\r\n        // Create a timestamp for the filename\r\n        SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyyMMdd_HHmmss\");\r\n        String timestamp \u003d dateFormat.format(new Date());\r\n\r\n        // Create the output filename\r\n        String filename \u003d String.format(\"parser_%s_%s.json\", parserType, timestamp);\r\n\r\n        // Use the parsed directory for the output file\r\n        File outputFile \u003d new File(directory, filename);\r\n\r\n        try (FileWriter writer \u003d new FileWriter(outputFile)) {\r\n            writer.write(json);\r\n            return outputFile.getAbsolutePath();\r\n        } catch (IOException e) {\r\n            System.out.println(ConsoleFormatterFactory.createMessage(\r\n                    \"Error saving JSON to file: \" + e.getMessage(), MessageType.ERROR));\r\n\r\n            // Fallback to saving in the current directory\r\n            try {\r\n                outputFile \u003d new File(filename);\r\n                try (FileWriter writer \u003d new FileWriter(outputFile)) {\r\n                    writer.write(json);\r\n                    return outputFile.getAbsolutePath();\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(ConsoleFormatterFactory.createMessage(\r\n                        \"Failed to save JSON file in fallback location: \" + ex.getMessage(), MessageType.ERROR));\r\n                return null;\r\n            }\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "String",
          "methodName": "saveResultToJsonFile",
          "parameters": [
            {
              "type": "Object\u003e",
              "name": "result"
            },
            {
              "type": "String",
              "name": "directory"
            },
            {
              "type": "String",
              "name": "parserType"
            }
          ],
          "body": "{\r\n        Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n        String json \u003d gson.toJson(result);\r\n\r\n        // Create a timestamp for the filename\r\n        SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyyMMdd_HHmmss\");\r\n        String timestamp \u003d dateFormat.format(new Date());\r\n\r\n        // Create the output filename\r\n        String filename \u003d String.format(\"parser_%s_%s.json\", parserType, timestamp);\r\n\r\n        // Use the parsed directory for the output file\r\n        File outputFile \u003d new File(directory, filename);\r\n\r\n        try (FileWriter writer \u003d new FileWriter(outputFile)) {\r\n            writer.write(json);\r\n            return outputFile.getAbsolutePath();\r\n        } catch (IOException e) {\r\n            System.out.println(ConsoleFormatterFactory.createMessage(\r\n                    \"Error saving JSON to file: \" + e.getMessage(), MessageType.ERROR));\r\n\r\n            // Fallback to saving in the current directory\r\n            try {\r\n                outputFile \u003d new File(filename);\r\n                try (FileWriter writer \u003d new FileWriter(outputFile)) {\r\n                    writer.write(json);\r\n                    return outputFile.getAbsolutePath();\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(ConsoleFormatterFactory.createMessage(\r\n                        \"Failed to save JSON file in fallback location: \" + ex.getMessage(), MessageType.ERROR));\r\n                return null;\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Save parsing results to a JSON file\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "result The parsing result map"
              },
              {
                "name": "param",
                "value": "directory The directory that was parsed"
              },
              {
                "name": "param",
                "value": "parserType The type of parser used (all, java, git, etc.)"
              },
              {
                "name": "return",
                "value": "The path to the saved JSON file"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "GsonBuilder",
          "parameters": [],
          "body": "{\r\n            writer.write(json);\r\n            return outputFile.getAbsolutePath();\r\n        }",
          "javadoc": {
            "description": "Save parsing results to a JSON file\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "result The parsing result map"
              },
              {
                "name": "param",
                "value": "directory The directory that was parsed"
              },
              {
                "name": "param",
                "value": "parserType The type of parser used (all, java, git, etc.)"
              },
              {
                "name": "return",
                "value": "The path to the saved JSON file"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            writer.write(json);\r\n            return outputFile.getAbsolutePath();\r\n        }",
          "comments": [
            "Create a timestamp for the filename"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "Date",
          "parameters": [],
          "body": "{\r\n            writer.write(json);\r\n            return outputFile.getAbsolutePath();\r\n        }",
          "comments": [
            "Create a timestamp for the filename",
            "Create the output filename"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            writer.write(json);\r\n            return outputFile.getAbsolutePath();\r\n        }",
          "comments": [
            "Use the parsed directory for the output file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "FileWriter",
          "parameters": [],
          "body": "{\r\n            writer.write(json);\r\n            return outputFile.getAbsolutePath();\r\n        }",
          "comments": [
            "Use the parsed directory for the output file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    writer.write(json);\r\n                    return outputFile.getAbsolutePath();\r\n                }",
          "comments": [
            "Fallback to saving in the current directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "FileWriter",
          "parameters": [],
          "body": "{\r\n            writer.write(json);\r\n            return outputFile.getAbsolutePath();\r\n        }",
          "comments": [
            "Fallback to saving in the current directory"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "outputResult",
          "parameters": [
            {
              "type": "Object\u003e",
              "name": "result"
            },
            {
              "type": "String",
              "name": "outputPath"
            }
          ],
          "body": "{\r\n        Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n        String json \u003d gson.toJson(result);\r\n\r\n        // Print the results to console\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Results:\", MessageType.SUCCESS));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(json, MessageType.DOC_CODE));\r\n\r\n        // Print information about saved file\r\n        if (outputPath !\u003d null) {\r\n            System.out.println(ConsoleFormatterFactory.createDivider(\"OUTPUT FILE\"));\r\n            System.out.println(ConsoleFormatterFactory.createMessage(\r\n                    \"Results saved to: \" + outputPath, MessageType.SUCCESS));\r\n        }\r\n    }",
          "javadoc": {
            "description": "Output the parsing results to console and show file save location",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "GsonBuilder",
          "parameters": [],
          "body": "{\r\n            writer.write(json);\r\n            return outputFile.getAbsolutePath();\r\n        }",
          "javadoc": {
            "description": "Output the parsing results to console and show file save location",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "file",
          "methodName": "if",
          "parameters": [
            {
              "type": "outputPath",
              "name": "!\u003d"
            }
          ],
          "body": "{\r\n            System.out.println(ConsoleFormatterFactory.createDivider(\"OUTPUT FILE\"));\r\n            System.out.println(ConsoleFormatterFactory.createMessage(\r\n                    \"Results saved to: \" + outputPath, MessageType.SUCCESS));\r\n        }",
          "comments": [
            "Print information about saved file"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "showVersion",
          "parameters": [],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createBox(\"Java Structure Parser v1.0\", MessageType.UI_HEADER));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Copyright © 2024 Joshua Salcedo\", MessageType.UI_SUBHEADER));\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "help",
          "parameters": [],
          "body": "{\r\n        System.out.println(ConsoleFormatterFactory.createBox(\"JAVA STRUCTURE PARSER\", MessageType.UI_HEADER));\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"USAGE\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar [command] [arguments]\", MessageType.DOC_CODE));\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"COMMANDS\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"help\", MessageType.UI_LABEL) + \"      - Show this help message\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"version\", MessageType.UI_LABEL) + \"   - Show version information\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"all\", MessageType.UI_LABEL) + \" [dir] - Parse all supported files in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java\", MessageType.UI_LABEL) + \" [dir] - Parse Java files in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"git\", MessageType.UI_LABEL) + \" [dir]  - Parse Git repository in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"pom\", MessageType.UI_LABEL) + \" [dir]  - Parse POM files in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"html\", MessageType.UI_LABEL) + \" [dir] - Parse HTML files in the directory\");\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"[file]\", MessageType.UI_LABEL) + \"     - Parse the specified file based on its extension\");\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"EXAMPLES\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar help\", MessageType.DOC_CODE));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar all /path/to/project\", MessageType.DOC_CODE));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar java /path/to/project\", MessageType.DOC_CODE));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"java -jar parser-utility.jar pom.xml\", MessageType.DOC_CODE));\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"NOTES\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"The parser outputs results as JSON both in the console and saves to a file in the parsed directory.\", MessageType.DOC_NOTE));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Output files are named \u0027parser_[type]_[timestamp].json\u0027\", MessageType.DOC_NOTE));\r\n\r\n        System.out.println(ConsoleFormatterFactory.createDivider(\"LICENSE\"));\r\n        System.out.println(ConsoleFormatterFactory.createMessage(\"Copyright © 2024 Joshua Salcedo\", MessageType.SUCCESS));\r\n    }",
          "comments": []
        }
      ],
      "className": "ParserRunner",
      "packageName": "io.joshuasalcedo"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/ClipboardService.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "5",
          "methodName": "minutes",
          "parameters": [],
          "body": "{\r\n//        // Get the system clipboard\r\n//        clipboard \u003d Toolkit.getDefaultToolkit().getSystemClipboard();\r\n//\r\n//        // Initialize HTTP client (using Java 11+ HttpClient)\r\n//        httpClient \u003d HttpClient.newBuilder()\r\n//                .version(HttpClient.Version.HTTP_2)\r\n//                .connectTimeout(Duration.ofSeconds(10))\r\n//                .build();\r\n//\r\n//        // Check if primary server is available, otherwise use fallback\r\n//        checkServerAvailability();\r\n//\r\n//        // Add shutdown hook to clean up threads\r\n//        Runtime.getRuntime().addShutdownHook(new Thread(() -\u003e {\r\n//            stopMonitoring();\r\n//            clipboardExecutor.shutdownNow();\r\n//            scheduledExecutor.shutdownNow();\r\n//        }));\r\n//\r\n//        System.out.println(\"[ClipboardService] Initialized\");\r\n//    }",
          "comments": [
            "public class ClipboardService {",
            "private final Clipboard clipboard;",
            "private String lastClipboardContent \u003d \"\";",
            "private static final int SAVE_INTERVAL_MS \u003d 300000; // Save every 5 minutes (300,000ms)",
            "private final HttpClient httpClient;",
            "private static final Strin"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AtomicBoolean",
          "parameters": [],
          "body": "{\r\n//        // Get the system clipboard\r\n//        clipboard \u003d Toolkit.getDefaultToolkit().getSystemClipboard();\r\n//\r\n//        // Initialize HTTP client (using Java 11+ HttpClient)\r\n//        httpClient \u003d HttpClient.newBuilder()\r\n//                .version(HttpClient.Version.HTTP_2)\r\n//                .connectTimeout(Duration.ofSeconds(10))\r\n//                .build();\r\n//\r\n//        // Check if primary server is available, otherwise use fallback\r\n//        checkServerAvailability();\r\n//\r\n//        // Add shutdown hook to clean up threads\r\n//        Runtime.getRuntime().addShutdownHook(new Thread(() -\u003e {\r\n//            stopMonitoring();\r\n//            clipboardExecutor.shutdownNow();\r\n//            scheduledExecutor.shutdownNow();\r\n//        }));\r\n//\r\n//        System.out.println(\"[ClipboardService] Initialized\");\r\n//    }",
          "comments": [
            "private ClipboardListenerTask clipboardListenerTask;",
            "private ScheduledFuture\u003c?\u003e serverSaveTask;",
            "private final AtomicBoolean isRunning \u003d new AtomicBoolean(false);",
            "",
            "public ClipboardService() {",
            "// Get the system clipb"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "public",
          "methodName": "ClipboardService",
          "parameters": [],
          "body": "{\r\n//        // Get the system clipboard\r\n//        clipboard \u003d Toolkit.getDefaultToolkit().getSystemClipboard();\r\n//\r\n//        // Initialize HTTP client (using Java 11+ HttpClient)\r\n//        httpClient \u003d HttpClient.newBuilder()\r\n//                .version(HttpClient.Version.HTTP_2)\r\n//                .connectTimeout(Duration.ofSeconds(10))\r\n//                .build();\r\n//\r\n//        // Check if primary server is available, otherwise use fallback\r\n//        checkServerAvailability();\r\n//\r\n//        // Add shutdown hook to clean up threads\r\n//        Runtime.getRuntime().addShutdownHook(new Thread(() -\u003e {\r\n//            stopMonitoring();\r\n//            clipboardExecutor.shutdownNow();\r\n//            scheduledExecutor.shutdownNow();\r\n//        }));\r\n//\r\n//        System.out.println(\"[ClipboardService] Initialized\");\r\n//    }",
          "comments": [
            "private ClipboardListenerTask clipboardListenerTask;",
            "private ScheduledFuture\u003c?\u003e serverSaveTask;",
            "private final AtomicBoolean isRunning \u003d new AtomicBoolean(false);",
            "",
            "public ClipboardService() {",
            "// Get the system clipboard",
            "clipboard \u003d Toolki"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "HTTP",
          "methodName": "client",
          "parameters": [
            {
              "type": "using",
              "name": "Java"
            }
          ],
          "body": "{\r\n//            stopMonitoring();\r\n//            clipboardExecutor.shutdownNow();\r\n//            scheduledExecutor.shutdownNow();\r\n//        }",
          "comments": [
            "",
            "public ClipboardService() {",
            "// Get the system clipboard",
            "clipboard \u003d Toolkit.getDefaultToolkit().getSystemClipboard();",
            "",
            "// Initialize HTTP client (using Java 11+ HttpClient)",
            "httpClient \u003d HttpClient.newBuilder()",
            ""
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "Thread",
          "parameters": [],
          "body": "{\r\n//            stopMonitoring();\r\n//            clipboardExecutor.shutdownNow();\r\n//            scheduledExecutor.shutdownNow();\r\n//        }",
          "comments": [
            "checkServerAvailability();",
            "",
            "// Add shutdown hook to clean up threads",
            "Runtime.getRuntime().addShutdownHook(new Thread(() -\u003e {",
            "stopMonitoring();",
            "clipboardExecutor.shutdownNow();"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "start",
          "parameters": [],
          "body": "{\r\n//        if (isRunning.getAndSet(true)) {\r\n//            return; // Already running\r\n//        }\r\n//\r\n//        System.out.println(\"[ClipboardService] Starting clipboard monitoring...\");\r\n//\r\n//        // Initialize the clipboard listener task\r\n//        clipboardListenerTask \u003d new ClipboardListenerTask();\r\n//        clipboardExecutor.submit(clipboardListenerTask);\r\n//\r\n//        // Schedule the server save task\r\n//        serverSaveTask \u003d scheduledExecutor.scheduleAtFixedRate(\r\n//                this::saveClipboardHistoryToServer,\r\n//                SAVE_INTERVAL_MS,\r\n//                SAVE_INTERVAL_MS,\r\n//                TimeUnit.MILLISECONDS\r\n//        );\r\n//\r\n//        System.out.println(\"[ClipboardService] Clipboard monitoring started\");\r\n//    }",
          "comments": [
            "clipboardExecutor.shutdownNow();",
            "scheduledExecutor.shutdownNow();",
            "}));",
            "",
            "System.out.println(\"[ClipboardService] Initialized\");",
            "}",
            "",
            "public void start() {",
            "if (isRunning.getAndSet(true)) {",
            "return; // Already"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ClipboardListenerTask",
          "parameters": [],
          "body": "{\r\n//        if (!isRunning.getAndSet(false)) {\r\n//            return; // Already stopped\r\n//        }\r\n//\r\n//        System.out.println(\"[ClipboardService] Stopping clipboard monitoring...\");\r\n//\r\n//        // Cancel the clipboard listener task\r\n//        if (clipboardListenerTask !\u003d null) {\r\n//            clipboardListenerTask.stop();\r\n//        }\r\n//\r\n//        // Cancel the server save task\r\n//        if (serverSaveTask !\u003d null) {\r\n//            serverSaveTask.cancel(false);\r\n//        }\r\n//\r\n//        System.out.println(\"[ClipboardService] Clipboard monitoring stopped\");\r\n//    }",
          "comments": [
            "}",
            "",
            "System.out.println(\"[ClipboardService] Starting clipboard monitoring...\");",
            "",
            "// Initialize the clipboard listener task",
            "clipboardListenerTask \u003d new ClipboardListenerTask();",
            "clipboardExecutor.submit(clipboardListenerTask);",
            "",
            ""
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "stop",
          "parameters": [],
          "body": "{\r\n//        if (!isRunning.getAndSet(false)) {\r\n//            return; // Already stopped\r\n//        }\r\n//\r\n//        System.out.println(\"[ClipboardService] Stopping clipboard monitoring...\");\r\n//\r\n//        // Cancel the clipboard listener task\r\n//        if (clipboardListenerTask !\u003d null) {\r\n//            clipboardListenerTask.stop();\r\n//        }\r\n//\r\n//        // Cancel the server save task\r\n//        if (serverSaveTask !\u003d null) {\r\n//            serverSaveTask.cancel(false);\r\n//        }\r\n//\r\n//        System.out.println(\"[ClipboardService] Clipboard monitoring stopped\");\r\n//    }",
          "comments": [
            "SAVE_INTERVAL_MS,",
            "TimeUnit.MILLISECONDS",
            ");",
            "",
            "System.out.println(\"[ClipboardService] Clipboard monitoring started\");",
            "}",
            "",
            "public void stop() {",
            "if (!isRunning.getAndSet(false)) {",
            "return; // Already"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "saveClipboardHistoryToServer",
          "parameters": [],
          "body": "{\r\n//        // This would save clipboard history to the server\r\n//        // Simplified version just logs the action\r\n//        System.out.println(\"[ClipboardService] Saving clipboard history to server: \" + currentApiUrl);\r\n//    }",
          "comments": [
            "serverSaveTask.cancel(false);",
            "}",
            "",
            "System.out.println(\"[ClipboardService] Clipboard monitoring stopped\");",
            "}",
            "",
            "private void saveClipboardHistoryToServer() {",
            "// This would save clipboard history to the"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "checkServerAvailability",
          "parameters": [],
          "body": "{\r\n//        CompletableFuture.supplyAsync(() -\u003e isServerAvailable(PRIMARY_API_URL))\r\n//                .thenAccept(available -\u003e {\r\n//                    if (available) {\r\n//                        currentApiUrl \u003d PRIMARY_API_URL;\r\n//                        System.out.println(\"[ClipboardService] Using primary server: \" + PRIMARY_API_URL);\r\n//                    } else {\r\n//                        currentApiUrl \u003d FALLBACK_API_URL;\r\n//                        System.out.println(\"[ClipboardService] Primary server unavailable. Using fallback server: \" + FALLBACK_API_URL);\r\n//\r\n//                        // Schedule a task to periodically check if the primary server becomes available\r\n//                        scheduledExecutor.scheduleAtFixedRate(() -\u003e {\r\n//                            if (isServerAvailable(PRIMARY_API_URL) \u0026\u0026\r\n//                                    !currentApiUrl.equals(PRIMARY_API_URL)) {\r\n//                                currentApiUrl \u003d PRIMARY_API_URL;\r\n//                                System.out.println(\"[ClipboardService] Reconnected to primary server: \" + PRIMARY_API_URL);\r\n//                            }\r\n//                        }, 60, 60, TimeUnit.SECONDS); // Check every minute\r\n//                    }\r\n//                });\r\n//    }",
          "comments": [
            "// Simplified version just logs the action",
            "System.out.println(\"[ClipboardService] Saving clipboard history to server: \" + currentApiUrl);",
            "}",
            "",
            "private void checkServerAvailability() {",
            "CompletableFuture.supplyAsync(() -\u003e isServerAvai"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "boolean",
          "methodName": "isServerAvailable",
          "parameters": [
            {
              "type": "String",
              "name": "url"
            }
          ],
          "body": "{\r\n//        try {\r\n//            HttpRequest request \u003d HttpRequest.newBuilder()\r\n//                    .uri(URI.create(url))\r\n//                    .timeout(Duration.ofSeconds(SERVER_CHECK_TIMEOUT_SECONDS))\r\n//                    .method(\"HEAD\", HttpRequest.BodyPublishers.noBody())\r\n//                    .build();\r\n//\r\n//            HttpResponse\u003cVoid\u003e response \u003d httpClient.send(request,\r\n//                    HttpResponse.BodyHandlers.discarding());\r\n//\r\n//            return response.statusCode() \u003e\u003d 200 \u0026\u0026 response.statusCode() \u003c 300;\r\n//        } catch (Exception e) {\r\n//            return false;\r\n//        }\r\n//    }",
          "comments": [
            "}",
            "}, 60, 60, TimeUnit.SECONDS); // Check every minute",
            "}",
            "});",
            "}",
            "",
            "private boolean isServerAvailable(String url) {",
            "try {",
            "HttpRequest request"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "CompletableFuture\u003cString\u003e",
          "methodName": "postToServer",
          "parameters": [
            {
              "type": "String",
              "name": "url"
            },
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n//        HttpRequest request \u003d HttpRequest.newBuilder()\r\n//                .uri(URI.create(url))\r\n//                .header(\"Content-Type\", \"application/json\")\r\n//                .POST(HttpRequest.BodyPublishers.ofString(content))\r\n//                .build();\r\n//\r\n//        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\r\n//                .thenApply(HttpResponse::body)\r\n//                .exceptionally(ex -\u003e \"Error: \" + ex.getMessage());\r\n//    }",
          "comments": [
            "",
            "return response.statusCode() \u003e\u003d 200 \u0026\u0026 response.statusCode() \u003c 300;",
            "} catch (Exception e) {",
            "return false;",
            "}",
            "}",
            "",
            "private CompletableFuture\u003cString\u003e postToServer(String url, String content) {",
            "HttpRequest"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AtomicBoolean",
          "parameters": [],
          "body": "{\r\n//            running.set(false);\r\n//        }",
          "comments": [
            ".exceptionally(ex -\u003e \"Error: \" + ex.getMessage());",
            "}",
            "",
            "private class ClipboardListenerTask implements Runnable {",
            "private final AtomicBoolean running \u003d new AtomicBoolean(true);",
            "",
            "public void stop() {",
            "running.set(false);",
            ""
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "stop",
          "parameters": [],
          "body": "{\r\n//        if (!isRunning.getAndSet(false)) {\r\n//            return; // Already stopped\r\n//        }\r\n//\r\n//        System.out.println(\"[ClipboardService] Stopping clipboard monitoring...\");\r\n//\r\n//        // Cancel the clipboard listener task\r\n//        if (clipboardListenerTask !\u003d null) {\r\n//            clipboardListenerTask.stop();\r\n//        }\r\n//\r\n//        // Cancel the server save task\r\n//        if (serverSaveTask !\u003d null) {\r\n//            serverSaveTask.cancel(false);\r\n//        }\r\n//\r\n//        System.out.println(\"[ClipboardService] Clipboard monitoring stopped\");\r\n//    }",
          "comments": [
            "}",
            "",
            "private class ClipboardListenerTask implements Runnable {",
            "private final AtomicBoolean running \u003d new AtomicBoolean(true);",
            "",
            "public void stop() {",
            "running.set(false);",
            "}",
            "",
            "@Override",
            ""
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "run",
          "parameters": [],
          "body": "{\r\n//            try {\r\n//                // Take initial ownership of the clipboard\r\n//                Transferable contents \u003d clipboard.getContents(null);\r\n//                ClipboardOwner owner \u003d new ClipboardOwner() {\r\n//                    @Override\r\n//                    public void lostOwnership(Clipboard clipboard, Transferable contents) {\r\n//                        if (!running.get()) return;\r\n//\r\n//                        try {\r\n//                            // Small delay to allow clipboard content to change\r\n//                            Thread.sleep(200);\r\n//\r\n//                            // Get new clipboard contents\r\n//                            Transferable newContents \u003d clipboard.getContents(null);\r\n//\r\n//                            // Process the content if it\u0027s text\r\n//                            if (newContents !\u003d null \u0026\u0026 newContents.isDataFlavorSupported(DataFlavor.stringFlavor)) {\r\n//                                String data \u003d (String) newContents.getTransferData(DataFlavor.stringFlavor);\r\n//\r\n//                                // Only process if content has changed\r\n//                                if (!data.equals(lastClipboardContent) \u0026\u0026 !data.isEmpty()) {\r\n//                                    lastClipboardContent \u003d data;\r\n//                                    System.out.println(\"[ClipboardService] Clipboard changed: \" + data);\r\n//\r\n//                                    // Send clipboard content to server\r\n//                                    postToServer(currentApiUrl, data)\r\n//                                            .thenAccept(response -\u003e System.out.println(\"[ClipboardService] Server response: \" + response))\r\n//                                            .exceptionally(ex -\u003e {\r\n//                                                System.err.println(\"[ClipboardService] Error sending clipboard content to server: \" + ex.getMessage());\r\n//                                                return null;\r\n//                                            });\r\n//                                }\r\n//                            }\r\n//\r\n//                            // Take ownership again to continue monitoring\r\n//                            if (running.get()) {\r\n//                                clipboard.setContents(newContents, this);\r\n//                            }\r\n//                        } catch (Exception e) {\r\n//                            System.err.println(\"[ClipboardService] Error processing clipboard content: \" + e.getMessage());\r\n//\r\n//                            // Try to recover ownership\r\n//                            if (running.get()) {\r\n//                                try {\r\n//                                    clipboard.setContents(clipboard.getContents(null), this);\r\n//                                } catch (Exception ex) {\r\n//                                    System.err.println(\"[ClipboardService] Failed to recover clipboard ownership: \" + ex.getMessage());\r\n//                                }\r\n//                            }\r\n//                        }\r\n//                    }\r\n//                };\r\n//\r\n//                // Store initial clipboard content if it\u0027s text\r\n//                if (contents !\u003d null \u0026\u0026 contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {\r\n//                    lastClipboardContent \u003d (String) contents.getTransferData(DataFlavor.stringFlavor);\r\n//                }\r\n//\r\n//                // Take ownership\r\n//                clipboard.setContents(contents, owner);\r\n//\r\n//                // Keep the thread alive until stopped\r\n//                while (running.get()) {\r\n//                    // Periodically check if we still have clipboard ownership\r\n//                    try {\r\n//                        Thread.sleep(1000);\r\n//                        // Sometimes ownership can be lost without notification, so we check periodically\r\n//                        if (running.get()) {\r\n//                            Transferable current \u003d clipboard.getContents(null);\r\n//                            if (current !\u003d null \u0026\u0026 current.isDataFlavorSupported(DataFlavor.stringFlavor)) {\r\n//                                String currentText \u003d (String) current.getTransferData(DataFlavor.stringFlavor);\r\n//                                // If content changed but we didn\u0027t get a lostOwnership notification\r\n//                                if (!currentText.equals(lastClipboardContent)) {\r\n//                                    lastClipboardContent \u003d currentText;\r\n//                                    System.out.println(\"[ClipboardService] Clipboard changed (poll): \" + currentText);\r\n//\r\n//                                    // Retake ownership\r\n//                                    clipboard.setContents(current, owner);\r\n//\r\n//                                    // Send to server\r\n//                                    postToServer(currentApiUrl, currentText)\r\n//                                            .thenAccept(response -\u003e System.out.println(\"[ClipboardService] Server response: \" + response))\r\n//                                            .exceptionally(ex -\u003e {\r\n//                                                System.err.println(\"[ClipboardService] Error sending clipboard content to server: \" + ex.getMessage());\r\n//                                                return null;\r\n//                                            });\r\n//                                }\r\n//                            }\r\n//                        }\r\n//                    } catch (Exception e) {\r\n//                        if (running.get()) {\r\n//                            System.err.println(\"[ClipboardService] Error polling clipboard: \" + e.getMessage());\r\n//                        }\r\n//                    }\r\n//                }\r\n//            } catch (Exception e) {\r\n//                System.err.println(\"[ClipboardService] Clipboard listener error: \" + e.getMessage());\r\n//            }\r\n//        }",
          "comments": [
            "private final AtomicBoolean running \u003d new AtomicBoolean(true);",
            "",
            "public void stop() {",
            "running.set(false);",
            "}",
            "",
            "@Override",
            "public void run() {",
            "try {",
            "// Take initial ownership of the clipboa"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ClipboardOwner",
          "parameters": [],
          "body": "{\r\n//                    @Override\r\n//                    public void lostOwnership(Clipboard clipboard, Transferable contents) {\r\n//                        if (!running.get()) return;\r\n//\r\n//                        try {\r\n//                            // Small delay to allow clipboard content to change\r\n//                            Thread.sleep(200);\r\n//\r\n//                            // Get new clipboard contents\r\n//                            Transferable newContents \u003d clipboard.getContents(null);\r\n//\r\n//                            // Process the content if it\u0027s text\r\n//                            if (newContents !\u003d null \u0026\u0026 newContents.isDataFlavorSupported(DataFlavor.stringFlavor)) {\r\n//                                String data \u003d (String) newContents.getTransferData(DataFlavor.stringFlavor);\r\n//\r\n//                                // Only process if content has changed\r\n//                                if (!data.equals(lastClipboardContent) \u0026\u0026 !data.isEmpty()) {\r\n//                                    lastClipboardContent \u003d data;\r\n//                                    System.out.println(\"[ClipboardService] Clipboard changed: \" + data);\r\n//\r\n//                                    // Send clipboard content to server\r\n//                                    postToServer(currentApiUrl, data)\r\n//                                            .thenAccept(response -\u003e System.out.println(\"[ClipboardService] Server response: \" + response))\r\n//                                            .exceptionally(ex -\u003e {\r\n//                                                System.err.println(\"[ClipboardService] Error sending clipboard content to server: \" + ex.getMessage());\r\n//                                                return null;\r\n//                                            });\r\n//                                }\r\n//                            }\r\n//\r\n//                            // Take ownership again to continue monitoring\r\n//                            if (running.get()) {\r\n//                                clipboard.setContents(newContents, this);\r\n//                            }\r\n//                        } catch (Exception e) {\r\n//                            System.err.println(\"[ClipboardService] Error processing clipboard content: \" + e.getMessage());\r\n//\r\n//                            // Try to recover ownership\r\n//                            if (running.get()) {\r\n//                                try {\r\n//                                    clipboard.setContents(clipboard.getContents(null), this);\r\n//                                } catch (Exception ex) {\r\n//                                    System.err.println(\"[ClipboardService] Failed to recover clipboard ownership: \" + ex.getMessage());\r\n//                                }\r\n//                            }\r\n//                        }\r\n//                    }\r\n//                }",
          "comments": [
            "try {",
            "// Take initial ownership of the clipboard",
            "Transferable contents \u003d clipboard.getContents(null);",
            "ClipboardOwner owner \u003d new ClipboardOwner() {",
            "@Override",
            "public void lostOwne"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "lostOwnership",
          "parameters": [
            {
              "type": "Clipboard",
              "name": "clipboard"
            },
            {
              "type": "Transferable",
              "name": "contents"
            }
          ],
          "body": "{\r\n//                        if (!running.get()) return;\r\n//\r\n//                        try {\r\n//                            // Small delay to allow clipboard content to change\r\n//                            Thread.sleep(200);\r\n//\r\n//                            // Get new clipboard contents\r\n//                            Transferable newContents \u003d clipboard.getContents(null);\r\n//\r\n//                            // Process the content if it\u0027s text\r\n//                            if (newContents !\u003d null \u0026\u0026 newContents.isDataFlavorSupported(DataFlavor.stringFlavor)) {\r\n//                                String data \u003d (String) newContents.getTransferData(DataFlavor.stringFlavor);\r\n//\r\n//                                // Only process if content has changed\r\n//                                if (!data.equals(lastClipboardContent) \u0026\u0026 !data.isEmpty()) {\r\n//                                    lastClipboardContent \u003d data;\r\n//                                    System.out.println(\"[ClipboardService] Clipboard changed: \" + data);\r\n//\r\n//                                    // Send clipboard content to server\r\n//                                    postToServer(currentApiUrl, data)\r\n//                                            .thenAccept(response -\u003e System.out.println(\"[ClipboardService] Server response: \" + response))\r\n//                                            .exceptionally(ex -\u003e {\r\n//                                                System.err.println(\"[ClipboardService] Error sending clipboard content to server: \" + ex.getMessage());\r\n//                                                return null;\r\n//                                            });\r\n//                                }\r\n//                            }\r\n//\r\n//                            // Take ownership again to continue monitoring\r\n//                            if (running.get()) {\r\n//                                clipboard.setContents(newContents, this);\r\n//                            }\r\n//                        } catch (Exception e) {\r\n//                            System.err.println(\"[ClipboardService] Error processing clipboard content: \" + e.getMessage());\r\n//\r\n//                            // Try to recover ownership\r\n//                            if (running.get()) {\r\n//                                try {\r\n//                                    clipboard.setContents(clipboard.getContents(null), this);\r\n//                                } catch (Exception ex) {\r\n//                                    System.err.println(\"[ClipboardService] Failed to recover clipboard ownership: \" + ex.getMessage());\r\n//                                }\r\n//                            }\r\n//                        }\r\n//                    }",
          "comments": [
            "Transferable contents \u003d clipboard.getContents(null);",
            "ClipboardOwner owner \u003d new ClipboardOwner() {",
            "@Override",
            "public void lostOwnership(Clipboard clipboard, Transferable contents) {",
            "i"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Clipboard",
          "methodName": "changed",
          "parameters": [],
          "body": "{\r\n//                                                System.err.println(\"[ClipboardService] Error sending clipboard content to server: \" + ex.getMessage());\r\n//                                                return null;\r\n//                                            }",
          "comments": [
            "lastClipboardContent \u003d currentText;",
            "System.out.println(\"[ClipboardService] Clipboard changed (poll): \" + currentText);",
            "",
            "// Retake ow"
          ]
        }
      ],
      "className": "ClipboardService",
      "packageName": "io.joshuasalcedo"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/maven/Dependency.java",
      "methods": [],
      "className": "Dependency",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/maven/Plugin.java",
      "methods": [],
      "className": "Plugin",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/maven/PomCoordinates.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "project",
          "parameters": [],
          "body": "",
          "javadoc": {
            "description": "The version of the project.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "PomCoordinates",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/maven/PomStructure.java",
      "methods": [],
      "className": "PomStructure",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/maven/Property.java",
      "methods": [],
      "className": "Property",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/maven/PluginConfiguration.java",
      "methods": [],
      "className": "PluginConfiguration",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/maven/ParentInfo.java",
      "methods": [],
      "className": "ParentInfo",
      "packageName": "io.joshuasalcedo.model.maven"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/javafile/JavadocTag.java",
      "methods": [],
      "className": "JavadocTag",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/javafile/JavadocStructure.java",
      "methods": [],
      "className": "JavadocStructure",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/javafile/ClassStructure.java",
      "methods": [],
      "className": "ClassStructure",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/javafile/Parameter.java",
      "methods": [],
      "className": "Parameter",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/javafile/MethodStructure.java",
      "methods": [],
      "className": "MethodStructure",
      "packageName": "io.joshuasalcedo.model.javafile"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/markdown/MarkdownHeading.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "heading",
          "parameters": [],
          "body": "",
          "javadoc": {
            "description": "Represents a heading in a Markdown document.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "heading",
          "parameters": [
            {
              "type": "for",
              "name": "anchor"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The text content of the heading.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "MarkdownHeading",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/markdown/MarkdownLink.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "internal",
          "methodName": "link",
          "parameters": [
            {
              "type": "within",
              "name": "the"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The title attribute of the link, if any.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "MarkdownLink",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/markdown/MarkdownCodeBlock.java",
      "methods": [],
      "className": "MarkdownCodeBlock",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/markdown/MarkdownParserUtility.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "MarkdownParserUtility",
          "parameters": [],
          "body": "{\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Markdown content using CommonMark.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AssertionError",
          "parameters": [
            {
              "type": "\"Utility",
              "name": "class"
            }
          ],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return MarkdownContent.builder().rawContent(\"\").htmlContent(\"\").build();\r\n        }\r\n        \r\n        // Create parser with extensions\r\n        List\u003corg.commonmark.Extension\u003e extensions \u003d Arrays.asList(\r\n                AutolinkExtension.create(),\r\n                TablesExtension.create(),\r\n                StrikethroughExtension.create(),\r\n                InsExtension.create(),\r\n                HeadingAnchorExtension.create(),\r\n                YamlFrontMatterExtension.create()\r\n        );\r\n        \r\n        Parser parser \u003d Parser.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        HtmlRenderer renderer \u003d HtmlRenderer.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        // Parse markdown\r\n        Node document \u003d parser.parse(markdown);\r\n        \r\n        // Process front matter\r\n        YamlFrontMatterVisitor frontMatterVisitor \u003d new YamlFrontMatterVisitor();\r\n        document.accept(frontMatterVisitor);\r\n        Map\u003cString, Object\u003e frontMatter \u003d convertFrontMatter(frontMatterVisitor.getData());\r\n        \r\n        // Collect structural elements\r\n        List\u003cMarkdownHeading\u003e headings \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownLink\u003e links \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownImage\u003e images \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownCodeBlock\u003e codeBlocks \u003d new ArrayList\u003c\u003e();\r\n        \r\n        // Extract structure by visiting nodes\r\n        StructureCollector collector \u003d new StructureCollector(headings, links, images, codeBlocks);\r\n        document.accept(collector);\r\n        \r\n        // Extract title (first heading if available)\r\n        String title \u003d null;\r\n        if (!headings.isEmpty()) {\r\n            title \u003d headings.get(0).getText();\r\n        }\r\n        \r\n        // Count words and estimate reading time\r\n        int wordCount \u003d countWords(markdown);\r\n        int readingTimeMinutes \u003d calculateReadingTime(wordCount);\r\n        \r\n        // Render HTML\r\n        String htmlContent \u003d renderer.render(document);\r\n        \r\n        return MarkdownContent.builder()\r\n                .title(title)\r\n                .rawContent(markdown)\r\n                .htmlContent(htmlContent)\r\n                .headings(headings)\r\n                .links(links)\r\n                .images(images)\r\n                .codeBlocks(codeBlocks)\r\n                .frontMatter(frontMatter)\r\n                .wordCount(wordCount)\r\n                .readingTimeMinutes(readingTimeMinutes)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Markdown content using CommonMark.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "MarkdownContent",
          "methodName": "parseMarkdown",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return MarkdownContent.builder().rawContent(\"\").htmlContent(\"\").build();\r\n        }\r\n        \r\n        // Create parser with extensions\r\n        List\u003corg.commonmark.Extension\u003e extensions \u003d Arrays.asList(\r\n                AutolinkExtension.create(),\r\n                TablesExtension.create(),\r\n                StrikethroughExtension.create(),\r\n                InsExtension.create(),\r\n                HeadingAnchorExtension.create(),\r\n                YamlFrontMatterExtension.create()\r\n        );\r\n        \r\n        Parser parser \u003d Parser.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        HtmlRenderer renderer \u003d HtmlRenderer.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        // Parse markdown\r\n        Node document \u003d parser.parse(markdown);\r\n        \r\n        // Process front matter\r\n        YamlFrontMatterVisitor frontMatterVisitor \u003d new YamlFrontMatterVisitor();\r\n        document.accept(frontMatterVisitor);\r\n        Map\u003cString, Object\u003e frontMatter \u003d convertFrontMatter(frontMatterVisitor.getData());\r\n        \r\n        // Collect structural elements\r\n        List\u003cMarkdownHeading\u003e headings \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownLink\u003e links \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownImage\u003e images \u003d new ArrayList\u003c\u003e();\r\n        List\u003cMarkdownCodeBlock\u003e codeBlocks \u003d new ArrayList\u003c\u003e();\r\n        \r\n        // Extract structure by visiting nodes\r\n        StructureCollector collector \u003d new StructureCollector(headings, links, images, codeBlocks);\r\n        document.accept(collector);\r\n        \r\n        // Extract title (first heading if available)\r\n        String title \u003d null;\r\n        if (!headings.isEmpty()) {\r\n            title \u003d headings.get(0).getText();\r\n        }\r\n        \r\n        // Count words and estimate reading time\r\n        int wordCount \u003d countWords(markdown);\r\n        int readingTimeMinutes \u003d calculateReadingTime(wordCount);\r\n        \r\n        // Render HTML\r\n        String htmlContent \u003d renderer.render(document);\r\n        \r\n        return MarkdownContent.builder()\r\n                .title(title)\r\n                .rawContent(markdown)\r\n                .htmlContent(htmlContent)\r\n                .headings(headings)\r\n                .links(links)\r\n                .images(images)\r\n                .codeBlocks(codeBlocks)\r\n                .frontMatter(frontMatter)\r\n                .wordCount(wordCount)\r\n                .readingTimeMinutes(readingTimeMinutes)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Parse markdown content into a structured MarkdownContent object.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to parse"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "YamlFrontMatterVisitor",
          "parameters": [],
          "body": "{\r\n            title \u003d headings.get(0).getText();\r\n        }",
          "comments": [
            "Parse markdown",
            "Process front matter"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StructureCollector",
          "parameters": [],
          "body": "{\r\n            title \u003d headings.get(0).getText();\r\n        }",
          "comments": [
            "Extract structure by visiting nodes"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Extract",
          "methodName": "title",
          "parameters": [
            {
              "type": "first",
              "name": "heading"
            }
          ],
          "body": "{\r\n            title \u003d headings.get(0).getText();\r\n        }",
          "comments": [
            "Extract structure by visiting nodes",
            "Extract title (first heading if available)"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "MarkdownContent",
          "methodName": "parseMarkdownFile",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            }
          ],
          "body": "{\r\n        String content \u003d Files.readString(file.toPath());\r\n        return parseMarkdown(content);\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The markdown file to parse"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "parseMarkdown",
          "parameters": [],
          "body": "{\r\n        String content \u003d Files.readString(path);\r\n        return parseMarkdown(content);\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file The markdown file to parse"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "MarkdownContent",
          "methodName": "parseMarkdownFile",
          "parameters": [
            {
              "type": "Path",
              "name": "path"
            }
          ],
          "body": "{\r\n        String content \u003d Files.readString(path);\r\n        return parseMarkdown(content);\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a Path.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to the markdown file"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "parseMarkdown",
          "parameters": [],
          "body": "{\r\n        String content \u003d Files.readString(path);\r\n        return parseMarkdown(content);\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a Path.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to the markdown file"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "MarkdownContent",
          "methodName": "parseMarkdownReader",
          "parameters": [
            {
              "type": "Reader",
              "name": "reader"
            }
          ],
          "body": "{\r\n        StringBuilder sb \u003d new StringBuilder();\r\n        char[] buffer \u003d new char[4096];\r\n        int n;\r\n        while ((n \u003d reader.read(buffer)) !\u003d -1) {\r\n            sb.append(buffer, 0, n);\r\n        }\r\n        return parseMarkdown(sb.toString());\r\n    }",
          "javadoc": {
            "description": "Parse markdown content from a Reader.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "reader The reader containing markdown content"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StringBuilder",
          "parameters": [],
          "body": "{\r\n            sb.append(buffer, 0, n);\r\n        }",
          "javadoc": {
            "description": "Parse markdown content from a Reader.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "reader The reader containing markdown content"
              },
              {
                "name": "return",
                "value": "MarkdownContent object with structured information"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "parseMarkdown",
          "parameters": [],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return \"\";\r\n        }\r\n        \r\n        List\u003corg.commonmark.Extension\u003e extensions \u003d Arrays.asList(\r\n                AutolinkExtension.create(),\r\n                TablesExtension.create(),\r\n                StrikethroughExtension.create(),\r\n                InsExtension.create()\r\n        );\r\n        \r\n        Parser parser \u003d Parser.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        HtmlRenderer renderer \u003d HtmlRenderer.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        Node document \u003d parser.parse(markdown);\r\n        return renderer.render(document);\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "markdownToHtml",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return \"\";\r\n        }\r\n        \r\n        List\u003corg.commonmark.Extension\u003e extensions \u003d Arrays.asList(\r\n                AutolinkExtension.create(),\r\n                TablesExtension.create(),\r\n                StrikethroughExtension.create(),\r\n                InsExtension.create()\r\n        );\r\n        \r\n        Parser parser \u003d Parser.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        HtmlRenderer renderer \u003d HtmlRenderer.builder()\r\n                .extensions(extensions)\r\n                .build();\r\n        \r\n        Node document \u003d parser.parse(markdown);\r\n        return renderer.render(document);\r\n    }",
          "javadoc": {
            "description": "Simply convert markdown to HTML.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to convert"
              },
              {
                "name": "return",
                "value": "HTML representation of the markdown"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMarkdownHeading\u003e",
          "methodName": "extractHeadings",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        MarkdownContent content \u003d parseMarkdown(markdown);\r\n        return content.getHeadings();\r\n    }",
          "javadoc": {
            "description": "Extract all headings from markdown content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to process"
              },
              {
                "name": "return",
                "value": "List of headings"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMarkdownLink\u003e",
          "methodName": "extractLinks",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        MarkdownContent content \u003d parseMarkdown(markdown);\r\n        return content.getLinks();\r\n    }",
          "javadoc": {
            "description": "Extract all links from markdown content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to process"
              },
              {
                "name": "return",
                "value": "List of links"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMarkdownImage\u003e",
          "methodName": "extractImages",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        MarkdownContent content \u003d parseMarkdown(markdown);\r\n        return content.getImages();\r\n    }",
          "javadoc": {
            "description": "Extract all images from markdown content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to process"
              },
              {
                "name": "return",
                "value": "List of images"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMarkdownCodeBlock\u003e",
          "methodName": "extractCodeBlocks",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        MarkdownContent content \u003d parseMarkdown(markdown);\r\n        return content.getCodeBlocks();\r\n    }",
          "javadoc": {
            "description": "Extract all code blocks from markdown content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content to process"
              },
              {
                "name": "return",
                "value": "List of code blocks"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "int",
          "methodName": "countWords",
          "parameters": [
            {
              "type": "String",
              "name": "markdown"
            }
          ],
          "body": "{\r\n        if (markdown \u003d\u003d null || markdown.isEmpty()) {\r\n            return 0;\r\n        }\r\n        \r\n        // Remove YAML front matter if present\r\n        String content \u003d markdown;\r\n        if (content.startsWith(\"---\")) {\r\n            int end \u003d content.indexOf(\"---\", 3);\r\n            if (end \u003e 0) {\r\n                content \u003d content.substring(end + 3);\r\n            }\r\n        }\r\n        \r\n        // Remove code blocks\r\n        content \u003d content.replaceAll(\"```.*?```\", \" \");\r\n        \r\n        // Remove HTML tags\r\n        content \u003d content.replaceAll(\"\u003c[^\u003e]*\u003e\", \" \");\r\n        \r\n        // Remove markdown symbols\r\n        content \u003d content.replaceAll(\"[#*_~`\\\\[\\\\](){}|]+\", \" \");\r\n        \r\n        // Split by whitespace and count non-empty words\r\n        String[] words \u003d content.trim().split(\"\\\\s+\");\r\n        int count \u003d 0;\r\n        for (String word : words) {\r\n            if (!word.isEmpty()) {\r\n                count++;\r\n            }\r\n        }\r\n        \r\n        return count;\r\n    }",
          "javadoc": {
            "description": "Count the words in a markdown text.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "markdown The markdown content"
              },
              {
                "name": "return",
                "value": "The word count"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "int",
          "methodName": "calculateReadingTime",
          "parameters": [
            {
              "type": "int",
              "name": "wordCount"
            }
          ],
          "body": "{\r\n        // Average reading speed: 200-250 words per minute\r\n        final int wordsPerMinute \u003d 225;\r\n        int minutes \u003d wordCount / wordsPerMinute;\r\n        if (wordCount % wordsPerMinute \u003e 0) {\r\n            minutes++;\r\n        }\r\n        return Math.max(1, minutes);\r\n    }",
          "javadoc": {
            "description": "Calculate estimated reading time in minutes.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "wordCount The number of words"
              },
              {
                "name": "return",
                "value": "Estimated reading time in minutes"
              }
            ]
          },
          "comments": [
            "Average reading speed: 200-250"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "convertFrontMatter",
          "parameters": [
            {
              "type": "List\u003cString\u003e\u003e",
              "name": "frontMatterData"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n        \r\n        for (Map.Entry\u003cString, List\u003cString\u003e\u003e entry : frontMatterData.entrySet()) {\r\n            String key \u003d entry.getKey();\r\n            List\u003cString\u003e values \u003d entry.getValue();\r\n            \r\n            if (values.size() \u003d\u003d 1) {\r\n                // Single value\r\n                result.put(key, values.get(0));\r\n            } else {\r\n                // Multiple values\r\n                result.put(key, values);\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }",
          "javadoc": {
            "description": "Convert front matter data to a map of objects.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "frontMatterData The front matter data from the visitor"
              },
              {
                "name": "return",
                "value": "Converted front matter map"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "public",
          "methodName": "StructureCollector",
          "parameters": [
            {
              "type": "List\u003cMarkdownHeading\u003e",
              "name": "headings"
            },
            {
              "type": "List\u003cMarkdownLink\u003e",
              "name": "links"
            },
            {
              "type": "List\u003cMarkdownImage\u003e",
              "name": "images"
            },
            {
              "type": "List\u003cMarkdownCodeBlock\u003e",
              "name": "codeBlocks"
            }
          ],
          "body": "{\r\n            this.headings \u003d headings;\r\n            this.links \u003d links;\r\n            this.images \u003d images;\r\n            this.codeBlocks \u003d codeBlocks;\r\n        }",
          "javadoc": {
            "description": "A node visitor that collects structural elements from a markdown document.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "Heading",
              "name": "heading"
            }
          ],
          "body": "{\r\n            String id \u003d \"\";\r\n            // Get heading ID from attributes if available\r\n            if (heading.getFirstChild() instanceof Text) {\r\n                String text \u003d ((Text) heading.getFirstChild()).getLiteral();\r\n                // Generate simplified ID from heading text\r\n                id \u003d text.toLowerCase()\r\n                        .replaceAll(\"[^\\\\w\\\\s-]\", \"\")\r\n                        .replaceAll(\"\\\\s+\", \"-\");\r\n            }\r\n            \r\n            StringBuilder textBuilder \u003d new StringBuilder();\r\n            Node child \u003d heading.getFirstChild();\r\n            while (child !\u003d null) {\r\n                if (child instanceof Text) {\r\n                    textBuilder.append(((Text) child).getLiteral());\r\n                }\r\n                child \u003d child.getNext();\r\n            }\r\n            \r\n            MarkdownHeading mdHeading \u003d MarkdownHeading.builder()\r\n                    .level(heading.getLevel())\r\n                    .text(textBuilder.toString())\r\n                    .id(id)\r\n                    .position(nodePosition++)\r\n                    .build();\r\n            \r\n            headings.add(mdHeading);\r\n            visitChildren(heading);\r\n        }",
          "comments": [
            "Get heading ID fro"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                String text \u003d ((Text) heading.getFirstChild()).getLiteral();\r\n                // Generate simplified ID from heading text\r\n                id \u003d text.toLowerCase()\r\n                        .replaceAll(\"[^\\\\w\\\\s-]\", \"\")\r\n                        .replaceAll(\"\\\\s+\", \"-\");\r\n            }",
          "comments": [
            "Get heading ID from attributes if available"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StringBuilder",
          "parameters": [],
          "body": "{\r\n            sb.append(buffer, 0, n);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "Link",
              "name": "link"
            }
          ],
          "body": "{\r\n            String text \u003d \"\";\r\n            if (link.getFirstChild() instanceof Text) {\r\n                text \u003d ((Text) link.getFirstChild()).getLiteral();\r\n            }\r\n            \r\n            MarkdownLink mdLink \u003d MarkdownLink.builder()\r\n                    .text(text)\r\n                    .url(link.getDestination())\r\n                    .title(link.getTitle())\r\n                    .internal(link.getDestination().startsWith(\"#\"))\r\n                    .build();\r\n            \r\n            links.add(mdLink);\r\n            visitChildren(link);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "Image",
              "name": "image"
            }
          ],
          "body": "{\r\n            MarkdownImage mdImage \u003d MarkdownImage.builder()\r\n                    .altText(image.getTitle())\r\n                    .url(image.getDestination())\r\n                    .title(image.getTitle())\r\n                    .local(!image.getDestination().startsWith(\"http\"))\r\n                    .build();\r\n            \r\n            images.add(mdImage);\r\n            visitChildren(image);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "FencedCodeBlock",
              "name": "codeBlock"
            }
          ],
          "body": "{\r\n            MarkdownCodeBlock mdCodeBlock \u003d MarkdownCodeBlock.builder()\r\n                    .content(codeBlock.getLiteral())\r\n                    .language(codeBlock.getInfo())\r\n                    .fenced(true)\r\n                    .position(nodePosition++)\r\n                    .build();\r\n            \r\n            codeBlocks.add(mdCodeBlock);\r\n            visitChildren(codeBlock);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "visit",
          "parameters": [
            {
              "type": "IndentedCodeBlock",
              "name": "codeBlock"
            }
          ],
          "body": "{\r\n            MarkdownCodeBlock mdCodeBlock \u003d MarkdownCodeBlock.builder()\r\n                    .content(codeBlock.getLiteral())\r\n                    .language(null)\r\n                    .fenced(false)\r\n                    .position(nodePosition++)\r\n                    .build();\r\n            \r\n            codeBlocks.add(mdCodeBlock);\r\n            visitChildren(codeBlock);\r\n        }",
          "comments": []
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/markdown/MarkdownContent.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "document",
          "parameters": [
            {
              "type": "usually",
              "name": "from"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Represents the parsed structure of a Markdown document.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "if",
          "methodName": "present",
          "parameters": [
            {
              "type": "for",
              "name": "formats"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "List of all code blocks in the document.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "MarkdownContent",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/markdown/MarkdownImage.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "local",
          "methodName": "image",
          "parameters": [
            {
              "type": "file",
              "name": "path"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The title of the image, if any.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "external",
          "methodName": "image",
          "parameters": [],
          "body": "",
          "javadoc": {
            "description": "The title of the image, if any.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "MarkdownImage",
      "packageName": "io.joshuasalcedo.model.markdown"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/git/TagInfo.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "tag",
          "parameters": [
            {
              "type": "for",
              "name": "annotated"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Whether this is an annotated tag.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "tagger",
          "parameters": [
            {
              "type": "for",
              "name": "annotated"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The message of the tag (for annotated tags).",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "tagger",
          "parameters": [
            {
              "type": "for",
              "name": "annotated"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The name of the tagger (for annotated tags).",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "was",
          "methodName": "created",
          "parameters": [
            {
              "type": "for",
              "name": "annotated"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "The email of the tagger (for annotated tags).",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "TagInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/git/CommitInfo.java",
      "methods": [],
      "className": "CommitInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/git/ContributorInfo.java",
      "methods": [],
      "className": "ContributorInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/git/GitRepositoryInfo.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "repository",
          "parameters": [
            {
              "type": "earliest",
              "name": "commit"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "List of top contributors.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "repository",
          "parameters": [
            {
              "type": "latest",
              "name": "commit"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Creation date of the repository (earliest commit).",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "GitRepositoryInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/git/BranchInfo.java",
      "methods": [],
      "className": "BranchInfo",
      "packageName": "io.joshuasalcedo.model.git"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/model/git/FileChange.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "change",
          "methodName": "type",
          "parameters": [],
          "body": "{\r\n        /**\r\n         * File was added.\r\n         */\r\n        ADD,\r\n        \r\n        /**\r\n         * File was modified.\r\n         */\r\n        MODIFY,\r\n        \r\n        /**\r\n         * File was deleted.\r\n         */\r\n        DELETE,\r\n        \r\n        /**\r\n         * File was renamed.\r\n         */\r\n        RENAME,\r\n        \r\n        /**\r\n         * File was copied.\r\n         */\r\n        COPY\r\n    }",
          "javadoc": {
            "description": "Represents information about a file change in a Git commit.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "file",
          "parameters": [
            {
              "type": "for",
              "name": "renames"
            }
          ],
          "body": "{\r\n        /**\r\n         * File was added.\r\n         */\r\n        ADD,\r\n        \r\n        /**\r\n         * File was modified.\r\n         */\r\n        MODIFY,\r\n        \r\n        /**\r\n         * File was deleted.\r\n         */\r\n        DELETE,\r\n        \r\n        /**\r\n         * File was renamed.\r\n         */\r\n        RENAME,\r\n        \r\n        /**\r\n         * File was copied.\r\n         */\r\n        COPY\r\n    }",
          "javadoc": {
            "description": "The path of the file.",
            "tags": []
          },
          "comments": []
        }
      ],
      "className": "FileChange",
      "packageName": "io.joshuasalcedo.model.git"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/parsers/GitParser.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "GitParser",
          "parameters": [],
          "body": "{\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Git repositories using JGit.\r\nThis class provides static methods to analyze Git repositories and extract structural information.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AssertionError",
          "parameters": [
            {
              "type": "\"Utility",
              "name": "class"
            }
          ],
          "body": "{\r\n        File gitDir \u003d new File(repoPath);\r\n        try (Git git \u003d Git.open(gitDir)) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Git repositories using JGit.\r\nThis class provides static methods to analyze Git repositories and extract structural information.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "GitRepositoryInfo",
          "methodName": "parseRepository",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            }
          ],
          "body": "{\r\n        File gitDir \u003d new File(repoPath);\r\n        try (Git git \u003d Git.open(gitDir)) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Parse a Git repository and extract comprehensive information.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "GitRepositoryInfo object containing repository information"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Parse a Git repository and extract comprehensive information.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "GitRepositoryInfo object containing repository information"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "RevCommit",
          "methodName": "getLatestCommit",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Iterable\u003cRevCommit\u003e commits \u003d git.log().setMaxCount(1).call();\r\n        return commits.iterator().hasNext() ? commits.iterator().next() : null;\r\n    }",
          "javadoc": {
            "description": "Get the latest commit in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "The latest RevCommit or null if the repository is empty"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "CommitInfo",
          "methodName": "convertToCommitInfo",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            },
            {
              "type": "Repository",
              "name": "repository"
            }
          ],
          "body": "{\r\n        PersonIdent authorIdent \u003d commit.getAuthorIdent();\r\n        PersonIdent committerIdent \u003d commit.getCommitterIdent();\r\n\r\n        // Get parent commits\r\n        List\u003cString\u003e parentIds \u003d new ArrayList\u003c\u003e();\r\n        for (RevCommit parent : commit.getParents()) {\r\n            parentIds.add(parent.getName());\r\n        }\r\n\r\n        // Get file changes\r\n        List\u003cFileChange\u003e fileChanges \u003d getFileChanges(commit, repository);\r\n\r\n        return CommitInfo.builder()\r\n                .id(commit.getName())\r\n                .shortId(commit.getName().substring(0, 7))\r\n                .message(commit.getFullMessage())\r\n                .authorName(authorIdent.getName())\r\n                .authorEmail(authorIdent.getEmailAddress())\r\n                .authorDate(authorIdent.getWhen())\r\n                .committerName(committerIdent.getName())\r\n                .committerEmail(committerIdent.getEmailAddress())\r\n                .commitDate(committerIdent.getWhen())\r\n                .parentIds(parentIds)\r\n                .changedFiles(fileChanges)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Convert a RevCommit to a CommitInfo object.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "commit     The RevCommit to convert"
              },
              {
                "name": "param",
                "value": "repository The repository containing the commit"
              },
              {
                "name": "return",
                "value": "A CommitInfo object"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cFileChange\u003e",
          "methodName": "getFileChanges",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            },
            {
              "type": "Repository",
              "name": "repository"
            }
          ],
          "body": "{\r\n        List\u003cFileChange\u003e changes \u003d new ArrayList\u003c\u003e();\r\n\r\n        // If this is the first commit, there\u0027s nothing to compare with\r\n        if (commit.getParentCount() \u003d\u003d 0) {\r\n            return changes;\r\n        }\r\n\r\n        RevCommit parent \u003d commit.getParent(0);\r\n\r\n        try (ObjectReader reader \u003d repository.newObjectReader();\r\n             DiffFormatter formatter \u003d new DiffFormatter(DisabledOutputStream.INSTANCE)) {\r\n\r\n            formatter.setRepository(repository);\r\n            formatter.setDiffComparator(RawTextComparator.DEFAULT);\r\n\r\n            CanonicalTreeParser oldTreeParser \u003d new CanonicalTreeParser();\r\n            oldTreeParser.reset(reader, parent.getTree());\r\n\r\n            CanonicalTreeParser newTreeParser \u003d new CanonicalTreeParser();\r\n            newTreeParser.reset(reader, commit.getTree());\r\n\r\n            List\u003cDiffEntry\u003e diffs \u003d formatter.scan(oldTreeParser, newTreeParser);\r\n\r\n            for (DiffEntry diff : diffs) {\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }\r\n        }\r\n\r\n        return changes;\r\n    }",
          "javadoc": {
            "description": "Get file changes for a commit.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "commit     The commit to analyze"
              },
              {
                "name": "param",
                "value": "repository The repository containing the commit"
              },
              {
                "name": "return",
                "value": "List of FileChange objects"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "with",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            return changes;\r\n        }",
          "comments": [
            "If this is the first commit, there\u0027s nothing to compare with"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "DiffFormatter",
          "parameters": [],
          "body": "{\r\n\r\n            formatter.setRepository(repository);\r\n            formatter.setDiffComparator(RawTextComparator.DEFAULT);\r\n\r\n            CanonicalTreeParser oldTreeParser \u003d new CanonicalTreeParser();\r\n            oldTreeParser.reset(reader, parent.getTree());\r\n\r\n            CanonicalTreeParser newTreeParser \u003d new CanonicalTreeParser();\r\n            newTreeParser.reset(reader, commit.getTree());\r\n\r\n            List\u003cDiffEntry\u003e diffs \u003d formatter.scan(oldTreeParser, newTreeParser);\r\n\r\n            for (DiffEntry diff : diffs) {\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "CanonicalTreeParser",
          "parameters": [],
          "body": "{\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "CanonicalTreeParser",
          "parameters": [],
          "body": "{\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "ChangeType",
          "methodName": "convertChangeType",
          "parameters": [
            {
              "type": "DiffEntry.ChangeType",
              "name": "jgitChangeType"
            }
          ],
          "body": "{\r\n        switch (jgitChangeType) {\r\n            case ADD:\r\n                return FileChange.ChangeType.ADD;\r\n            case MODIFY:\r\n                return FileChange.ChangeType.MODIFY;\r\n            case DELETE:\r\n                return FileChange.ChangeType.DELETE;\r\n            case RENAME:\r\n                return FileChange.ChangeType.RENAME;\r\n            case COPY:\r\n                return FileChange.ChangeType.COPY;\r\n            default:\r\n                return FileChange.ChangeType.MODIFY;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Convert JGit change type to our own ChangeType enum.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "jgitChangeType The JGit DiffEntry.ChangeType"
              },
              {
                "name": "return",
                "value": "Our FileChange.ChangeType"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cBranchInfo\u003e",
          "methodName": "getAllBranches",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        List\u003cBranchInfo\u003e branches \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Get current branch name\r\n        String currentBranch \u003d git.getRepository().getBranch();\r\n\r\n        // Get local branches\r\n        List\u003cRef\u003e localBranches \u003d git.branchList().call();\r\n        for (Ref branch : localBranches) {\r\n            String branchName \u003d branch.getName().substring(branch.getName().lastIndexOf(\"/\") + 1);\r\n\r\n            // Check if branch is merged\r\n            boolean merged \u003d false;\r\n            try {\r\n                List\u003cRef\u003e mergedBranches \u003d git.branchList().setContains(currentBranch).call();\r\n                for (Ref mergedBranch : mergedBranches) {\r\n                    if (mergedBranch.getName().equals(branch.getName())) {\r\n                        merged \u003d true;\r\n                        break;\r\n                    }\r\n                }\r\n            } catch (Exception e) {\r\n                // Ignore errors checking merged status\r\n            }\r\n\r\n            // Get tracking branch\r\n            String trackingBranch \u003d null;\r\n            try {\r\n                trackingBranch \u003d git.getRepository().getConfig().getString(\"branch\", branchName, \"merge\");\r\n                if (trackingBranch !\u003d null \u0026\u0026 trackingBranch.startsWith(\"refs/heads/\")) {\r\n                    trackingBranch \u003d trackingBranch.substring(\"refs/heads/\".length());\r\n                }\r\n            } catch (Exception e) {\r\n                // Ignore errors getting tracking branch\r\n            }\r\n\r\n            branches.add(BranchInfo.builder()\r\n                    .name(branchName)\r\n                    .current(branchName.equals(currentBranch))\r\n                    .remote(false)\r\n                    .commitId(branch.getObjectId().getName())\r\n                    .merged(merged)\r\n                    .trackingBranch(trackingBranch)\r\n                    .build());\r\n        }\r\n\r\n        // Get remote branches\r\n        List\u003cRef\u003e remoteBranches \u003d git.branchList().setListMode(ListBranchCommand.ListMode.REMOTE).call();\r\n        for (Ref branch : remoteBranches) {\r\n            String fullName \u003d branch.getName();\r\n            String remoteName \u003d fullName.substring(fullName.indexOf(\"/\") + 1, fullName.lastIndexOf(\"/\"));\r\n            String branchName \u003d fullName.substring(fullName.lastIndexOf(\"/\") + 1);\r\n            branches.add(BranchInfo.builder()\r\n                    .name(branchName)\r\n                    .current(false)\r\n                    .remote(true)\r\n                    .remoteName(remoteName)\r\n                    .commitId(branch.getObjectId().getName())\r\n                    .build());\r\n        }\r\n\r\n        return branches;\r\n    }",
          "javadoc": {
            "description": "Get all branches in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "List of BranchInfo objects"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cTagInfo\u003e",
          "methodName": "getAllTags",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        List\u003cTagInfo\u003e tags \u003d new ArrayList\u003c\u003e();\r\n        List\u003cRef\u003e tagRefs \u003d git.tagList().call();\r\n\r\n        try (RevWalk revWalk \u003d new RevWalk(git.getRepository())) {\r\n            for (Ref tagRef : tagRefs) {\r\n                String tagName \u003d tagRef.getName().substring(tagRef.getName().lastIndexOf(\"/\") + 1);\r\n                ObjectId objectId \u003d tagRef.getObjectId();\r\n\r\n                boolean isAnnotated \u003d false;\r\n                RevTag revTag \u003d null;\r\n                RevCommit commit \u003d null;\r\n\r\n                try {\r\n                    revTag \u003d revWalk.parseTag(objectId);\r\n                    isAnnotated \u003d true;\r\n                    commit \u003d revWalk.parseCommit(revTag.getObject());\r\n                } catch (IOException e) {\r\n                    // Not an annotated tag\r\n                    commit \u003d revWalk.parseCommit(objectId);\r\n                }\r\n\r\n                TagInfo.TagInfoBuilder builder \u003d TagInfo.builder()\r\n                        .name(tagName)\r\n                        .commitId(commit.getName())\r\n                        .annotated(isAnnotated);\r\n\r\n                if (isAnnotated \u0026\u0026 revTag !\u003d null) {\r\n                    PersonIdent taggerIdent \u003d revTag.getTaggerIdent();\r\n                    builder.message(revTag.getFullMessage())\r\n                            .taggerName(taggerIdent.getName())\r\n                            .taggerEmail(taggerIdent.getEmailAddress())\r\n                            .taggerDate(taggerIdent.getWhen());\r\n                }\r\n\r\n                tags.add(builder.build());\r\n            }\r\n        }\r\n\r\n        return tags;\r\n    }",
          "javadoc": {
            "description": "Get all tags in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "List of TagInfo objects"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "RevWalk",
          "parameters": [],
          "body": "{\r\n            for (Ref tagRef : tagRefs) {\r\n                String tagName \u003d tagRef.getName().substring(tagRef.getName().lastIndexOf(\"/\") + 1);\r\n                ObjectId objectId \u003d tagRef.getObjectId();\r\n\r\n                boolean isAnnotated \u003d false;\r\n                RevTag revTag \u003d null;\r\n                RevCommit commit \u003d null;\r\n\r\n                try {\r\n                    revTag \u003d revWalk.parseTag(objectId);\r\n                    isAnnotated \u003d true;\r\n                    commit \u003d revWalk.parseCommit(revTag.getObject());\r\n                } catch (IOException e) {\r\n                    // Not an annotated tag\r\n                    commit \u003d revWalk.parseCommit(objectId);\r\n                }\r\n\r\n                TagInfo.TagInfoBuilder builder \u003d TagInfo.builder()\r\n                        .name(tagName)\r\n                        .commitId(commit.getName())\r\n                        .annotated(isAnnotated);\r\n\r\n                if (isAnnotated \u0026\u0026 revTag !\u003d null) {\r\n                    PersonIdent taggerIdent \u003d revTag.getTaggerIdent();\r\n                    builder.message(revTag.getFullMessage())\r\n                            .taggerName(taggerIdent.getName())\r\n                            .taggerEmail(taggerIdent.getEmailAddress())\r\n                            .taggerDate(taggerIdent.getWhen());\r\n                }\r\n\r\n                tags.add(builder.build());\r\n            }\r\n        }",
          "javadoc": {
            "description": "Get all tags in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "List of TagInfo objects"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "hasUncommittedChanges",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Status status \u003d git.status().call();\r\n        return !status.isClean();\r\n    }",
          "javadoc": {
            "description": "Check if the repository has uncommitted changes.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "true if there are uncommitted changes, false otherwise"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "int",
          "methodName": "countCommits",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        LogCommand logCommand \u003d git.log();\r\n        Iterable\u003cRevCommit\u003e commits \u003d logCommand.call();\r\n        return (int) StreamSupport.stream(commits.spliterator(), false).count();\r\n    }",
          "javadoc": {
            "description": "Count the number of commits in the current branch.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "The number of commits"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "List\u003cContributorInfo\u003e",
          "methodName": "getTopContributors",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            },
            {
              "type": "int",
              "name": "maxCount"
            }
          ],
          "body": "{\r\n        // Maps to track contributor statistics\r\n        Map\u003cString, ContributorInfo.ContributorInfoBuilder\u003e contributors \u003d new HashMap\u003c\u003e();\r\n        Map\u003cString, Date\u003e firstCommitDates \u003d new HashMap\u003c\u003e();\r\n        Map\u003cString, Date\u003e lastCommitDates \u003d new HashMap\u003c\u003e();\r\n\r\n        // Get all commits\r\n        Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n        for (RevCommit commit : commits) {\r\n            PersonIdent author \u003d commit.getAuthorIdent();\r\n            String authorEmail \u003d author.getEmailAddress();\r\n\r\n            // Initialize contributor if not exists\r\n            if (!contributors.containsKey(authorEmail)) {\r\n                contributors.put(authorEmail, ContributorInfo.builder()\r\n                        .name(author.getName())\r\n                        .email(authorEmail)\r\n                        .commitCount(0)\r\n                        .linesAdded(0)\r\n                        .linesDeleted(0));\r\n\r\n                firstCommitDates.put(authorEmail, author.getWhen());\r\n                lastCommitDates.put(authorEmail, author.getWhen());\r\n            }\r\n\r\n            // Update commit count\r\n            ContributorInfo.ContributorInfoBuilder contributor \u003d contributors.get(authorEmail);\r\n            contributor.commitCount(contributor.build().getCommitCount() + 1);\r\n\r\n            // Update dates\r\n            Date commitDate \u003d author.getWhen();\r\n            if (commitDate.before(firstCommitDates.get(authorEmail))) {\r\n                firstCommitDates.put(authorEmail, commitDate);\r\n            }\r\n            if (commitDate.after(lastCommitDates.get(authorEmail))) {\r\n                lastCommitDates.put(authorEmail, commitDate);\r\n            }\r\n\r\n            // Update line changes\r\n            if (commit.getParentCount() \u003e 0) {\r\n                List\u003cFileChange\u003e changes \u003d getFileChanges(commit, git.getRepository());\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                for (FileChange change : changes) {\r\n                    linesAdded +\u003d change.getLinesAdded();\r\n                    linesDeleted +\u003d change.getLinesDeleted();\r\n                }\r\n\r\n                contributor.linesAdded(contributor.build().getLinesAdded() + linesAdded);\r\n                contributor.linesDeleted(contributor.build().getLinesDeleted() + linesDeleted);\r\n            }\r\n        }\r\n\r\n        // Build final contributor list\r\n        List\u003cContributorInfo\u003e result \u003d new ArrayList\u003c\u003e();\r\n        for (String email : contributors.keySet()) {\r\n            ContributorInfo.ContributorInfoBuilder builder \u003d contributors.get(email);\r\n            builder.firstCommitDate(firstCommitDates.get(email));\r\n            builder.lastCommitDate(lastCommitDates.get(email));\r\n            result.add(builder.build());\r\n        }\r\n\r\n        // Sort by commit count and limit to maxCount\r\n        result.sort((c1, c2) -\u003e Integer.compare(c2.getCommitCount(), c1.getCommitCount()));\r\n        return result.stream().limit(maxCount).collect(Collectors.toList());\r\n    }",
          "javadoc": {
            "description": "Get the top contributors to the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git      The Git instance"
              },
              {
                "name": "param",
                "value": "maxCount Maximum number of contributors to return"
              },
              {
                "name": "return",
                "value": "List of ContributorInfo objects"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "exists",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                contributors.put(authorEmail, ContributorInfo.builder()\r\n                        .name(author.getName())\r\n                        .email(authorEmail)\r\n                        .commitCount(0)\r\n                        .linesAdded(0)\r\n                        .linesDeleted(0));\r\n\r\n                firstCommitDates.put(authorEmail, author.getWhen());\r\n                lastCommitDates.put(authorEmail, author.getWhen());\r\n            }",
          "comments": [
            "Initialize contributor if not exists"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "changes",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                List\u003cFileChange\u003e changes \u003d getFileChanges(commit, git.getRepository());\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                for (FileChange change : changes) {\r\n                    linesAdded +\u003d change.getLinesAdded();\r\n                    linesDeleted +\u003d change.getLinesDeleted();\r\n                }\r\n\r\n                contributor.linesAdded(contributor.build().getLinesAdded() + linesAdded);\r\n                contributor.linesDeleted(contributor.build().getLinesDeleted() + linesDeleted);\r\n            }",
          "comments": [
            "Update line changes"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "getRepositoryStatistics",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Map\u003cString, Object\u003e statistics \u003d new HashMap\u003c\u003e();\r\n\r\n        // Get all commits\r\n        Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n        List\u003cRevCommit\u003e commitList \u003d StreamSupport.stream(commits.spliterator(), false)\r\n                .collect(Collectors.toList());\r\n\r\n        // Calculate commits per day of week\r\n        Map\u003cString, Integer\u003e commitsPerDayOfWeek \u003d new HashMap\u003c\u003e();\r\n        String[] daysOfWeek \u003d {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\r\n        for (String day : daysOfWeek) {\r\n            commitsPerDayOfWeek.put(day, 0);\r\n        }\r\n\r\n        SimpleDateFormat dayFormat \u003d new SimpleDateFormat(\"EEEE\");\r\n        for (RevCommit commit : commitList) {\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String dayOfWeek \u003d dayFormat.format(commitDate);\r\n            commitsPerDayOfWeek.put(dayOfWeek, commitsPerDayOfWeek.get(dayOfWeek) + 1);\r\n        }\r\n\r\n        // Calculate commits per hour\r\n        Map\u003cInteger, Integer\u003e commitsPerHour \u003d new HashMap\u003c\u003e();\r\n        for (int i \u003d 0; i \u003c 24; i++) {\r\n            commitsPerHour.put(i, 0);\r\n        }\r\n\r\n        Calendar calendar \u003d Calendar.getInstance();\r\n        for (RevCommit commit : commitList) {\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            calendar.setTime(commitDate);\r\n            int hour \u003d calendar.get(Calendar.HOUR_OF_DAY);\r\n            commitsPerHour.put(hour, commitsPerHour.get(hour) + 1);\r\n        }\r\n\r\n        // Calculate commits per month\r\n        Map\u003cString, Integer\u003e commitsPerMonth \u003d new HashMap\u003c\u003e();\r\n        String[] months \u003d {\"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\r\n                \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\r\n        for (String month : months) {\r\n            commitsPerMonth.put(month, 0);\r\n        }\r\n\r\n        SimpleDateFormat monthFormat \u003d new SimpleDateFormat(\"MMMM\");\r\n        for (RevCommit commit : commitList) {\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String month \u003d monthFormat.format(commitDate);\r\n            commitsPerMonth.put(month, commitsPerMonth.get(month) + 1);\r\n        }\r\n\r\n        // Calculate average commit size (in changed files)\r\n        int totalChangedFiles \u003d 0;\r\n        for (RevCommit commit : commitList) {\r\n            if (commit.getParentCount() \u003e 0) {\r\n                List\u003cFileChange\u003e changes \u003d getFileChanges(commit, git.getRepository());\r\n                totalChangedFiles +\u003d changes.size();\r\n            }\r\n        }\r\n\r\n        double avgChangedFiles \u003d commitList.isEmpty() ? 0 : (double) totalChangedFiles / commitList.size();\r\n\r\n        // Add statistics to the map\r\n        statistics.put(\"totalCommits\", commitList.size());\r\n        statistics.put(\"commitsPerDayOfWeek\", commitsPerDayOfWeek);\r\n        statistics.put(\"commitsPerHour\", commitsPerHour);\r\n        statistics.put(\"commitsPerMonth\", commitsPerMonth);\r\n        statistics.put(\"averageChangedFilesPerCommit\", avgChangedFiles);\r\n\r\n        return statistics;\r\n    }",
          "javadoc": {
            "description": "Get various statistics about the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "Map of statistics"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String dayOfWeek \u003d dayFormat.format(commitDate);\r\n            commitsPerDayOfWeek.put(dayOfWeek, commitsPerDayOfWeek.get(dayOfWeek) + 1);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String month \u003d monthFormat.format(commitDate);\r\n            commitsPerMonth.put(month, commitsPerMonth.get(month) + 1);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "commit",
          "methodName": "size",
          "parameters": [
            {
              "type": "in",
              "name": "changed"
            }
          ],
          "body": "{\r\n            if (commit.getParentCount() \u003e 0) {\r\n                List\u003cFileChange\u003e changes \u003d getFileChanges(commit, git.getRepository());\r\n                totalChangedFiles +\u003d changes.size();\r\n            }\r\n        }",
          "comments": [
            "Calculate average commit size (in changed files)"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Map\u003cString, Integer\u003e",
          "methodName": "getFileExtensionCounts",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Map\u003cString, Integer\u003e extensionCounts \u003d new HashMap\u003c\u003e();\r\n\r\n        RevCommit headCommit \u003d getLatestCommit(git);\r\n        if (headCommit \u003d\u003d null) {\r\n            return extensionCounts;\r\n        }\r\n\r\n        Repository repository \u003d git.getRepository();\r\n        try (TreeWalk treeWalk \u003d new TreeWalk(repository)) {\r\n            treeWalk.addTree(headCommit.getTree());\r\n            treeWalk.setRecursive(true);\r\n\r\n            while (treeWalk.next()) {\r\n                String path \u003d treeWalk.getPathString();\r\n                int dotIndex \u003d path.lastIndexOf(\u0027.\u0027);\r\n                if (dotIndex \u003e 0) {\r\n                    String extension \u003d path.substring(dotIndex + 1).toLowerCase();\r\n                    extensionCounts.put(extension, extensionCounts.getOrDefault(extension, 0) + 1);\r\n                } else {\r\n                    extensionCounts.put(\"(no extension)\", extensionCounts.getOrDefault(\"(no extension)\", 0) + 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        return extensionCounts;\r\n    }",
          "javadoc": {
            "description": "Get counts of files by extension in the repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "Map of file extensions to counts"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "TreeWalk",
          "parameters": [],
          "body": "{\r\n            treeWalk.addTree(headCommit.getTree());\r\n            treeWalk.setRecursive(true);\r\n\r\n            while (treeWalk.next()) {\r\n                String path \u003d treeWalk.getPathString();\r\n                int dotIndex \u003d path.lastIndexOf(\u0027.\u0027);\r\n                if (dotIndex \u003e 0) {\r\n                    String extension \u003d path.substring(dotIndex + 1).toLowerCase();\r\n                    extensionCounts.put(extension, extensionCounts.getOrDefault(extension, 0) + 1);\r\n                } else {\r\n                    extensionCounts.put(\"(no extension)\", extensionCounts.getOrDefault(\"(no extension)\", 0) + 1);\r\n                }\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "repository",
          "parameters": [
            {
              "type": "date",
              "name": "of"
            }
          ],
          "body": "{\r\n        Repository repository \u003d git.getRepository();\r\n\r\n        try (RevWalk revWalk \u003d new RevWalk(repository)) {\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "Date",
          "methodName": "getRepositoryCreationDate",
          "parameters": [
            {
              "type": "Git",
              "name": "git"
            }
          ],
          "body": "{\r\n        Repository repository \u003d git.getRepository();\r\n\r\n        try (RevWalk revWalk \u003d new RevWalk(repository)) {\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }",
          "javadoc": {
            "description": "Get the creation date of the repository (date of the first commit).\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "The creation date or null if no commits exist"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "RevWalk",
          "parameters": [],
          "body": "{\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }",
          "javadoc": {
            "description": "Get the creation date of the repository (date of the first commit).\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "git The Git instance"
              },
              {
                "name": "return",
                "value": "The creation date or null if no commits exist"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "findGitRepositories",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            }
          ],
          "body": "{\r\n        List\u003cFile\u003e repositories \u003d new ArrayList\u003c\u003e();\r\n        findGitRepositoriesRecursive(directory, repositories);\r\n        return repositories;\r\n    }",
          "javadoc": {
            "description": "Find all Git repositories in a directory and its subdirectories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "return",
                "value": "List of Git repository directories"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "findGitRepositoriesRecursive",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "List\u003cFile\u003e",
              "name": "repositories"
            }
          ],
          "body": "{\r\n        File[] files \u003d directory.listFiles();\r\n        if (files !\u003d null) {\r\n            for (File file : files) {\r\n                if (file.isDirectory()) {\r\n                    if (file.getName().equals(\".git\")) {\r\n                        repositories.add(directory);\r\n                    } else if (!file.getName().equals(\".git\")) {\r\n                        findGitRepositoriesRecursive(file, repositories);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Recursive helper method to find all Git repositories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory    The directory to search"
              },
              {
                "name": "param",
                "value": "repositories List to collect Git repository directories"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                        findGitRepositoriesRecursive(file, repositories);\r\n                    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "CommitInfo",
          "methodName": "getCommitInfo",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "commitId"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            try (RevWalk revWalk \u003d new RevWalk(repository)) {\r\n                ObjectId objectId \u003d repository.resolve(commitId);\r\n                if (objectId \u003d\u003d null) {\r\n                    return null;\r\n                }\r\n\r\n                RevCommit commit \u003d revWalk.parseCommit(objectId);\r\n                return convertToCommitInfo(commit, repository);\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get specific information about a commit.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "commitId The commit ID"
              },
              {
                "name": "return",
                "value": "CommitInfo object containing commit information"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get specific information about a commit.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "commitId The commit ID"
              },
              {
                "name": "return",
                "value": "CommitInfo object containing commit information"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "RevWalk",
          "parameters": [],
          "body": "{\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "convertToCommitInfo",
          "parameters": [],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().setMaxCount(maxCount).call();\r\n            List\u003cCommitInfo\u003e commitInfos \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                commitInfos.add(convertToCommitInfo(commit, repository));\r\n            }\r\n\r\n            return commitInfos;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getRecentCommits",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "int",
              "name": "maxCount"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().setMaxCount(maxCount).call();\r\n            List\u003cCommitInfo\u003e commitInfos \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                commitInfos.add(convertToCommitInfo(commit, repository));\r\n            }\r\n\r\n            return commitInfos;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get a list of recent commits.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "maxCount The maximum number of commits to retrieve"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get a list of recent commits.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "maxCount The maximum number of commits to retrieve"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects"
              },
              {
                "name": "throws",
                "value": "IOException     If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getAllCommits",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e commitInfos \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                commitInfos.add(convertToCommitInfo(commit, repository));\r\n            }\r\n\r\n            return commitInfos;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get a list of all commits in a repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for all commits"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get a list of all commits in a repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for all commits"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getCommitsByAuthor",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "authorName"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e authorCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n                if (author.getName().contains(authorName) || author.getEmailAddress().contains(authorName)) {\r\n                    authorCommits.add(convertToCommitInfo(commit, repository));\r\n                }\r\n            }\r\n\r\n            return authorCommits;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get commits by a specific author.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "authorName The name or email of the author"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for commits by the author"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Start",
          "methodName": "date",
          "parameters": [],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e dateRangeCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.equals(since) || commitDate.after(since)) \u0026\u0026\r\n                        (commitDate.equals(until) || commitDate.before(until))) {\r\n                    dateRangeCommits.add(convertToCommitInfo(commit, repository));\r\n                }\r\n            }\r\n\r\n            return dateRangeCommits;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "End",
          "methodName": "date",
          "parameters": [],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e dateRangeCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.equals(since) || commitDate.after(since)) \u0026\u0026\r\n                        (commitDate.equals(until) || commitDate.before(until))) {\r\n                    dateRangeCommits.add(convertToCommitInfo(commit, repository));\r\n                }\r\n            }\r\n\r\n            return dateRangeCommits;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getCommitsByDateRange",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "Date",
              "name": "since"
            },
            {
              "type": "Date",
              "name": "until"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            List\u003cCommitInfo\u003e dateRangeCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.equals(since) || commitDate.after(since)) \u0026\u0026\r\n                        (commitDate.equals(until) || commitDate.before(until))) {\r\n                    dateRangeCommits.add(convertToCommitInfo(commit, repository));\r\n                }\r\n            }\r\n\r\n            return dateRangeCommits;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get commits within a date range.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "since Start date (inclusive)"
              },
              {
                "name": "param",
                "value": "until End date (inclusive)"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for commits within the date range"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cCommitInfo\u003e",
          "methodName": "getFileHistory",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "filePath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().addPath(filePath).call();\r\n            List\u003cCommitInfo\u003e fileCommits \u003d new ArrayList\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                fileCommits.add(convertToCommitInfo(commit, repository));\r\n            }\r\n\r\n            return fileCommits;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get the history of a specific file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "filePath The path to the file within the repository"
              },
              {
                "name": "return",
                "value": "List of CommitInfo objects for commits that changed the file"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getFileBlame",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "filePath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            BlameResult blameResult \u003d git.blame()\r\n                    .setFilePath(filePath)\r\n                    .call();\r\n\r\n            StringBuilder result \u003d new StringBuilder();\r\n\r\n            int lineCount \u003d blameResult.getResultContents().size();\r\n            for (int i \u003d 0; i \u003c lineCount; i++) {\r\n                RevCommit commit \u003d blameResult.getSourceCommit(i);\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n                String shortCommitId \u003d commit.getName().substring(0, 7);\r\n                String line \u003d blameResult.getResultContents().getString(i);\r\n\r\n                result.append(String.format(\"%s (%s - %s): %s\\n\",\r\n                        shortCommitId,\r\n                        author.getName(),\r\n                        new SimpleDateFormat(\"yyyy-MM-dd\").format(author.getWhen()),\r\n                        line));\r\n            }\r\n\r\n            return result.toString();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get blame information for a specific file, showing who last modified each line.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "filePath The path to the file within the repository"
              },
              {
                "name": "return",
                "value": "String representing blame information"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StringBuilder",
          "parameters": [],
          "body": "{\r\n                RevCommit commit \u003d blameResult.getSourceCommit(i);\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n                String shortCommitId \u003d commit.getName().substring(0, 7);\r\n                String line \u003d blameResult.getResultContents().getString(i);\r\n\r\n                result.append(String.format(\"%s (%s - %s): %s\\n\",\r\n                        shortCommitId,\r\n                        author.getName(),\r\n                        new SimpleDateFormat(\"yyyy-MM-dd\").format(author.getWhen()),\r\n                        line));\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            ObjectId oldId \u003d repository.resolve(oldCommitId);\r\n            ObjectId newId \u003d repository.resolve(newCommitId);\r\n\r\n            if (oldId \u003d\u003d null || newId \u003d\u003d null) {\r\n                return \"Invalid commit IDs\";\r\n            }\r\n\r\n            ByteArrayOutputStream outputStream \u003d new ByteArrayOutputStream();\r\n            try (DiffFormatter formatter \u003d new DiffFormatter(outputStream)) {\r\n                formatter.setRepository(repository);\r\n\r\n                RevCommit oldCommit \u003d repository.parseCommit(oldId);\r\n                RevCommit newCommit \u003d repository.parseCommit(newId);\r\n\r\n                AbstractTreeIterator oldTreeIterator \u003d getCanonicalTreeParser(repository, oldCommit);\r\n                AbstractTreeIterator newTreeIterator \u003d getCanonicalTreeParser(repository, newCommit);\r\n\r\n                List\u003cDiffEntry\u003e diffs \u003d git.diff()\r\n                        .setOldTree(oldTreeIterator)\r\n                        .setNewTree(newTreeIterator)\r\n                        .call();\r\n\r\n                for (DiffEntry diff : diffs) {\r\n                    formatter.format(diff);\r\n                    formatter.flush();\r\n                }\r\n\r\n                return new String(outputStream.toByteArray(), StandardCharsets.UTF_8);\r\n            }\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getDiffBetweenCommits",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "String",
              "name": "oldCommitId"
            },
            {
              "type": "String",
              "name": "newCommitId"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            ObjectId oldId \u003d repository.resolve(oldCommitId);\r\n            ObjectId newId \u003d repository.resolve(newCommitId);\r\n\r\n            if (oldId \u003d\u003d null || newId \u003d\u003d null) {\r\n                return \"Invalid commit IDs\";\r\n            }\r\n\r\n            ByteArrayOutputStream outputStream \u003d new ByteArrayOutputStream();\r\n            try (DiffFormatter formatter \u003d new DiffFormatter(outputStream)) {\r\n                formatter.setRepository(repository);\r\n\r\n                RevCommit oldCommit \u003d repository.parseCommit(oldId);\r\n                RevCommit newCommit \u003d repository.parseCommit(newId);\r\n\r\n                AbstractTreeIterator oldTreeIterator \u003d getCanonicalTreeParser(repository, oldCommit);\r\n                AbstractTreeIterator newTreeIterator \u003d getCanonicalTreeParser(repository, newCommit);\r\n\r\n                List\u003cDiffEntry\u003e diffs \u003d git.diff()\r\n                        .setOldTree(oldTreeIterator)\r\n                        .setNewTree(newTreeIterator)\r\n                        .call();\r\n\r\n                for (DiffEntry diff : diffs) {\r\n                    formatter.format(diff);\r\n                    formatter.flush();\r\n                }\r\n\r\n                return new String(outputStream.toByteArray(), StandardCharsets.UTF_8);\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get diff between two commits.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "oldCommitId The ID of the old commit"
              },
              {
                "name": "param",
                "value": "newCommitId The ID of the new commit"
              },
              {
                "name": "return",
                "value": "String representing the diff"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ByteArrayOutputStream",
          "parameters": [],
          "body": "{\r\n                formatter.setRepository(repository);\r\n\r\n                RevCommit oldCommit \u003d repository.parseCommit(oldId);\r\n                RevCommit newCommit \u003d repository.parseCommit(newId);\r\n\r\n                AbstractTreeIterator oldTreeIterator \u003d getCanonicalTreeParser(repository, oldCommit);\r\n                AbstractTreeIterator newTreeIterator \u003d getCanonicalTreeParser(repository, newCommit);\r\n\r\n                List\u003cDiffEntry\u003e diffs \u003d git.diff()\r\n                        .setOldTree(oldTreeIterator)\r\n                        .setNewTree(newTreeIterator)\r\n                        .call();\r\n\r\n                for (DiffEntry diff : diffs) {\r\n                    formatter.format(diff);\r\n                    formatter.flush();\r\n                }\r\n\r\n                return new String(outputStream.toByteArray(), StandardCharsets.UTF_8);\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "DiffFormatter",
          "parameters": [],
          "body": "{\r\n                formatter.setRepository(repository);\r\n\r\n                RevCommit oldCommit \u003d repository.parseCommit(oldId);\r\n                RevCommit newCommit \u003d repository.parseCommit(newId);\r\n\r\n                AbstractTreeIterator oldTreeIterator \u003d getCanonicalTreeParser(repository, oldCommit);\r\n                AbstractTreeIterator newTreeIterator \u003d getCanonicalTreeParser(repository, newCommit);\r\n\r\n                List\u003cDiffEntry\u003e diffs \u003d git.diff()\r\n                        .setOldTree(oldTreeIterator)\r\n                        .setNewTree(newTreeIterator)\r\n                        .call();\r\n\r\n                for (DiffEntry diff : diffs) {\r\n                    formatter.format(diff);\r\n                    formatter.flush();\r\n                }\r\n\r\n                return new String(outputStream.toByteArray(), StandardCharsets.UTF_8);\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "String",
          "parameters": [],
          "body": "{\r\n        try (RevWalk walk \u003d new RevWalk(repository)) {\r\n            RevCommit commitTree \u003d walk.parseCommit(commit.getId());\r\n            try (ObjectReader reader \u003d repository.newObjectReader()) {\r\n                CanonicalTreeParser treeParser \u003d new CanonicalTreeParser();\r\n                treeParser.reset(reader, commitTree.getTree().getId());\r\n                return treeParser;\r\n            }\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "AbstractTreeIterator",
          "methodName": "getCanonicalTreeParser",
          "parameters": [
            {
              "type": "Repository",
              "name": "repository"
            },
            {
              "type": "RevCommit",
              "name": "commit"
            }
          ],
          "body": "{\r\n        try (RevWalk walk \u003d new RevWalk(repository)) {\r\n            RevCommit commitTree \u003d walk.parseCommit(commit.getId());\r\n            try (ObjectReader reader \u003d repository.newObjectReader()) {\r\n                CanonicalTreeParser treeParser \u003d new CanonicalTreeParser();\r\n                treeParser.reset(reader, commitTree.getTree().getId());\r\n                return treeParser;\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to get a tree parser for a commit.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "RevWalk",
          "parameters": [],
          "body": "{\r\n            revWalk.sort(RevSort.COMMIT_TIME_DESC, true);\r\n            revWalk.sort(RevSort.REVERSE, true);\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            for (RevCommit commit : commits) {\r\n                revWalk.parseCommit(commit);\r\n                return commit.getAuthorIdent().getWhen();\r\n            }\r\n        }",
          "javadoc": {
            "description": "Helper method to get a tree parser for a commit.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "CanonicalTreeParser",
          "parameters": [],
          "body": "{\r\n                FileChange.ChangeType type \u003d convertChangeType(diff.getChangeType());\r\n\r\n                // Calculate line changes for this file\r\n                int linesAdded \u003d 0;\r\n                int linesDeleted \u003d 0;\r\n\r\n                try {\r\n                    for (Edit edit : formatter.toFileHeader(diff).toEditList()) {\r\n                        linesAdded +\u003d edit.getEndB() - edit.getBeginB();\r\n                        linesDeleted +\u003d edit.getEndA() - edit.getBeginA();\r\n                    }\r\n                } catch (Exception e) {\r\n                    // In case of binary files or other issues\r\n                }\r\n\r\n                changes.add(FileChange.builder()\r\n                        .type(type)\r\n                        .path(diff.getNewPath())\r\n                        .oldPath(diff.getOldPath())\r\n                        .linesAdded(linesAdded)\r\n                        .linesDeleted(linesDeleted)\r\n                        .mode(diff.getNewMode().getBits())\r\n                        .build());\r\n            }",
          "javadoc": {
            "description": "Helper method to get a tree parser for a commit.",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Integer\u003e",
          "methodName": "getContributionsByDayOfWeek",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            // Initialize days of week map\r\n            Map\u003cString, Integer\u003e daysOfWeek \u003d new LinkedHashMap\u003c\u003e();\r\n            daysOfWeek.put(\"Monday\", 0);\r\n            daysOfWeek.put(\"Tuesday\", 0);\r\n            daysOfWeek.put(\"Wednesday\", 0);\r\n            daysOfWeek.put(\"Thursday\", 0);\r\n            daysOfWeek.put(\"Friday\", 0);\r\n            daysOfWeek.put(\"Saturday\", 0);\r\n            daysOfWeek.put(\"Sunday\", 0);\r\n\r\n            // Get all commits\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            SimpleDateFormat dayFormat \u003d new SimpleDateFormat(\"EEEE\");\r\n\r\n            // Count commits by day of week\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                String dayOfWeek \u003d dayFormat.format(commitDate);\r\n                daysOfWeek.put(dayOfWeek, daysOfWeek.get(dayOfWeek) + 1);\r\n            }\r\n\r\n            return daysOfWeek;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get a summary of contributions by day of week.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "Map with days of week as keys and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get a summary of contributions by day of week.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "Map with days of week as keys and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": [
            "Initialize days of week map"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n            String dayOfWeek \u003d dayFormat.format(commitDate);\r\n            commitsPerDayOfWeek.put(dayOfWeek, commitsPerDayOfWeek.get(dayOfWeek) + 1);\r\n        }",
          "comments": [
            "Get all commits",
            "Count commits by day of week"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "week",
          "methodName": "for",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            }
          ],
          "body": "{\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                String dayOfWeek \u003d dayFormat.format(commitDate);\r\n                daysOfWeek.put(dayOfWeek, daysOfWeek.get(dayOfWeek) + 1);\r\n            }",
          "comments": [
            "Get all commits",
            "Count commits by day of week"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cInteger, Integer\u003e",
          "methodName": "getContributionsByHourOfDay",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            // Initialize hours map (0-23)\r\n            Map\u003cInteger, Integer\u003e hourMap \u003d new LinkedHashMap\u003c\u003e();\r\n            for (int i \u003d 0; i \u003c 24; i++) {\r\n                hourMap.put(i, 0);\r\n            }\r\n\r\n            // Get all commits\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n            Calendar calendar \u003d Calendar.getInstance();\r\n\r\n            // Count commits by hour\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                calendar.setTime(commitDate);\r\n                int hour \u003d calendar.get(Calendar.HOUR_OF_DAY);\r\n                hourMap.put(hour, hourMap.get(hour) + 1);\r\n            }\r\n\r\n            return hourMap;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get a summary of contributions by hour of day.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "Map with hours as keys and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "javadoc": {
            "description": "Get a summary of contributions by hour of day.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "return",
                "value": "Map with hours as keys and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": [
            "Initialize hours map (0-23)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "hours",
          "methodName": "map",
          "parameters": [],
          "body": "{\r\n                hourMap.put(i, 0);\r\n            }",
          "comments": [
            "Initialize hours map (0-23)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "hour",
          "methodName": "for",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            }
          ],
          "body": "{\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                calendar.setTime(commitDate);\r\n                int hour \u003d calendar.get(Calendar.HOUR_OF_DAY);\r\n                hourMap.put(hour, hourMap.get(hour) + 1);\r\n            }",
          "comments": [
            "Get all commits",
            "Count commits by hour"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "as",
          "methodName": "keys",
          "parameters": [
            {
              "type": "format:",
              "name": "yyyy-MM-dd"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            // Create a calendar for the requested year\r\n            Calendar startCalendar \u003d Calendar.getInstance();\r\n            startCalendar.set(year, Calendar.JANUARY, 1, 0, 0, 0);\r\n            Date startDate \u003d startCalendar.getTime();\r\n\r\n            Calendar endCalendar \u003d Calendar.getInstance();\r\n            endCalendar.set(year, Calendar.DECEMBER, 31, 23, 59, 59);\r\n            Date endDate \u003d endCalendar.getTime();\r\n\r\n            // Initialize heat map\r\n            Map\u003cString, Integer\u003e heatMap \u003d new LinkedHashMap\u003c\u003e();\r\n            SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd\");\r\n\r\n            // Initialize all days of the year with zero counts\r\n            Calendar calendar \u003d Calendar.getInstance();\r\n            calendar.setTime(startDate);\r\n            while (calendar.getTime().before(endDate) || calendar.getTime().equals(endDate)) {\r\n                heatMap.put(dateFormat.format(calendar.getTime()), 0);\r\n                calendar.add(Calendar.DAY_OF_YEAR, 1);\r\n            }\r\n\r\n            // Get commits for the year\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n            // Count commits by day\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.after(startDate) || commitDate.equals(startDate)) \u0026\u0026\r\n                        (commitDate.before(endDate) || commitDate.equals(endDate))) {\r\n\r\n                    String dateStr \u003d dateFormat.format(commitDate);\r\n                    if (heatMap.containsKey(dateStr)) {\r\n                        heatMap.put(dateStr, heatMap.get(dateStr) + 1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return heatMap;\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Integer\u003e",
          "methodName": "getContributionHeatMap",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "int",
              "name": "year"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            // Create a calendar for the requested year\r\n            Calendar startCalendar \u003d Calendar.getInstance();\r\n            startCalendar.set(year, Calendar.JANUARY, 1, 0, 0, 0);\r\n            Date startDate \u003d startCalendar.getTime();\r\n\r\n            Calendar endCalendar \u003d Calendar.getInstance();\r\n            endCalendar.set(year, Calendar.DECEMBER, 31, 23, 59, 59);\r\n            Date endDate \u003d endCalendar.getTime();\r\n\r\n            // Initialize heat map\r\n            Map\u003cString, Integer\u003e heatMap \u003d new LinkedHashMap\u003c\u003e();\r\n            SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd\");\r\n\r\n            // Initialize all days of the year with zero counts\r\n            Calendar calendar \u003d Calendar.getInstance();\r\n            calendar.setTime(startDate);\r\n            while (calendar.getTime().before(endDate) || calendar.getTime().equals(endDate)) {\r\n                heatMap.put(dateFormat.format(calendar.getTime()), 0);\r\n                calendar.add(Calendar.DAY_OF_YEAR, 1);\r\n            }\r\n\r\n            // Get commits for the year\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n            // Count commits by day\r\n            for (RevCommit commit : commits) {\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.after(startDate) || commitDate.equals(startDate)) \u0026\u0026\r\n                        (commitDate.before(endDate) || commitDate.equals(endDate))) {\r\n\r\n                    String dateStr \u003d dateFormat.format(commitDate);\r\n                    if (heatMap.containsKey(dateStr)) {\r\n                        heatMap.put(dateStr, heatMap.get(dateStr) + 1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return heatMap;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Generate a monthly contribution heat map.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "year The year to analyze"
              },
              {
                "name": "return",
                "value": "Map with days as keys (format: yyyy-MM-dd) and commit counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": [
            "Create a calendar for the requested year"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            ObjectId oldId \u003d repository.resolve(oldCommitId);\r\n            ObjectId newId \u003d repository.resolve(newCommitId);\r\n\r\n            if (oldId \u003d\u003d null || newId \u003d\u003d null) {\r\n                return \"Invalid commit IDs\";\r\n            }\r\n\r\n            ByteArrayOutputStream outputStream \u003d new ByteArrayOutputStream();\r\n            try (DiffFormatter formatter \u003d new DiffFormatter(outputStream)) {\r\n                formatter.setRepository(repository);\r\n\r\n                RevCommit oldCommit \u003d repository.parseCommit(oldId);\r\n                RevCommit newCommit \u003d repository.parseCommit(newId);\r\n\r\n                AbstractTreeIterator oldTreeIterator \u003d getCanonicalTreeParser(repository, oldCommit);\r\n                AbstractTreeIterator newTreeIterator \u003d getCanonicalTreeParser(repository, newCommit);\r\n\r\n                List\u003cDiffEntry\u003e diffs \u003d git.diff()\r\n                        .setOldTree(oldTreeIterator)\r\n                        .setNewTree(newTreeIterator)\r\n                        .call();\r\n\r\n                for (DiffEntry diff : diffs) {\r\n                    formatter.format(diff);\r\n                    formatter.flush();\r\n                }\r\n\r\n                return new String(outputStream.toByteArray(), StandardCharsets.UTF_8);\r\n            }\r\n        }\r\n    }",
          "comments": [
            "Initialize heat map",
            "Initialize all days of the year with zero cou"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "day",
          "methodName": "for",
          "parameters": [
            {
              "type": "RevCommit",
              "name": "commit"
            }
          ],
          "body": "{\r\n                Date commitDate \u003d commit.getAuthorIdent().getWhen();\r\n                if ((commitDate.after(startDate) || commitDate.equals(startDate)) \u0026\u0026\r\n                        (commitDate.before(endDate) || commitDate.equals(endDate))) {\r\n\r\n                    String dateStr \u003d dateFormat.format(commitDate);\r\n                    if (heatMap.containsKey(dateStr)) {\r\n                        heatMap.put(dateStr, heatMap.get(dateStr) + 1);\r\n                    }\r\n                }\r\n            }",
          "comments": [
            "Get commits for the year",
            "Count commits by day"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "the",
          "methodName": "repository",
          "parameters": [
            {
              "type": "most",
              "name": "frequently"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get all commits\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n            // Count changes by file path\r\n            Map\u003cString, Integer\u003e fileChangeCounts \u003d new HashMap\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                if (commit.getParentCount() \u003e 0) {\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n                    for (FileChange change : changes) {\r\n                        String path \u003d change.getPath();\r\n                        if (path !\u003d null \u0026\u0026 !path.equals(\"/dev/null\")) {\r\n                            fileChangeCounts.put(path, fileChangeCounts.getOrDefault(path, 0) + 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Sort files by change count and limit results\r\n            return fileChangeCounts.entrySet().stream()\r\n                    .sorted(Map.Entry.\u003cString, Integer\u003ecomparingByValue().reversed())\r\n                    .limit(limit)\r\n                    .collect(Collectors.toMap(\r\n                            Map.Entry::getKey,\r\n                            Map.Entry::getValue,\r\n                            (e1, e2) -\u003e e1,\r\n                            LinkedHashMap::new\r\n                    ));\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Integer\u003e",
          "methodName": "getMostActiveFiles",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "int",
              "name": "limit"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get all commits\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().all().call();\r\n\r\n            // Count changes by file path\r\n            Map\u003cString, Integer\u003e fileChangeCounts \u003d new HashMap\u003c\u003e();\r\n\r\n            for (RevCommit commit : commits) {\r\n                if (commit.getParentCount() \u003e 0) {\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n                    for (FileChange change : changes) {\r\n                        String path \u003d change.getPath();\r\n                        if (path !\u003d null \u0026\u0026 !path.equals(\"/dev/null\")) {\r\n                            fileChangeCounts.put(path, fileChangeCounts.getOrDefault(path, 0) + 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Sort files by change count and limit results\r\n            return fileChangeCounts.entrySet().stream()\r\n                    .sorted(Map.Entry.\u003cString, Integer\u003ecomparingByValue().reversed())\r\n                    .limit(limit)\r\n                    .collect(Collectors.toMap(\r\n                            Map.Entry::getKey,\r\n                            Map.Entry::getValue,\r\n                            (e1, e2) -\u003e e1,\r\n                            LinkedHashMap::new\r\n                    ));\r\n        }\r\n    }",
          "javadoc": {
            "description": "Get the most active files in the repository (most frequently changed).\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "limit Maximum number of files to return"
              },
              {
                "name": "return",
                "value": "Map with file paths as keys and change counts as values"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": [
            "G"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getFormattedCommitLog",
          "parameters": [
            {
              "type": "String",
              "name": "repoPath"
            },
            {
              "type": "int",
              "name": "maxCount"
            }
          ],
          "body": "{\r\n        try (Git git \u003d Git.open(new File(repoPath))) {\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            Iterable\u003cRevCommit\u003e commits \u003d git.log().setMaxCount(maxCount).call();\r\n            StringBuilder log \u003d new StringBuilder();\r\n            SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n            for (RevCommit commit : commits) {\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n\r\n                log.append(\"Commit: \").append(commit.getName()).append(\"\\n\");\r\n                log.append(\"Author: \").append(author.getName())\r\n                        .append(\" \u003c\").append(author.getEmailAddress()).append(\"\u003e\\n\");\r\n                log.append(\"Date:   \").append(dateFormat.format(author.getWhen())).append(\"\\n\\n\");\r\n                log.append(\"    \").append(commit.getFullMessage().replace(\"\\n\", \"\\n    \")).append(\"\\n\\n\");\r\n\r\n                // Add file changes if not the first commit\r\n                if (commit.getParentCount() \u003e 0) {\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n\r\n                    if (!changes.isEmpty()) {\r\n                        log.append(\"    Changed files:\\n\");\r\n                        for (FileChange change : changes) {\r\n                            String prefix \u003d \"\";\r\n                            switch (change.getType()) {\r\n                                case ADD:\r\n                                    prefix \u003d \"A\";\r\n                                    break;\r\n                                case MODIFY:\r\n                                    prefix \u003d \"M\";\r\n                                    break;\r\n                                case DELETE:\r\n                                    prefix \u003d \"D\";\r\n                                    break;\r\n                                case RENAME:\r\n                                    prefix \u003d \"R\";\r\n                                    break;\r\n                                case COPY:\r\n                                    prefix \u003d \"C\";\r\n                                    break;\r\n                            }\r\n\r\n                            log.append(\"      \").append(prefix).append(\" \").append(change.getPath()).append(\"\\n\");\r\n                        }\r\n                        log.append(\"\\n\");\r\n                    }\r\n                }\r\n\r\n                log.append(\"-------------------------------------------------------------------------------\\n\\n\");\r\n            }\r\n\r\n            return log.toString();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Generate a commit log in a readable format.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "repoPath The path to the Git repository"
              },
              {
                "name": "param",
                "value": "maxCount Maximum number of commits to include"
              },
              {
                "name": "return",
                "value": "String representing the commit log"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              },
              {
                "name": "throws",
                "value": "GitAPIException If any Git API errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            Repository repository \u003d git.getRepository();\r\n\r\n            // Get current branch\r\n            String currentBranch \u003d repository.getBranch();\r\n\r\n            // Get remote URL\r\n            String remoteUrl \u003d repository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n\r\n            // Get latest commit\r\n            RevCommit latestCommit \u003d getLatestCommit(git);\r\n            CommitInfo latestCommitInfo \u003d latestCommit !\u003d null ? convertToCommitInfo(latestCommit, repository) : null;\r\n\r\n            // Get all branches\r\n            List\u003cBranchInfo\u003e branches \u003d getAllBranches(git);\r\n\r\n            // Get all tags\r\n            List\u003cTagInfo\u003e tags \u003d getAllTags(git);\r\n\r\n            // Check for uncommitted changes\r\n            boolean hasUncommittedChanges \u003d hasUncommittedChanges(git);\r\n\r\n            // Count commits in current branch\r\n            int commitCount \u003d countCommits(git);\r\n\r\n            // Get top contributors\r\n            List\u003cContributorInfo\u003e topContributors \u003d getTopContributors(git, 5);\r\n\r\n            // Get repository statistics\r\n            Map\u003cString, Object\u003e statistics \u003d getRepositoryStatistics(git);\r\n\r\n            // Get file extension counts\r\n            Map\u003cString, Integer\u003e fileExtensionCounts \u003d getFileExtensionCounts(git);\r\n\r\n            // Get repository creation and last updated dates\r\n            Date creationDate \u003d getRepositoryCreationDate(git);\r\n            Date lastUpdatedDate \u003d latestCommit !\u003d null ?\r\n                    latestCommit.getAuthorIdent().getWhen() : null;\r\n\r\n            return GitRepositoryInfo.builder()\r\n                    .name(gitDir.getName())\r\n                    .path(gitDir.getAbsolutePath())\r\n                    .currentBranch(currentBranch)\r\n                    .remoteUrl(remoteUrl)\r\n                    .latestCommit(latestCommitInfo)\r\n                    .branches(branches)\r\n                    .tags(tags)\r\n                    .hasUncommittedChanges(hasUncommittedChanges)\r\n                    .commitCount(commitCount)\r\n                    .statistics(statistics)\r\n                    .topContributors(topContributors)\r\n                    .creationDate(creationDate)\r\n                    .lastUpdatedDate(lastUpdatedDate)\r\n                    .fileExtensionCounts(fileExtensionCounts)\r\n                    .build();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StringBuilder",
          "parameters": [],
          "body": "{\r\n                RevCommit commit \u003d blameResult.getSourceCommit(i);\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n                String shortCommitId \u003d commit.getName().substring(0, 7);\r\n                String line \u003d blameResult.getResultContents().getString(i);\r\n\r\n                result.append(String.format(\"%s (%s - %s): %s\\n\",\r\n                        shortCommitId,\r\n                        author.getName(),\r\n                        new SimpleDateFormat(\"yyyy-MM-dd\").format(author.getWhen()),\r\n                        line));\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [
            {
              "type": "\"yyyy-MM-dd",
              "name": "HH:mm:ss\""
            }
          ],
          "body": "{\r\n                PersonIdent author \u003d commit.getAuthorIdent();\r\n\r\n                log.append(\"Commit: \").append(commit.getName()).append(\"\\n\");\r\n                log.append(\"Author: \").append(author.getName())\r\n                        .append(\" \u003c\").append(author.getEmailAddress()).append(\"\u003e\\n\");\r\n                log.append(\"Date:   \").append(dateFormat.format(author.getWhen())).append(\"\\n\\n\");\r\n                log.append(\"    \").append(commit.getFullMessage().replace(\"\\n\", \"\\n    \")).append(\"\\n\\n\");\r\n\r\n                // Add file changes if not the first commit\r\n                if (commit.getParentCount() \u003e 0) {\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n\r\n                    if (!changes.isEmpty()) {\r\n                        log.append(\"    Changed files:\\n\");\r\n                        for (FileChange change : changes) {\r\n                            String prefix \u003d \"\";\r\n                            switch (change.getType()) {\r\n                                case ADD:\r\n                                    prefix \u003d \"A\";\r\n                                    break;\r\n                                case MODIFY:\r\n                                    prefix \u003d \"M\";\r\n                                    break;\r\n                                case DELETE:\r\n                                    prefix \u003d \"D\";\r\n                                    break;\r\n                                case RENAME:\r\n                                    prefix \u003d \"R\";\r\n                                    break;\r\n                                case COPY:\r\n                                    prefix \u003d \"C\";\r\n                                    break;\r\n                            }\r\n\r\n                            log.append(\"      \").append(prefix).append(\" \").append(change.getPath()).append(\"\\n\");\r\n                        }\r\n                        log.append(\"\\n\");\r\n                    }\r\n                }\r\n\r\n                log.append(\"-------------------------------------------------------------------------------\\n\\n\");\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "commit",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    List\u003cFileChange\u003e changes \u003d getFileChanges(commit, repository);\r\n\r\n                    if (!changes.isEmpty()) {\r\n                        log.append(\"    Changed files:\\n\");\r\n                        for (FileChange change : changes) {\r\n                            String prefix \u003d \"\";\r\n                            switch (change.getType()) {\r\n                                case ADD:\r\n                                    prefix \u003d \"A\";\r\n                                    break;\r\n                                case MODIFY:\r\n                                    prefix \u003d \"M\";\r\n                                    break;\r\n                                case DELETE:\r\n                                    prefix \u003d \"D\";\r\n                                    break;\r\n                                case RENAME:\r\n                                    prefix \u003d \"R\";\r\n                                    break;\r\n                                case COPY:\r\n                                    prefix \u003d \"C\";\r\n                                    break;\r\n                            }\r\n\r\n                            log.append(\"      \").append(prefix).append(\" \").append(change.getPath()).append(\"\\n\");\r\n                        }\r\n                        log.append(\"\\n\");\r\n                    }\r\n                }",
          "comments": [
            "Add file changes if not the first commit"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "isValidRepository",
          "parameters": [
            {
              "type": "String",
              "name": "path"
            }
          ],
          "body": "{\r\n        File gitDir \u003d new File(path);\r\n        try {\r\n            FileRepositoryBuilder builder \u003d new FileRepositoryBuilder()\r\n                    .setGitDir(new File(gitDir, \".git\"))\r\n                    .readEnvironment()\r\n                    .findGitDir();\r\n\r\n            if (builder.getGitDir() \u003d\u003d null) {\r\n                return false;\r\n            }\r\n\r\n            try (Repository repository \u003d builder.build()) {\r\n                return repository.getObjectDatabase().exists();\r\n            }\r\n        } catch (IOException e) {\r\n            return false;\r\n        }\r\n    }",
          "javadoc": {
            "description": "Check if a path is a valid Git repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to check"
              },
              {
                "name": "return",
                "value": "true if the path is a valid Git repository, false otherwise"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            FileRepositoryBuilder builder \u003d new FileRepositoryBuilder()\r\n                    .setGitDir(new File(gitDir, \".git\"))\r\n                    .readEnvironment()\r\n                    .findGitDir();\r\n\r\n            if (builder.getGitDir() \u003d\u003d null) {\r\n                return false;\r\n            }\r\n\r\n            try (Repository repository \u003d builder.build()) {\r\n                return repository.getObjectDatabase().exists();\r\n            }\r\n        }",
          "javadoc": {
            "description": "Check if a path is a valid Git repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to check"
              },
              {
                "name": "return",
                "value": "true if the path is a valid Git repository, false otherwise"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "FileRepositoryBuilder",
          "parameters": [],
          "body": "{\r\n                return false;\r\n            }",
          "javadoc": {
            "description": "Check if a path is a valid Git repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to check"
              },
              {
                "name": "return",
                "value": "true if the path is a valid Git repository, false otherwise"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                return false;\r\n            }",
          "javadoc": {
            "description": "Check if a path is a valid Git repository.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The path to check"
              },
              {
                "name": "return",
                "value": "true if the path is a valid Git repository, false otherwise"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "listFilesRespectingGitignore",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n        Path dirPath \u003d Paths.get(directory);\r\n        File gitignoreFile \u003d new File(directory, \".gitignore\");\r\n\r\n        // List to store ignore patterns\r\n        List\u003cString\u003e ignorePatterns \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Load .gitignore patterns if the file exists\r\n        if (gitignoreFile.exists() \u0026\u0026 gitignoreFile.isFile()) {\r\n            try {\r\n                List\u003cString\u003e lines \u003d Files.readAllLines(gitignoreFile.toPath(), StandardCharsets.UTF_8);\r\n                for (String line : lines) {\r\n                    // Skip empty lines and comments\r\n                    if (line.trim().isEmpty() || line.startsWith(\"#\")) {\r\n                        continue;\r\n                    }\r\n                    ignorePatterns.add(line.trim());\r\n                }\r\n            } catch (IOException e) {\r\n                // If there\u0027s an error reading .gitignore, log it but continue without ignore rules\r\n                System.err.println(\"Error reading .gitignore file: \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        List\u003cFile\u003e result \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Walk the directory tree\r\n        try (Stream\u003cPath\u003e paths \u003d Files.walk(dirPath)) {\r\n            paths.filter(Files::isRegularFile)\r\n                 .forEach(path -\u003e {\r\n                     // Get the relative path from the base directory\r\n                     Path relativePath \u003d dirPath.relativize(path);\r\n                     String pathStr \u003d relativePath.toString().replace(\u0027\\\\\u0027, \u0027/\u0027);\r\n\r\n                     // Check if the file matches any ignore pattern\r\n                     boolean isIgnored \u003d false;\r\n                     for (String pattern : ignorePatterns) {\r\n                         if (matchesGitignorePattern(pathStr, pattern)) {\r\n                             isIgnored \u003d true;\r\n                             break;\r\n                         }\r\n                     }\r\n\r\n                     // Add the file to the result if it\u0027s not ignored\r\n                     if (!isIgnored) {\r\n                         result.add(path.toFile());\r\n                     }\r\n                 });\r\n        }\r\n\r\n        return result;\r\n    }",
          "javadoc": {
            "description": "List all files in a directory, respecting .gitignore rules if present.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to list files from"
              },
              {
                "name": "return",
                "value": "List of files, excluding those matched by .gitignore rules"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            try {\r\n                List\u003cString\u003e lines \u003d Files.readAllLines(gitignoreFile.toPath(), StandardCharsets.UTF_8);\r\n                for (String line : lines) {\r\n                    // Skip empty lines and comments\r\n                    if (line.trim().isEmpty() || line.startsWith(\"#\")) {\r\n                        continue;\r\n                    }\r\n                    ignorePatterns.add(line.trim());\r\n                }\r\n            } catch (IOException e) {\r\n                // If there\u0027s an error reading .gitignore, log it but continue without ignore rules\r\n                System.err.println(\"Error reading .gitignore file: \" + e.getMessage());\r\n            }\r\n        }",
          "javadoc": {
            "description": "List all files in a directory, respecting .gitignore rules if present.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to list files from"
              },
              {
                "name": "return",
                "value": "List of files, excluding those matched by .gitignore rules"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": [
            "List to store ignore patterns"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "exists",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n            try {\r\n                List\u003cString\u003e lines \u003d Files.readAllLines(gitignoreFile.toPath(), StandardCharsets.UTF_8);\r\n                for (String line : lines) {\r\n                    // Skip empty lines and comments\r\n                    if (line.trim().isEmpty() || line.startsWith(\"#\")) {\r\n                        continue;\r\n                    }\r\n                    ignorePatterns.add(line.trim());\r\n                }\r\n            } catch (IOException e) {\r\n                // If there\u0027s an error reading .gitignore, log it but continue without ignore rules\r\n                System.err.println(\"Error reading .gitignore file: \" + e.getMessage());\r\n            }\r\n        }",
          "comments": [
            "List to store ignore patterns",
            "Load .gitignore patterns if the file exists"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "comments",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                        continue;\r\n                    }",
          "comments": [
            "Skip empty lines and comments"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "tree",
          "methodName": "try",
          "parameters": [
            {
              "type": "Stream\u003cPath\u003e",
              "name": "paths"
            }
          ],
          "body": "{\r\n            paths.filter(Files::isRegularFile)\r\n                 .forEach(path -\u003e {\r\n                     // Get the relative path from the base directory\r\n                     Path relativePath \u003d dirPath.relativize(path);\r\n                     String pathStr \u003d relativePath.toString().replace(\u0027\\\\\u0027, \u0027/\u0027);\r\n\r\n                     // Check if the file matches any ignore pattern\r\n                     boolean isIgnored \u003d false;\r\n                     for (String pattern : ignorePatterns) {\r\n                         if (matchesGitignorePattern(pathStr, pattern)) {\r\n                             isIgnored \u003d true;\r\n                             break;\r\n                         }\r\n                     }\r\n\r\n                     // Add the file to the result if it\u0027s not ignored\r\n                     if (!isIgnored) {\r\n                         result.add(path.toFile());\r\n                     }\r\n                 });\r\n        }",
          "comments": [
            "Walk the directory tree"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "ignored",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                         result.add(path.toFile());\r\n                     }",
          "comments": [
            "Add the file to the result if it\u0027s not ignored"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "matchesGitignorePattern",
          "parameters": [
            {
              "type": "String",
              "name": "path"
            },
            {
              "type": "String",
              "name": "pattern"
            }
          ],
          "body": "{\r\n        // Handle negation (patterns starting with !)\r\n        boolean negate \u003d pattern.startsWith(\"!\");\r\n        if (negate) {\r\n            pattern \u003d pattern.substring(1);\r\n        }\r\n\r\n        // Handle directory-only patterns (ending with /)\r\n        boolean dirOnly \u003d pattern.endsWith(\"/\");\r\n        if (dirOnly) {\r\n            pattern \u003d pattern.substring(0, pattern.length() - 1);\r\n        }\r\n\r\n        // Convert gitignore glob pattern to regex\r\n        pattern \u003d pattern\r\n            .replace(\".\", \"\\\\.\")   // Escape dots\r\n            .replace(\"*\", \".*\")    // * becomes .*\r\n            .replace(\"?\", \".\");    // ? becomes .\r\n\r\n        // Match the pattern against the path\r\n        boolean matches \u003d path.matches(pattern);\r\n\r\n        // Return the result, taking negation into account\r\n        return negate ? !matches : matches;\r\n    }",
          "javadoc": {
            "description": "Check if a file path matches a gitignore pattern.\r\nThis is a simplified implementation and doesn\u0027t handle all gitignore pattern features.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The file path to check"
              },
              {
                "name": "param",
                "value": "pattern The gitignore pattern"
              },
              {
                "name": "return",
                "value": "true if the path matches the pattern, false otherwise"
              }
            ]
          },
          "comments": [
            "Handle neg"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Handle",
          "methodName": "negation",
          "parameters": [
            {
              "type": "patterns",
              "name": "starting"
            }
          ],
          "body": "{\r\n            pattern \u003d pattern.substring(1);\r\n        }",
          "javadoc": {
            "description": "Check if a file path matches a gitignore pattern.\r\nThis is a simplified implementation and doesn\u0027t handle all gitignore pattern features.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path The file path to check"
              },
              {
                "name": "param",
                "value": "pattern The gitignore pattern"
              },
              {
                "name": "return",
                "value": "true if the path matches the pattern, false otherwise"
              }
            ]
          },
          "comments": [
            "Handle negation (patterns starting with !)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "only",
          "methodName": "patterns",
          "parameters": [
            {
              "type": "ending",
              "name": "with"
            }
          ],
          "body": "{\r\n            pattern \u003d pattern.substring(0, pattern.length() - 1);\r\n        }",
          "comments": [
            "Handle directory-only patterns (ending with /)"
          ]
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/parsers/PomParser.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Maven",
          "methodName": "POM",
          "parameters": [],
          "body": "{\r\n\r\n    // Prevent instantiation\r\n    private PomParser() {\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }\r\n\r\n    /**\r\n     * Parse a POM file and extract its Maven Model.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return Model object representing the POM file\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static Model parsePom(File pomFile) throws IOException {\r\n        try (FileInputStream inputStream \u003d new FileInputStream(pomFile)) {\r\n            MavenStaxReader mavenReader \u003d new MavenStaxReader();\r\n            try {\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Error parsing POM file: \" + e.getMessage(), e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract project coordinates (groupId, artifactId, version) from a POM file.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return PomCoordinates object with the project coordinates\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static PomCoordinates extractCoordinates(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        String groupId \u003d model.getGroupId();\r\n        String artifactId \u003d model.getArtifactId();\r\n        String version \u003d model.getVersion();\r\n\r\n        // If coordinates are not directly specified, they might be inherited from parent\r\n        if (groupId \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }\r\n\r\n        if (version \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            version \u003d model.getParent().getVersion();\r\n        }\r\n\r\n        return PomCoordinates.builder()\r\n                .groupId(groupId)\r\n                .artifactId(artifactId)\r\n                .version(version)\r\n                .build();\r\n    }\r\n\r\n    /**\r\n     * Extract all dependencies from a POM file.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return List of Dependency objects\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static List\u003cDependency\u003e extractDependencies(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n        return model.getDependencies();\r\n    }\r\n\r\n    /**\r\n     * Extract parent POM information if available.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return Parent object or null if no parent exists\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static Parent extractParentInfo(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n        return model.getParent();\r\n    }\r\n\r\n    /**\r\n     * Extract build plugins from a POM file.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return List of Plugin objects or empty list if no plugins exist\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static List\u003cPlugin\u003e extractPlugins(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        if (model.getBuild() \u003d\u003d null || model.getBuild().getPlugins() \u003d\u003d null) {\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n\r\n        return model.getBuild().getPlugins();\r\n    }\r\n\r\n    /**\r\n     * Extract module names for multi-module projects.\r\n     * \r\n     * @param pomFile The POM file to parse\r\n     * @return List of module names or empty list if not a multi-module project\r\n     * @throws IOException If any I/O errors occur\r\n     */\r\n    public static List\u003cString\u003e extractModules(File pomFile) throws IOException {\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        if (model \u003d\u003d null) {\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n\r\n        return model.getSubprojects();\r\n    }\r\n\r\n    /**\r\n     * Find all POM files in a directory and its subdirectories.\r\n     * \r\n     * @param directory The directory to search\r\n     * @return List of POM files\r\n     */\r\n    public static List\u003cFile\u003e findPomFiles(File directory) {\r\n        List\u003cFile\u003e pomFiles \u003d new ArrayList\u003c\u003e();\r\n        findPomFilesRecursive(directory, pomFiles);\r\n        return pomFiles;\r\n    }\r\n\r\n    /**\r\n     * Recursive helper method to find all POM files.\r\n     * \r\n     * @param directory The directory to search\r\n     * @param pomFiles List to collect POM files\r\n     */\r\n    private static void findPomFilesRecursive(File directory, List\u003cFile\u003e pomFiles) {\r\n        File[] files \u003d directory.listFiles();\r\n        if (files !\u003d null) {\r\n            for (File file : files) {\r\n                if (file.isDirectory()) {\r\n                    findPomFilesRecursive(file, pomFiles);\r\n                } else if (file.getName().equals(\"pom.xml\")) {\r\n                    pomFiles.add(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "PomParser",
          "parameters": [],
          "body": "{\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Maven POM (pom.xml) files using the official Maven Model API.\r\nThis class provides static methods to analyze Maven project files and extract structural information.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AssertionError",
          "parameters": [
            {
              "type": "\"Utility",
              "name": "class"
            }
          ],
          "body": "{\r\n        try (FileInputStream inputStream \u003d new FileInputStream(pomFile)) {\r\n            MavenStaxReader mavenReader \u003d new MavenStaxReader();\r\n            try {\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Error parsing POM file: \" + e.getMessage(), e);\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Maven POM (pom.xml) files using the official Maven Model API.\r\nThis class provides static methods to analyze Maven project files and extract structural information.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Model",
          "methodName": "parsePom",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        try (FileInputStream inputStream \u003d new FileInputStream(pomFile)) {\r\n            MavenStaxReader mavenReader \u003d new MavenStaxReader();\r\n            try {\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Error parsing POM file: \" + e.getMessage(), e);\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Parse a POM file and extract its Maven Model.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "Model object representing the POM file"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "FileInputStream",
          "parameters": [],
          "body": "{\r\n            MavenStaxReader mavenReader \u003d new MavenStaxReader();\r\n            try {\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            } catch (Exception e) {\r\n                throw new IOException(\"Error parsing POM file: \" + e.getMessage(), e);\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse a POM file and extract its Maven Model.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "Model object representing the POM file"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "MavenStaxReader",
          "parameters": [],
          "body": "{\r\n                // Use the MavenStaxReader to read the POM file directly into a Model\r\n\r\n                // Return the model as is - no conversion needed\r\n                return mavenReader.read(inputStream);\r\n            }",
          "javadoc": {
            "description": "Parse a POM file and extract its Maven Model.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "Model object representing the POM file"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": [
            "Use the MavenStaxReader to read the P"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "IOException",
          "parameters": [
            {
              "type": "\"Error",
              "name": "parsing"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        String groupId \u003d model.getGroupId();\r\n        String artifactId \u003d model.getArtifactId();\r\n        String version \u003d model.getVersion();\r\n\r\n        // If coordinates are not directly specified, they might be inherited from parent\r\n        if (groupId \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }\r\n\r\n        if (version \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            version \u003d model.getParent().getVersion();\r\n        }\r\n\r\n        return PomCoordinates.builder()\r\n                .groupId(groupId)\r\n                .artifactId(artifactId)\r\n                .version(version)\r\n                .build();\r\n    }",
          "comments": [
            "Return the model as is - no conversion needed"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "project",
          "methodName": "coordinates",
          "parameters": [],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        String groupId \u003d model.getGroupId();\r\n        String artifactId \u003d model.getArtifactId();\r\n        String version \u003d model.getVersion();\r\n\r\n        // If coordinates are not directly specified, they might be inherited from parent\r\n        if (groupId \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }\r\n\r\n        if (version \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            version \u003d model.getParent().getVersion();\r\n        }\r\n\r\n        return PomCoordinates.builder()\r\n                .groupId(groupId)\r\n                .artifactId(artifactId)\r\n                .version(version)\r\n                .build();\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "PomCoordinates",
          "methodName": "extractCoordinates",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        String groupId \u003d model.getGroupId();\r\n        String artifactId \u003d model.getArtifactId();\r\n        String version \u003d model.getVersion();\r\n\r\n        // If coordinates are not directly specified, they might be inherited from parent\r\n        if (groupId \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }\r\n\r\n        if (version \u003d\u003d null \u0026\u0026 model.getParent() !\u003d null) {\r\n            version \u003d model.getParent().getVersion();\r\n        }\r\n\r\n        return PomCoordinates.builder()\r\n                .groupId(groupId)\r\n                .artifactId(artifactId)\r\n                .version(version)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Extract project coordinates (groupId, artifactId, version) from a POM file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "PomCoordinates object with the project coordinates"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parent",
          "methodName": "if",
          "parameters": [
            {
              "type": "groupId",
              "name": "\u003d\u003d"
            }
          ],
          "body": "{\r\n            groupId \u003d model.getParent().getGroupId();\r\n        }",
          "comments": [
            "If coordinates are not directly specified, they might be inherited from parent"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cDependency\u003e",
          "methodName": "extractDependencies",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n        return model.getDependencies();\r\n    }",
          "javadoc": {
            "description": "Extract all dependencies from a POM file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "List of Dependency objects"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Parent",
          "methodName": "extractParentInfo",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n        return model.getParent();\r\n    }",
          "javadoc": {
            "description": "Extract parent POM information if available.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "Parent object or null if no parent exists"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cPlugin\u003e",
          "methodName": "extractPlugins",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        if (model.getBuild() \u003d\u003d null || model.getBuild().getPlugins() \u003d\u003d null) {\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n\r\n        return model.getBuild().getPlugins();\r\n    }",
          "javadoc": {
            "description": "Extract build plugins from a POM file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "List of Plugin objects or empty list if no plugins exist"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cString\u003e",
          "methodName": "extractModules",
          "parameters": [
            {
              "type": "File",
              "name": "pomFile"
            }
          ],
          "body": "{\r\n        Model model \u003d parsePom(pomFile);\r\n\r\n        if (model \u003d\u003d null) {\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n\r\n        return model.getSubprojects();\r\n    }",
          "javadoc": {
            "description": "Extract module names for multi-module projects.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "pomFile The POM file to parse"
              },
              {
                "name": "return",
                "value": "List of module names or empty list if not a multi-module project"
              },
              {
                "name": "throws",
                "value": "IOException If any I/O errors occur"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "findPomFiles",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            }
          ],
          "body": "{\r\n        List\u003cFile\u003e pomFiles \u003d new ArrayList\u003c\u003e();\r\n        findPomFilesRecursive(directory, pomFiles);\r\n        return pomFiles;\r\n    }",
          "javadoc": {
            "description": "Find all POM files in a directory and its subdirectories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "return",
                "value": "List of POM files"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "findPomFilesRecursive",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "List\u003cFile\u003e",
              "name": "pomFiles"
            }
          ],
          "body": "{\r\n        File[] files \u003d directory.listFiles();\r\n        if (files !\u003d null) {\r\n            for (File file : files) {\r\n                if (file.isDirectory()) {\r\n                    findPomFilesRecursive(file, pomFiles);\r\n                } else if (file.getName().equals(\"pom.xml\")) {\r\n                    pomFiles.add(file);\r\n                }\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Recursive helper method to find all POM files.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "param",
                "value": "pomFiles List to collect POM files"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    pomFiles.add(file);\r\n                }",
          "javadoc": {
            "description": "Recursive helper method to find all POM files.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "param",
                "value": "pomFiles List to collect POM files"
              }
            ]
          },
          "comments": []
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/parsers/Parser.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "all",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Check if directory exists\r\n                File dir \u003d new File(directory);\r\n                if (!dir.exists() || !dir.isDirectory()) {\r\n                    result.put(\"error\", \"Directory does not exist or is not a directory: \" + directory);\r\n                    return result;\r\n                }\r\n\r\n                // Parse Git repository if it\u0027s a valid Git repository\r\n                if (GitParser.isValidRepository(directory)) {\r\n                    GitRepositoryInfo repoInfo \u003d GitParser.parseRepository(directory);\r\n                    result.put(\"gitRepository\", repoInfo);\r\n                }\r\n\r\n                // List all files in the directory respecting .gitignore\r\n                List\u003cFile\u003e files;\r\n                try {\r\n                    files \u003d GitParser.listFilesRespectingGitignore(directory);\r\n                } catch (IOException e) {\r\n                    // If there\u0027s an error listing files with .gitignore, fall back to listing all files\r\n                    files \u003d new ArrayList\u003c\u003e();\r\n                    listFilesRecursive(dir, files);\r\n                }\r\n\r\n                // Parse POM files\r\n                List\u003cFile\u003e pomFiles \u003d new ArrayList\u003c\u003e();\r\n                List\u003cMap\u003cString, Object\u003e\u003e pomResults \u003d new ArrayList\u003c\u003e();\r\n\r\n                for (File file : files) {\r\n                    if (file.getName().equals(\"pom.xml\")) {\r\n                        pomFiles.add(file);\r\n                    }\r\n                }\r\n\r\n                for (File pomFile : pomFiles) {\r\n                    try {\r\n                        Model model \u003d PomParser.parsePom(pomFile);\r\n                        Map\u003cString, Object\u003e pomInfo \u003d new HashMap\u003c\u003e();\r\n                        pomInfo.put(\"path\", pomFile.getAbsolutePath());\r\n                        pomInfo.put(\"groupId\", model.getGroupId());\r\n                        pomInfo.put(\"artifactId\", model.getArtifactId());\r\n                        pomInfo.put(\"version\", model.getVersion());\r\n                        pomInfo.put(\"name\", model.getName());\r\n                        pomInfo.put(\"description\", model.getDescription());\r\n\r\n                        // Add dependencies\r\n                        List\u003cMap\u003cString, String\u003e\u003e dependencies \u003d new ArrayList\u003c\u003e();\r\n                        for (org.apache.maven.api.model.Dependency dependency : model.getDependencies()) {\r\n                            Map\u003cString, String\u003e dep \u003d new HashMap\u003c\u003e();\r\n                            dep.put(\"groupId\", dependency.getGroupId());\r\n                            dep.put(\"artifactId\", dependency.getArtifactId());\r\n                            dep.put(\"version\", dependency.getVersion());\r\n                            dep.put(\"scope\", dependency.getScope());\r\n                            dependencies.add(dep);\r\n                        }\r\n                        pomInfo.put(\"dependencies\", dependencies);\r\n\r\n                        pomResults.add(pomInfo);\r\n                    } catch (Exception e) {\r\n                        // Skip this POM file if there\u0027s an error\r\n                        Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n                        errorInfo.put(\"path\", pomFile.getAbsolutePath());\r\n                        errorInfo.put(\"error\", \"Failed to parse POM file: \" + e.getMessage());\r\n                        pomResults.add(errorInfo);\r\n                    }\r\n                }\r\n\r\n                if (!pomResults.isEmpty()) {\r\n                    result.put(\"pomFiles\", pomResults);\r\n                }\r\n\r\n                // Parse Java files\r\n                List\u003cFile\u003e javaFiles \u003d new ArrayList\u003c\u003e();\r\n                List\u003cMap\u003cString, Object\u003e\u003e javaResults \u003d new ArrayList\u003c\u003e();\r\n\r\n                for (File file : files) {\r\n                    if (file.getName().endsWith(\".java\")) {\r\n                        javaFiles.add(file);\r\n                    }\r\n                }\r\n\r\n                for (File javaFile : javaFiles) {\r\n                    try {\r\n                        String content \u003d new String(java.nio.file.Files.readAllBytes(javaFile.toPath()));\r\n                        ClassStructure classStructure \u003d JavaParser.extractClassStructure(javaFile.getName(), content);\r\n\r\n                        Map\u003cString, Object\u003e javaInfo \u003d new HashMap\u003c\u003e();\r\n                        javaInfo.put(\"path\", javaFile.getAbsolutePath());\r\n                        javaInfo.put(\"packageName\", classStructure.getPackageName());\r\n                        javaInfo.put(\"className\", classStructure.getClassName());\r\n                        javaInfo.put(\"methods\", classStructure.getMethods());\r\n\r\n                        javaResults.add(javaInfo);\r\n                    } catch (Exception e) {\r\n                        // Skip this Java file if there\u0027s an error\r\n                        Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n                        errorInfo.put(\"path\", javaFile.getAbsolutePath());\r\n                        errorInfo.put(\"error\", \"Failed to parse Java file: \" + e.getMessage());\r\n                        javaResults.add(errorInfo);\r\n                    }\r\n                }\r\n\r\n                if (!javaResults.isEmpty()) {\r\n                    result.put(\"javaFiles\", javaResults);\r\n                }\r\n\r\n                // Parse HTML files\r\n                List\u003cFile\u003e htmlFiles \u003d new ArrayList\u003c\u003e();\r\n                List\u003cMap\u003cString, Object\u003e\u003e htmlResults \u003d new ArrayList\u003c\u003e();\r\n\r\n                for (File file : files) {\r\n                    String name \u003d file.getName().toLowerCase();\r\n                    if (name.endsWith(\".html\") || name.endsWith(\".htm\")) {\r\n                        htmlFiles.add(file);\r\n                    }\r\n                }\r\n\r\n                for (File htmlFile : htmlFiles) {\r\n                    try {\r\n                        Document document \u003d HtmlParser.parse(htmlFile, \"UTF-8\", \"\");\r\n\r\n                        Map\u003cString, Object\u003e htmlInfo \u003d new HashMap\u003c\u003e();\r\n                        htmlInfo.put(\"path\", htmlFile.getAbsolutePath());\r\n                        htmlInfo.put(\"title\", document.title());\r\n                        htmlInfo.put(\"headings\", HtmlParser.getHeadings(document).size());\r\n                        htmlInfo.put(\"links\", HtmlParser.getLinks(document).size());\r\n                        htmlInfo.put(\"images\", HtmlParser.getImages(document).size());\r\n                        htmlInfo.put(\"metadata\", HtmlParser.getMetadata(document));\r\n\r\n                        htmlResults.add(htmlInfo);\r\n                    } catch (Exception e) {\r\n                        // Skip this HTML file if there\u0027s an error\r\n                        Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n                        errorInfo.put(\"path\", htmlFile.getAbsolutePath());\r\n                        errorInfo.put(\"error\", \"Failed to parse HTML file: \" + e.getMessage());\r\n                        htmlResults.add(errorInfo);\r\n                    }\r\n                }\r\n\r\n                if (!htmlResults.isEmpty()) {\r\n                    result.put(\"htmlFiles\", htmlResults);\r\n                }\r\n\r\n                // Add file statistics\r\n                Map\u003cString, Object\u003e fileStats \u003d new HashMap\u003c\u003e();\r\n                fileStats.put(\"totalFiles\", files.size());\r\n                fileStats.put(\"pomFiles\", pomFiles.size());\r\n                fileStats.put(\"javaFiles\", javaFiles.size());\r\n                fileStats.put(\"htmlFiles\", htmlFiles.size());\r\n                result.put(\"fileStatistics\", fileStats);\r\n\r\n                return result;\r\n            } catch (Exception e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse directory: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse a directory and extract all available information using all parsers.\r\nThis method respects .gitignore rules when listing files.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory to parse"
              },
              {
                "name": "return",
                "value": "Map containing all parsed information"
              }
            ]
          },
          "comments": [
            "Cre"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    result.put(\"error\", \"Directory does not exist or is not a directory: \" + directory);\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Check if directory exists"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "repository",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    GitRepositoryInfo repoInfo \u003d GitParser.parseRepository(directory);\r\n                    result.put(\"gitRepository\", repoInfo);\r\n                }",
          "comments": [
            "Parse Git repository if it\u0027s a valid Git repository"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "String",
          "parameters": [],
          "body": "{\r\n                        // Skip this Java file if there\u0027s an error\r\n                        Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n                        errorInfo.put(\"path\", javaFile.getAbsolutePath());\r\n                        errorInfo.put(\"error\", \"Failed to parse Java file: \" + e.getMessage());\r\n                        javaResults.add(errorInfo);\r\n                    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "git",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Parse Git repository\r\n                File dir \u003d new File(directory);\r\n                if (dir.exists() \u0026\u0026 dir.isDirectory()) {\r\n                    if (GitParser.isValidRepository(directory)) {\r\n                        GitRepositoryInfo repoInfo \u003d GitParser.parseRepository(directory);\r\n                        result.put(\"gitRepository\", repoInfo);\r\n                    } else {\r\n                        result.put(\"error\", \"Not a valid Git repository: \" + directory);\r\n                    }\r\n                } else {\r\n                    result.put(\"error\", \"Directory does not exist: \" + directory);\r\n                }\r\n\r\n                return result;\r\n            } catch (IOException | GitAPIException e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse Git repository: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse a Git repository and return a Map containing the repository information.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory containing the Git repository"
              },
              {
                "name": "return",
                "value": "Map containing the parsed Git repository information"
              }
            ]
          },
          "comments": [
            "Cre"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    result.put(\"error\", \"Directory does not exist or is not a directory: \" + directory);\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Parse Git repository"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "java",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Find all Java files in the directory\r\n                File dir \u003d new File(directory);\r\n                if (!dir.exists() || !dir.isDirectory()) {\r\n                    result.put(\"error\", \"Directory does not exist or is not a directory: \" + directory);\r\n                    return result;\r\n                }\r\n\r\n                List\u003cFile\u003e javaFiles \u003d new ArrayList\u003c\u003e();\r\n                JavaParser.findJavaFiles(dir).forEach(javaFiles::add);\r\n\r\n                List\u003cMap\u003cString, Object\u003e\u003e javaResults \u003d new ArrayList\u003c\u003e();\r\n\r\n                for (File javaFile : javaFiles) {\r\n                    try {\r\n                        String content \u003d new String(java.nio.file.Files.readAllBytes(javaFile.toPath()));\r\n                        ClassStructure classStructure \u003d JavaParser.extractClassStructure(javaFile.getName(), content);\r\n\r\n                        Map\u003cString, Object\u003e javaInfo \u003d new HashMap\u003c\u003e();\r\n                        javaInfo.put(\"path\", javaFile.getAbsolutePath());\r\n                        javaInfo.put(\"packageName\", classStructure.getPackageName());\r\n                        javaInfo.put(\"className\", classStructure.getClassName());\r\n                        javaInfo.put(\"methods\", classStructure.getMethods());\r\n\r\n                        javaResults.add(javaInfo);\r\n                    } catch (Exception e) {\r\n                        // Skip this Java file if there\u0027s an error\r\n                        Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n                        errorInfo.put(\"path\", javaFile.getAbsolutePath());\r\n                        errorInfo.put(\"error\", \"Failed to parse Java file: \" + e.getMessage());\r\n                        javaResults.add(errorInfo);\r\n                    }\r\n                }\r\n\r\n                result.put(\"javaFiles\", javaResults);\r\n                return result;\r\n            } catch (Exception e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse Java files: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse Java files in a directory and return a Map containing the Java code structure.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory containing Java files"
              },
              {
                "name": "return",
                "value": "Map containing the parsed Java files information"
              }
            ]
          },
          "comments": [
            "Cr"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    result.put(\"error\", \"Directory does not exist or is not a directory: \" + directory);\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Find all Java files in the directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "String",
          "parameters": [],
          "body": "{\r\n                        // Skip this Java file if there\u0027s an error\r\n                        Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n                        errorInfo.put(\"path\", javaFile.getAbsolutePath());\r\n                        errorInfo.put(\"error\", \"Failed to parse Java file: \" + e.getMessage());\r\n                        javaResults.add(errorInfo);\r\n                    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "pom",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Find all POM files in the directory\r\n                File dir \u003d new File(directory);\r\n                if (!dir.exists() || !dir.isDirectory()) {\r\n                    result.put(\"error\", \"Directory does not exist or is not a directory: \" + directory);\r\n                    return result;\r\n                }\r\n\r\n                List\u003cFile\u003e pomFiles \u003d PomParser.findPomFiles(dir);\r\n                List\u003cMap\u003cString, Object\u003e\u003e pomResults \u003d new ArrayList\u003c\u003e();\r\n\r\n                for (File pomFile : pomFiles) {\r\n                    try {\r\n                        Model model \u003d PomParser.parsePom(pomFile);\r\n                        Map\u003cString, Object\u003e pomInfo \u003d new HashMap\u003c\u003e();\r\n                        pomInfo.put(\"path\", pomFile.getAbsolutePath());\r\n                        pomInfo.put(\"groupId\", model.getGroupId());\r\n                        pomInfo.put(\"artifactId\", model.getArtifactId());\r\n                        pomInfo.put(\"version\", model.getVersion());\r\n                        pomInfo.put(\"name\", model.getName());\r\n                        pomInfo.put(\"description\", model.getDescription());\r\n\r\n                        // Add dependencies\r\n                        List\u003cMap\u003cString, String\u003e\u003e dependencies \u003d new ArrayList\u003c\u003e();\r\n                        for (org.apache.maven.api.model.Dependency dependency : model.getDependencies()) {\r\n                            Map\u003cString, String\u003e dep \u003d new HashMap\u003c\u003e();\r\n                            dep.put(\"groupId\", dependency.getGroupId());\r\n                            dep.put(\"artifactId\", dependency.getArtifactId());\r\n                            dep.put(\"version\", dependency.getVersion());\r\n                            dep.put(\"scope\", dependency.getScope());\r\n                            dependencies.add(dep);\r\n                        }\r\n                        pomInfo.put(\"dependencies\", dependencies);\r\n\r\n                        pomResults.add(pomInfo);\r\n                    } catch (Exception e) {\r\n                        // Skip this POM file if there\u0027s an error\r\n                        Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n                        errorInfo.put(\"path\", pomFile.getAbsolutePath());\r\n                        errorInfo.put(\"error\", \"Failed to parse POM file: \" + e.getMessage());\r\n                        pomResults.add(errorInfo);\r\n                    }\r\n                }\r\n\r\n                result.put(\"pomFiles\", pomResults);\r\n                return result;\r\n            } catch (Exception e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse POM files: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse POM files in a directory and return a Map containing the Maven project information.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory containing POM files"
              },
              {
                "name": "return",
                "value": "Map containing the parsed POM files information"
              }
            ]
          },
          "comments": [
            "Cre"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    result.put(\"error\", \"Directory does not exist or is not a directory: \" + directory);\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Find all POM files in the directory"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, Object\u003e",
          "methodName": "html",
          "parameters": [
            {
              "type": "String",
              "name": "directory"
            }
          ],
          "body": "{\r\n            try {\r\n                // Create a map to hold all parsed information\r\n                Map\u003cString, Object\u003e result \u003d new HashMap\u003c\u003e();\r\n\r\n                // Find all HTML files in the directory\r\n                File dir \u003d new File(directory);\r\n                if (!dir.exists() || !dir.isDirectory()) {\r\n                    result.put(\"error\", \"Directory does not exist or is not a directory: \" + directory);\r\n                    return result;\r\n                }\r\n\r\n                List\u003cFile\u003e htmlFiles \u003d new ArrayList\u003c\u003e();\r\n                listFilesRecursive(dir, htmlFiles, \".html\", \".htm\");\r\n\r\n                List\u003cMap\u003cString, Object\u003e\u003e htmlResults \u003d new ArrayList\u003c\u003e();\r\n\r\n                for (File htmlFile : htmlFiles) {\r\n                    try {\r\n                        Document document \u003d HtmlParser.parse(htmlFile, \"UTF-8\", \"\");\r\n\r\n                        Map\u003cString, Object\u003e htmlInfo \u003d new HashMap\u003c\u003e();\r\n                        htmlInfo.put(\"path\", htmlFile.getAbsolutePath());\r\n                        htmlInfo.put(\"title\", document.title());\r\n                        htmlInfo.put(\"headings\", HtmlParser.getHeadings(document).size());\r\n                        htmlInfo.put(\"links\", HtmlParser.getLinks(document).size());\r\n                        htmlInfo.put(\"images\", HtmlParser.getImages(document).size());\r\n                        htmlInfo.put(\"metadata\", HtmlParser.getMetadata(document));\r\n\r\n                        htmlResults.add(htmlInfo);\r\n                    } catch (Exception e) {\r\n                        // Skip this HTML file if there\u0027s an error\r\n                        Map\u003cString, Object\u003e errorInfo \u003d new HashMap\u003c\u003e();\r\n                        errorInfo.put(\"path\", htmlFile.getAbsolutePath());\r\n                        errorInfo.put(\"error\", \"Failed to parse HTML file: \" + e.getMessage());\r\n                        htmlResults.add(errorInfo);\r\n                    }\r\n                }\r\n\r\n                result.put(\"htmlFiles\", htmlResults);\r\n                return result;\r\n            } catch (Exception e) {\r\n                Map\u003cString, Object\u003e error \u003d new HashMap\u003c\u003e();\r\n                error.put(\"error\", \"Failed to parse HTML files: \" + e.getMessage());\r\n                return error;\r\n            }\r\n        }",
          "javadoc": {
            "description": "Parse HTML files in a directory and return a Map containing the HTML structure.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The path to the directory containing HTML files"
              },
              {
                "name": "return",
                "value": "Map containing the parsed HTML files information"
              }
            ]
          },
          "comments": [
            "Cr"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                    result.put(\"error\", \"Directory does not exist or is not a directory: \" + directory);\r\n                    return result;\r\n                }",
          "comments": [
            "Create a map to hold all parsed information",
            "Find all HTML files in the directory"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "listFilesRecursive",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "List\u003cFile\u003e",
              "name": "files"
            }
          ],
          "body": "{\r\n        File[] fileList \u003d directory.listFiles();\r\n        if (fileList !\u003d null) {\r\n            for (File file : fileList) {\r\n                if (file.isDirectory()) {\r\n                    listFilesRecursive(file, files);\r\n                } else {\r\n                    files.add(file);\r\n                }\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to recursively list all files in a directory.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "param",
                "value": "files List to collect files"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "listFilesRecursive",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "List\u003cFile\u003e",
              "name": "files"
            },
            {
              "type": "String...",
              "name": "extensions"
            }
          ],
          "body": "{\r\n        File[] fileList \u003d directory.listFiles();\r\n        if (fileList !\u003d null) {\r\n            for (File file : fileList) {\r\n                if (file.isDirectory()) {\r\n                    listFilesRecursive(file, files, extensions);\r\n                } else {\r\n                    String name \u003d file.getName().toLowerCase();\r\n                    for (String extension : extensions) {\r\n                        if (name.endsWith(extension.toLowerCase())) {\r\n                            files.add(file);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to recursively list files with specific extensions in a directory.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "param",
                "value": "files List to collect files"
              },
              {
                "name": "param",
                "value": "extensions File extensions to include"
              }
            ]
          },
          "comments": []
        }
      ],
      "className": "that",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/parsers/JavaParser.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "JavaParser",
          "parameters": [],
          "body": "{\r\n        throw new AssertionError(\"Utility class should not be instantiated\");\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing Java files and extracting structural information.\r\nThis class provides static methods to analyze Java source code.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "AssertionError",
          "parameters": [
            {
              "type": "\"Utility",
              "name": "class"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Utility class for parsing Java files and extracting structural information.\r\nThis class provides static methods to analyze Java source code.",
            "tags": []
          },
          "comments": [
            "Prevent instantiation",
            "Regular expression"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cFile\u003e",
          "methodName": "findJavaFiles",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            }
          ],
          "body": "{\r\n        List\u003cFile\u003e javaFiles \u003d new ArrayList\u003c\u003e();\r\n        findJavaFilesRecursive(directory, javaFiles);\r\n        return javaFiles;\r\n    }",
          "javadoc": {
            "description": "Find all Java files in a directory and its subdirectories.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "return",
                "value": "List of Java files"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": true,
          "returnType": "void",
          "methodName": "findJavaFilesRecursive",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            },
            {
              "type": "List\u003cFile\u003e",
              "name": "javaFiles"
            }
          ],
          "body": "{\r\n        File[] files \u003d directory.listFiles();\r\n        if (files !\u003d null) {\r\n            for (File file : files) {\r\n                if (file.isDirectory()) {\r\n                    findJavaFilesRecursive(file, javaFiles);\r\n                } else if (file.getName().endsWith(\".java\")) {\r\n                    javaFiles.add(file);\r\n                }\r\n            }\r\n        }\r\n    }",
          "javadoc": {
            "description": "Recursive helper method to find all Java files.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "directory The directory to search"
              },
              {
                "name": "param",
                "value": "javaFiles List to collect Java files"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    javaFiles.add(file);\r\n                }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "extractPackageName",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n        Matcher matcher \u003d PACKAGE_PATTERN.matcher(content);\r\n        return matcher.find() ? matcher.group(1) : \"default\";\r\n    }",
          "javadoc": {
            "description": "Extract the package name from Java file content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "The package name or \"default\" if not found"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "JavadocStructure",
          "methodName": "extractClassJavadoc",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n        // Find class declaration position\r\n        Matcher classMatcher \u003d CLASS_PATTERN.matcher(content);\r\n        if (!classMatcher.find()) {\r\n            return null;\r\n        }\r\n\r\n        // Get position of class declaration\r\n        int classPosition \u003d classMatcher.start();\r\n\r\n        // Search for JavaDoc before class declaration\r\n        String contentBeforeClass \u003d content.substring(0, classPosition);\r\n        Matcher javadocMatcher \u003d JAVADOC_PATTERN.matcher(contentBeforeClass);\r\n\r\n        // Find the last JavaDoc before class declaration\r\n        JavadocStructure javadoc \u003d null;\r\n        while (javadocMatcher.find()) {\r\n            String javadocText \u003d javadocMatcher.group(1).trim();\r\n            javadoc \u003d parseJavadoc(javadocText);\r\n        }\r\n\r\n        return javadoc;\r\n    }",
          "javadoc": {
            "description": "Extract the class JavaDoc from Java file content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "JavadocStructure object or null if not found"
              }
            ]
          },
          "comments": [
            "Find class declarat"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cString\u003e",
          "methodName": "extractClassComments",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n        List\u003cString\u003e comments \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Find class declaration position\r\n        Matcher classMatcher \u003d CLASS_PATTERN.matcher(content);\r\n        if (!classMatcher.find()) {\r\n            return comments;\r\n        }\r\n\r\n        // Get position of class declaration\r\n        int classPosition \u003d classMatcher.start();\r\n\r\n        // Define a window around the class declaration (200 chars before and after)\r\n        int startPos \u003d Math.max(0, classPosition - 200);\r\n        int endPos \u003d Math.min(content.length(), classPosition + 200);\r\n        String windowContent \u003d content.substring(startPos, endPos);\r\n\r\n        // Extract single-line comments\r\n        Matcher singleLineCommentMatcher \u003d SINGLE_LINE_COMMENT_PATTERN.matcher(windowContent);\r\n        while (singleLineCommentMatcher.find()) {\r\n            comments.add(singleLineCommentMatcher.group(1).trim());\r\n        }\r\n\r\n        // Extract multi-line comments (excluding JavaDoc)\r\n        Matcher multiLineCommentMatcher \u003d MULTI_LINE_COMMENT_PATTERN.matcher(windowContent);\r\n        while (multiLineCommentMatcher.find()) {\r\n            String commentText \u003d multiLineCommentMatcher.group(1).trim();\r\n            // If it doesn\u0027t start with *, it\u0027s not a JavaDoc\r\n            if (!commentText.startsWith(\"*\")) {\r\n                comments.add(commentText);\r\n            }\r\n        }\r\n\r\n        return comments;\r\n    }",
          "javadoc": {
            "description": "Extract all non-JavaDoc comments around the class declaration.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "List of comments"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "class",
          "methodName": "declaration",
          "parameters": [
            {
              "type": "200",
              "name": "chars"
            }
          ],
          "body": "{\r\n            comments.add(singleLineCommentMatcher.group(1).trim());\r\n        }",
          "comments": [
            "Get position of class declaration",
            "Define a window around the class declaration (200 chars before and after)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "line",
          "methodName": "comments",
          "parameters": [
            {
              "type": "excluding",
              "name": "JavaDoc"
            }
          ],
          "body": "{\r\n            String commentText \u003d multiLineCommentMatcher.group(1).trim();\r\n            // If it doesn\u0027t start with *, it\u0027s not a JavaDoc\r\n            if (!commentText.startsWith(\"*\")) {\r\n                comments.add(commentText);\r\n            }\r\n        }",
          "comments": [
            "Extract multi-line comments (excluding JavaDoc)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "JavaDoc",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                comments.add(commentText);\r\n            }",
          "comments": [
            "If it doesn\u0027t start with *, it\u0027s not a JavaDoc"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "ClassStructure",
          "methodName": "extractClassStructure",
          "parameters": [
            {
              "type": "String",
              "name": "fileName"
            },
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "{\r\n        String packageName \u003d extractPackageName(content);\r\n\r\n        // Extract class name and type\r\n        String className \u003d fileName.replace(\".java\", \"\");\r\n        String classType \u003d \"class\";\r\n\r\n        Matcher classMatcher \u003d CLASS_PATTERN.matcher(content);\r\n        if (classMatcher.find()) {\r\n            className \u003d classMatcher.group(4);\r\n            classType \u003d classMatcher.group(3); // class, interface, or enum\r\n        }\r\n\r\n        // Extract methods\r\n        List\u003cMethodStructure\u003e methods \u003d extractMethods(content);\r\n\r\n        // Extract JavaDoc and comments\r\n        JavadocStructure javadoc \u003d extractClassJavadoc(content);\r\n        List\u003cString\u003e comments \u003d extractClassComments(content);\r\n\r\n        // Assuming you\u0027ve built a proper ClassStructure builder elsewhere\r\n        return ClassStructure.builder()\r\n                .fileName(fileName)\r\n                .packageName(packageName)\r\n                .className(className)\r\n                .classType(classType)\r\n                .methods(methods)\r\n                .javadoc(javadoc)\r\n                .comments(comments)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Extract the class structure from Java file content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "fileName The Java file name"
              },
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "ClassStructure object"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cMethodStructure\u003e",
          "methodName": "extractMethods",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            }
          ],
          "body": "",
          "javadoc": {
            "description": "Extract all methods from a Java file content.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "return",
                "value": "List of MethodStructure objects"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "signature",
          "methodName": "if",
          "parameters": [],
          "body": "{\")) {\r\n                    bodyStart \u003d content.indexOf(\"{\", bodyStart);\r\n                    if (bodyStart \u003e\u003d 0) {\r\n                        // Find the matching closing brace\r\n                        int bodyEnd \u003d findMatchingBrace(content, bodyStart);\r\n                        if (bodyEnd \u003e bodyStart) {\r\n                            // Extract the method body including braces\r\n                            body \u003d content.substring(bodyStart, bodyEnd + 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Assuming you\u0027ve built a proper MethodStructure builder elsewhere\r\n            MethodStructure method \u003d  MethodStructure.builder()\r\n                    .accessModifier(accessModifier !\u003d null ? accessModifier : \"\")\r\n                    .isStatic(staticModifier !\u003d null)\r\n                    .returnType(returnType)\r\n                    .methodName(methodName)\r\n                    .parameters(parseParameters(parameters))\r\n                    .body(body)\r\n                    .javadoc(javadoc)\r\n                    .comments(comments)\r\n                    .build();\r\n\r\n            methods.add(method);\r\n        }",
          "comments": [
            "Position after the method signature",
            "Search for the opening brace if not part of the signature"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "JavadocStructure",
          "methodName": "extractMethodJavadoc",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            },
            {
              "type": "int",
              "name": "methodPosition"
            }
          ],
          "body": "{\r\n        // Search for JavaDoc before method\r\n        int searchStart \u003d Math.max(0, methodPosition - 500); // Look up to 500 chars before method\r\n        String contentBefore \u003d content.substring(searchStart, methodPosition);\r\n\r\n        Matcher javadocMatcher \u003d JAVADOC_PATTERN.matcher(contentBefore);\r\n\r\n        // Find the last JavaDoc before method\r\n        JavadocStructure javadoc \u003d null;\r\n        while (javadocMatcher.find()) {\r\n            String javadocText \u003d javadocMatcher.group(1).trim();\r\n            javadoc \u003d parseJavadoc(javadocText);\r\n        }\r\n\r\n        return javadoc;\r\n    }",
          "javadoc": {
            "description": "Extract JavaDoc for a method.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "param",
                "value": "methodPosition Position of method in content"
              },
              {
                "name": "return",
                "value": "JavadocStructure object or null if not found"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cString\u003e",
          "methodName": "extractMethodComments",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            },
            {
              "type": "int",
              "name": "methodPosition"
            }
          ],
          "body": "{\r\n        List\u003cString\u003e comments \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Define a window around the method declaration\r\n        int startPos \u003d Math.max(0, methodPosition - 200);\r\n        int endPos \u003d Math.min(content.length(), methodPosition + 100);\r\n        String windowContent \u003d content.substring(startPos, endPos);\r\n\r\n        // Extract single-line comments\r\n        Matcher singleLineCommentMatcher \u003d SINGLE_LINE_COMMENT_PATTERN.matcher(windowContent);\r\n        while (singleLineCommentMatcher.find()) {\r\n            comments.add(singleLineCommentMatcher.group(1).trim());\r\n        }\r\n\r\n        // Extract multi-line comments (excluding JavaDoc)\r\n        Matcher multiLineCommentMatcher \u003d MULTI_LINE_COMMENT_PATTERN.matcher(windowContent);\r\n        while (multiLineCommentMatcher.find()) {\r\n            String commentText \u003d multiLineCommentMatcher.group(1).trim();\r\n            // If it doesn\u0027t start with *, it\u0027s not a JavaDoc\r\n            if (!commentText.startsWith(\"*\")) {\r\n                comments.add(commentText);\r\n            }\r\n        }\r\n\r\n        return comments;\r\n    }",
          "javadoc": {
            "description": "Extract non-JavaDoc comments for a method.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The Java file content"
              },
              {
                "name": "param",
                "value": "methodPosition Position of method in content"
              },
              {
                "name": "return",
                "value": "List of comments"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "line",
          "methodName": "comments",
          "parameters": [
            {
              "type": "excluding",
              "name": "JavaDoc"
            }
          ],
          "body": "{\r\n            String commentText \u003d multiLineCommentMatcher.group(1).trim();\r\n            // If it doesn\u0027t start with *, it\u0027s not a JavaDoc\r\n            if (!commentText.startsWith(\"*\")) {\r\n                comments.add(commentText);\r\n            }\r\n        }",
          "comments": [
            "Extract multi-line comments (excluding JavaDoc)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "JavaDoc",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                comments.add(commentText);\r\n            }",
          "comments": [
            "If it doesn\u0027t start with *, it\u0027s not a JavaDoc"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "JavadocStructure",
          "methodName": "parseJavadoc",
          "parameters": [
            {
              "type": "String",
              "name": "javadocText"
            }
          ],
          "body": "{\r\n        // Clean up the JavaDoc text by removing leading asterisks and extra whitespace\r\n        String cleanJavadoc \u003d javadocText.replaceAll(\"^\\\\s*\\\\*\\\\s*\", \"\")\r\n                .replaceAll(\"\\\\n\\\\s*\\\\*\\\\s*\", \"\\n\")\r\n                .trim();\r\n\r\n        // Split into main description and tags\r\n        int firstTagIndex \u003d cleanJavadoc.indexOf(\"@\");\r\n        String description \u003d \"\";\r\n\r\n        if (firstTagIndex \u003d\u003d -1) {\r\n            // No tags, whole text is description\r\n            description \u003d cleanJavadoc;\r\n        } else {\r\n            // Extract description (text before first @tag)\r\n            description \u003d cleanJavadoc.substring(0, firstTagIndex).trim();\r\n        }\r\n\r\n        // Extract tags\r\n        List\u003cJavadocTag\u003e tags \u003d new ArrayList\u003c\u003e();\r\n        if (firstTagIndex !\u003d -1) {\r\n            Matcher tagMatcher \u003d JAVADOC_TAG_PATTERN.matcher(cleanJavadoc);\r\n\r\n            while (tagMatcher.find()) {\r\n                String tagName \u003d tagMatcher.group(1);\r\n                String tagValue \u003d tagMatcher.group(2).trim();\r\n\r\n                // Assuming you\u0027ve built a proper JavadocTag builder elsewhere\r\n                JavadocTag tag \u003d  JavadocTag.builder()\r\n                        .name(tagName)\r\n                        .value(tagValue)\r\n                        .build();\r\n\r\n                tags.add(tag);\r\n            }\r\n        }\r\n\r\n        // Assuming you\u0027ve built a proper JavadocStructure builder elsewhere\r\n        return  JavadocStructure.builder()\r\n                .description(description)\r\n                .tags(tags)\r\n                .build();\r\n    }",
          "javadoc": {
            "description": "Parse a JavaDoc comment text into a structured representation.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "javadocText The JavaDoc text to parse"
              },
              {
                "name": "return",
                "value": "JavadocStructure object"
              }
            ]
          },
          "comments": [
            "Clean up the JavaDoc t"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Extract",
          "methodName": "description",
          "parameters": [
            {
              "type": "text",
              "name": "before"
            }
          ],
          "body": "{\r\n            Matcher tagMatcher \u003d JAVADOC_TAG_PATTERN.matcher(cleanJavadoc);\r\n\r\n            while (tagMatcher.find()) {\r\n                String tagName \u003d tagMatcher.group(1);\r\n                String tagValue \u003d tagMatcher.group(2).trim();\r\n\r\n                // Assuming you\u0027ve built a proper JavadocTag builder elsewhere\r\n                JavadocTag tag \u003d  JavadocTag.builder()\r\n                        .name(tagName)\r\n                        .value(tagValue)\r\n                        .build();\r\n\r\n                tags.add(tag);\r\n            }\r\n        }",
          "comments": [
            "No tags, whole text is description",
            "Extract description (text before first @tag)"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "int",
          "methodName": "findMatchingBrace",
          "parameters": [
            {
              "type": "String",
              "name": "content"
            },
            {
              "type": "int",
              "name": "openingBracePos"
            }
          ],
          "body": "{\r\n        int count \u003d 1;\r\n        for (int i \u003d openingBracePos + 1; i \u003c content.length(); i++) {\r\n            char c \u003d content.charAt(i);\r\n            if (c \u003d\u003d \u0027{\u0027) {\r\n                count++;\r\n            } else if (c \u003d\u003d \u0027}\u0027) {\r\n                count--;\r\n                if (count \u003d\u003d 0) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1; // No matching brace found\r\n    }",
          "javadoc": {
            "description": "Find the position of the matching closing brace for an opening brace.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "content The text to search in"
              },
              {
                "name": "param",
                "value": "openingBracePos Position of the opening brace"
              },
              {
                "name": "return",
                "value": "Position of the matching closing brace or -1 if not found"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [
            {
              "type": "c",
              "name": "\u003d\u003d"
            }
          ],
          "body": "{\r\n                count--;\r\n                if (count \u003d\u003d 0) {\r\n                    return i;\r\n                }\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parameter",
          "methodName": "string",
          "parameters": [
            {
              "type": "\"String",
              "name": "name\""
            }
          ],
          "body": "{\r\n            if (parameterString \u003d\u003d null || parameterString.trim().isEmpty()) {\r\n                return null;\r\n            }\r\n\r\n            String cleanParam \u003d parameterString.trim();\r\n            String[] parts \u003d cleanParam.split(\"\\\\s+\");\r\n\r\n            if (parts.length \u003e\u003d 2) {\r\n                return Parameter.builder()\r\n                        .type(parts[0])\r\n                        .name(parts[1].replace(\")\", \"\"))\r\n                        .build();\r\n            }\r\n\r\n            return null;\r\n        }",
          "comments": [
            "No matching brace found"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Parameter",
          "methodName": "parseParameter",
          "parameters": [
            {
              "type": "String",
              "name": "parameterString"
            }
          ],
          "body": "{\r\n            if (parameterString \u003d\u003d null || parameterString.trim().isEmpty()) {\r\n                return null;\r\n            }\r\n\r\n            String cleanParam \u003d parameterString.trim();\r\n            String[] parts \u003d cleanParam.split(\"\\\\s+\");\r\n\r\n            if (parts.length \u003e\u003d 2) {\r\n                return Parameter.builder()\r\n                        .type(parts[0])\r\n                        .name(parts[1].replace(\")\", \"\"))\r\n                        .build();\r\n            }\r\n\r\n            return null;\r\n        }",
          "javadoc": {
            "description": "Parse a single parameter string into a Parameter object.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "parameterString The single parameter string (e.g., \"String name\")"
              },
              {
                "name": "return",
                "value": "Parameter object or null if parsing fails"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "List\u003cParameter\u003e",
          "methodName": "parseParameters",
          "parameters": [
            {
              "type": "String",
              "name": "parameterString"
            }
          ],
          "body": "{\r\n            List\u003cParameter\u003e parameters \u003d new ArrayList\u003c\u003e();\r\n\r\n            if (parameterString \u003d\u003d null || parameterString.trim().isEmpty()) {\r\n                return parameters;\r\n            }\r\n\r\n            String[] paramArray \u003d parameterString.split(\",\");\r\n            for (String param : paramArray) {\r\n                Parameter parameter \u003d parseParameter(param);\r\n                if (parameter !\u003d null) {\r\n                    parameters.add(parameter);\r\n                }\r\n            }\r\n\r\n            return parameters;\r\n        }",
          "javadoc": {
            "description": "Parse method parameters into a list of Parameter objects.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "parameterString The parameter string from the method signature"
              },
              {
                "name": "return",
                "value": "List of Parameter objects"
              }
            ]
          },
          "comments": []
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/parsers/HtmlParser.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "private",
          "methodName": "HtmlParser",
          "parameters": [],
          "body": "{\r\n        // Utility class, prevent instantiation\r\n    }",
          "javadoc": {
            "description": "Utility class for parsing HTML documents using JSoup.",
            "tags": []
          },
          "comments": [
            "Utility class, prevent instantiation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parse",
          "parameters": [
            {
              "type": "String",
              "name": "html"
            },
            {
              "type": "String",
              "name": "baseUri"
            }
          ],
          "body": "{\r\n        return Jsoup.parse(html, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from a string.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "html    The HTML content"
              },
              {
                "name": "param",
                "value": "baseUri The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parse",
          "parameters": [
            {
              "type": "File",
              "name": "file"
            },
            {
              "type": "String",
              "name": "charset"
            },
            {
              "type": "String",
              "name": "baseUri"
            }
          ],
          "body": "{\r\n        return Jsoup.parse(file, charset, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from a file.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "file    The HTML file"
              },
              {
                "name": "param",
                "value": "charset The character set of the file"
              },
              {
                "name": "param",
                "value": "baseUri The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parse",
          "parameters": [
            {
              "type": "Path",
              "name": "path"
            },
            {
              "type": "String",
              "name": "baseUri"
            }
          ],
          "body": "{\r\n        String html \u003d Files.readString(path, StandardCharsets.UTF_8);\r\n        return parse(html, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from a Path.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path    The path to the HTML file"
              },
              {
                "name": "param",
                "value": "baseUri The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "return",
          "methodName": "parse",
          "parameters": [],
          "body": "{\r\n        return Jsoup.parse(inputStream, charset, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from a Path.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "path    The path to the HTML file"
              },
              {
                "name": "param",
                "value": "baseUri The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parse",
          "parameters": [
            {
              "type": "InputStream",
              "name": "inputStream"
            },
            {
              "type": "String",
              "name": "charset"
            },
            {
              "type": "String",
              "name": "baseUri"
            }
          ],
          "body": "{\r\n        return Jsoup.parse(inputStream, charset, baseUri);\r\n    }",
          "javadoc": {
            "description": "Parse HTML content from an InputStream.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "inputStream The input stream containing HTML content"
              },
              {
                "name": "param",
                "value": "charset     The character set of the stream"
              },
              {
                "name": "param",
                "value": "baseUri     The base URI for resolving relative links"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Document",
          "methodName": "parseUrl",
          "parameters": [
            {
              "type": "String",
              "name": "url"
            }
          ],
          "body": "{\r\n        return Jsoup.connect(url)\r\n                .userAgent(\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\")\r\n                .get();\r\n    }",
          "javadoc": {
            "description": "Connect to a URL and parse the returned HTML.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "url The URL to connect to"
              },
              {
                "name": "return",
                "value": "JSoup Document object"
              },
              {
                "name": "throws",
                "value": "IOException If an IO error occurs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "all",
          "methodName": "headings",
          "parameters": [],
          "body": "{\r\n        return document.select(\"h1, h2, h3, h4, h5, h6\");\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getHeadings",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"h1, h2, h3, h4, h5, h6\");\r\n    }",
          "javadoc": {
            "description": "Get all headings (h1-h6) from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all headings"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getLinks",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"a[href]\");\r\n    }",
          "javadoc": {
            "description": "Get all links from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all links"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getImages",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"img\");\r\n    }",
          "javadoc": {
            "description": "Get all images from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all images"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getTables",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"table\");\r\n    }",
          "javadoc": {
            "description": "Get all tables from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all tables"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getForms",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"form\");\r\n    }",
          "javadoc": {
            "description": "Get all forms from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all forms"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "list",
          "methodName": "elements",
          "parameters": [],
          "body": "{\r\n        return document.select(\"ul, ol\");\r\n    }",
          "javadoc": {
            "description": "Get all forms from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all forms"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getLists",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.select(\"ul, ol\");\r\n    }",
          "javadoc": {
            "description": "Get all list elements (ul, ol) from a document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Elements containing all lists"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "getElementsByClass",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "className"
            }
          ],
          "body": "{\r\n        return document.getElementsByClass(className);\r\n    }",
          "javadoc": {
            "description": "Get all elements with the specified class name.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document  The JSoup Document"
              },
              {
                "name": "param",
                "value": "className The class name to search for"
              },
              {
                "name": "return",
                "value": "Elements containing all matching elements"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Element",
          "methodName": "getElementById",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "id"
            }
          ],
          "body": "{\r\n        return document.getElementById(id);\r\n    }",
          "javadoc": {
            "description": "Get the element with the specified ID.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "param",
                "value": "id       The ID to search for"
              },
              {
                "name": "return",
                "value": "The element with the specified ID, or null if not found"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Elements",
          "methodName": "select",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "cssSelector"
            }
          ],
          "body": "{\r\n        return document.select(cssSelector);\r\n    }",
          "javadoc": {
            "description": "Get all elements matching the specified CSS selector.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document    The JSoup Document"
              },
              {
                "name": "param",
                "value": "cssSelector The CSS selector to match"
              },
              {
                "name": "return",
                "value": "Elements containing all matching elements"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "Map\u003cString, String\u003e",
          "methodName": "getMetadata",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        Map\u003cString, String\u003e metadata \u003d new HashMap\u003c\u003e();\r\n\r\n        // Title\r\n        metadata.put(\"title\", document.title());\r\n\r\n        // Meta tags\r\n        Elements metaTags \u003d document.select(\"meta\");\r\n        for (Element metaTag : metaTags) {\r\n            if (metaTag.hasAttr(\"name\") \u0026\u0026 metaTag.hasAttr(\"content\")) {\r\n                metadata.put(metaTag.attr(\"name\"), metaTag.attr(\"content\"));\r\n            } else if (metaTag.hasAttr(\"property\") \u0026\u0026 metaTag.hasAttr(\"content\")) {\r\n                metadata.put(metaTag.attr(\"property\"), metaTag.attr(\"content\"));\r\n            }\r\n        }\r\n\r\n        return metadata;\r\n    }",
          "javadoc": {
            "description": "Extract all metadata from the document head.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Map of metadata key-value pairs"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                metadata.put(metaTag.attr(\"property\"), metaTag.attr(\"content\"));\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getTextContent",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            }
          ],
          "body": "{\r\n        return document.text();\r\n    }",
          "javadoc": {
            "description": "Extract text content from a document, removing all HTML tags.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "return",
                "value": "Plain text content"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    data[i][j] \u003d element.html();\r\n                }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    data[i][j] \u003d element.outerHtml();\r\n                }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "boolean",
          "methodName": "exists",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "selector"
            }
          ],
          "body": "{\r\n        return !document.select(selector).isEmpty();\r\n    }",
          "javadoc": {
            "description": "Check if elements matching a selector exist in the document.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "param",
                "value": "selector CSS selector to check"
              },
              {
                "name": "return",
                "value": "true if at least one matching element exists"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getText",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "selector"
            }
          ],
          "body": "{\r\n        Element element \u003d document.select(selector).first();\r\n        return element !\u003d null ? element.text() : \"\";\r\n    }",
          "javadoc": {
            "description": "Get text content of an element, or empty string if the selector doesn\u0027t match any elements.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document The JSoup Document"
              },
              {
                "name": "param",
                "value": "selector CSS selector to find element"
              },
              {
                "name": "return",
                "value": "Text content of the first matching element, or empty string if none match"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "String",
          "methodName": "getAttr",
          "parameters": [
            {
              "type": "Document",
              "name": "document"
            },
            {
              "type": "String",
              "name": "selector"
            },
            {
              "type": "String",
              "name": "attribute"
            }
          ],
          "body": "{\r\n        Element element \u003d document.select(selector).first();\r\n        return element !\u003d null ? element.attr(attribute) : \"\";\r\n    }",
          "javadoc": {
            "description": "Get attribute value of an element, or empty string if the selector doesn\u0027t match any elements.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "document  The JSoup Document"
              },
              {
                "name": "param",
                "value": "selector  CSS selector to find element"
              },
              {
                "name": "param",
                "value": "attribute Attribute name to get"
              },
              {
                "name": "return",
                "value": "Attribute value of the first matching element, or empty string if none match"
              }
            ]
          },
          "comments": []
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/main/java/io/joshuasalcedo/KeyMappingDisplay.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "public",
          "methodName": "KeyMappingDisplay",
          "parameters": [],
          "body": "{\r\n        setTitle(\"IntelliJ Key Mappings\");\r\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n        setAlwaysOnTop(true);\r\n        setSize(450, 350);\r\n        \r\n        // Load initial data\r\n        initializeShortcuts();\r\n        \r\n        // Create the main panel with a border\r\n        mainPanel \u003d new JPanel(new BorderLayout());\r\n        mainPanel.setBorder(new EmptyBorder(10, 10, 10, 10));\r\n        \r\n        // Add control panel at the top\r\n        JPanel controlPanel \u003d new JPanel(new FlowLayout(FlowLayout.LEFT));\r\n        \r\n        // Create category selector\r\n        categoryComboBox \u003d new JComboBox\u003c\u003e(categoryShortcuts.keySet().toArray(new String[0]));\r\n        categoryComboBox.addActionListener(e -\u003e refreshTable());\r\n        controlPanel.add(new JLabel(\"Category:\"));\r\n        controlPanel.add(categoryComboBox);\r\n        \r\n        // Create edit mode toggle\r\n        editModeCheckBox \u003d new JCheckBox(\"Edit Mode\");\r\n        editModeCheckBox.addActionListener(e -\u003e refreshTable());\r\n        controlPanel.add(editModeCheckBox);\r\n        \r\n        // Add save button\r\n        JButton saveButton \u003d new JButton(\"Save\");\r\n        saveButton.addActionListener(e -\u003e saveShortcuts());\r\n        controlPanel.add(saveButton);\r\n        \r\n        mainPanel.add(controlPanel, BorderLayout.NORTH);\r\n        \r\n        // Create table for shortcuts\r\n        String[] columnNames \u003d {\"Shortcut\", \"Action\"};\r\n        tableModel \u003d new DefaultTableModel(columnNames, 0) {\r\n            @Override\r\n            public boolean isCellEditable(int row, int column) {\r\n                return editModeCheckBox.isSelected();\r\n            }\r\n        };\r\n        \r\n        shortcutsTable \u003d new JTable(tableModel);\r\n        shortcutsTable.setRowHeight(25);\r\n        shortcutsTable.getTableHeader().setReorderingAllowed(false);\r\n        \r\n        // Set column widths\r\n        shortcutsTable.getColumnModel().getColumn(0).setPreferredWidth(120);\r\n        shortcutsTable.getColumnModel().getColumn(1).setPreferredWidth(280);\r\n        \r\n        JScrollPane scrollPane \u003d new JScrollPane(shortcutsTable);\r\n        mainPanel.add(scrollPane, BorderLayout.CENTER);\r\n        \r\n        // Add a panel for the button at the bottom\r\n        JPanel bottomPanel \u003d new JPanel(new FlowLayout(FlowLayout.LEFT));\r\n        \r\n        JLabel opacityLabel \u003d new JLabel(\"Opacity:\");\r\n        bottomPanel.add(opacityLabel);\r\n        \r\n        // Add opacity slider\r\n        JSlider opacitySlider \u003d new JSlider(JSlider.HORIZONTAL, 10, 100, (int)(TRANSPARENCY * 100));\r\n        opacitySlider.addChangeListener(e -\u003e {\r\n            float opacity \u003d opacitySlider.getValue() / 100.0f;\r\n            setOpacity(opacity);\r\n        });\r\n        bottomPanel.add(opacitySlider);\r\n        \r\n        // Add control to add new entry\r\n        JButton addButton \u003d new JButton(\"Add Entry\");\r\n        addButton.addActionListener(e -\u003e addNewEntry());\r\n        bottomPanel.add(addButton);\r\n        \r\n        // Add to main panel\r\n        mainPanel.add(bottomPanel, BorderLayout.SOUTH);\r\n        \r\n        setContentPane(mainPanel);\r\n        \r\n        // Make window draggable\r\n        DragWindowListener dragListener \u003d new DragWindowListener();\r\n        addMouseListener(dragListener);\r\n        addMouseMotionListener(dragListener);\r\n        \r\n        // Refresh table with initial data\r\n        refreshTable();\r\n        \r\n        // Set transparency of the window\r\n        setOpacity(TRANSPARENCY);\r\n        \r\n        // Center on screen\r\n        setLocationRelativeTo(null);\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "data",
          "methodName": "initializeShortcuts",
          "parameters": [],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Load initial data",
            "Create the main panel with a border"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JPanel",
          "parameters": [
            {
              "type": "new",
              "name": "BorderLayout("
            }
          ],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Load initial data",
            "Create the main panel with a border"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "EmptyBorder",
          "parameters": [],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Load initial data",
            "Create the main panel with a border",
            "Add control panel at the top"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JPanel",
          "parameters": [
            {
              "type": "new",
              "name": "FlowLayout(FlowLayout.LEFT"
            }
          ],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Add control panel at the top",
            "Create category selector"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JLabel",
          "parameters": [],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Create"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JCheckBox",
          "parameters": [
            {
              "type": "\"Edit",
              "name": "Mode\""
            }
          ],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Create edit mode toggle"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JButton",
          "parameters": [],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Add save button"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "DefaultTableModel",
          "parameters": [],
          "body": "{\r\n            @Override\r\n            public boolean isCellEditable(int row, int column) {\r\n                return editModeCheckBox.isSelected();\r\n            }\r\n        }",
          "comments": [
            "Create table for shortcuts"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "boolean",
          "methodName": "isCellEditable",
          "parameters": [
            {
              "type": "int",
              "name": "row"
            },
            {
              "type": "int",
              "name": "column"
            }
          ],
          "body": "{\r\n                return editModeCheckBox.isSelected();\r\n            }",
          "comments": [
            "Create table for shortcuts"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JTable",
          "parameters": [],
          "body": "{\r\n            float opacity \u003d opacitySlider.getValue() / 100.0f;\r\n            setOpacity(opacity);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JScrollPane",
          "parameters": [],
          "body": "{\r\n            float opacity \u003d opacitySlider.getValue() / 100.0f;\r\n            setOpacity(opacity);\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JPanel",
          "parameters": [
            {
              "type": "new",
              "name": "FlowLayout(FlowLayout.LEFT"
            }
          ],
          "body": "{\"Shortcut\", \"Action\"}",
          "comments": [
            "Add a panel for the button at the bottom"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JLabel",
          "parameters": [],
          "body": "{\r\n            float opacity \u003d opacitySlider.getValue() / 100.0f;\r\n            setOpacity(opacity);\r\n        }",
          "comments": [
            "Add a panel for the button at the bottom",
            "Add opacity s"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JSlider",
          "parameters": [],
          "body": "{\r\n            float opacity \u003d opacitySlider.getValue() / 100.0f;\r\n            setOpacity(opacity);\r\n        }",
          "comments": [
            "Add opacity slider"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "JButton",
          "parameters": [
            {
              "type": "\"Add",
              "name": "Entry\""
            }
          ],
          "body": "{\r\n        try {\r\n            File configFile \u003d new File(CONFIG_FILE);\r\n            if (configFile.exists()) {\r\n                loadFromFile();\r\n                return;\r\n            }\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error loading config: \" + e.getMessage());\r\n        }\r\n        \r\n        // Default shortcuts if file doesn\u0027t exist\r\n        List\u003cShortcutEntry\u003e navigationShortcuts \u003d new ArrayList\u003c\u003e();\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 1\", \"Toggle Project view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 2\", \"Toggle Bookmarks\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 3\", \"Toggle Structure view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 4\", \"Toggle Run/Debug tool window\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 5\", \"Toggle Terminal\"));\r\n        categoryShortcuts.put(\"Navigation\", navigationShortcuts);\r\n        \r\n        List\u003cShortcutEntry\u003e codeOperations \u003d new ArrayList\u003c\u003e();\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 7\", \"Generate Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 8\", \"Reformat Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 9\", \"Optimize Imports\"));\r\n        categoryShortcuts.put(\"Code Operations\", codeOperations);\r\n        \r\n        List\u003cShortcutEntry\u003e refactoring \u003d new ArrayList\u003c\u003e();\r\n        refactoring.add(new ShortcutEntry(\"ALT + 4\", \"Rename\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 5\", \"Extract Method\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 6\", \"Extract Variable/Constant\"));\r\n        categoryShortcuts.put(\"Refactoring\", refactoring);\r\n        \r\n        List\u003cShortcutEntry\u003e runDebug \u003d new ArrayList\u003c\u003e();\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad 0\", \"Run current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad .\", \"Debug current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad Enter\", \"Run with Coverage\"));\r\n        categoryShortcuts.put(\"Run \u0026 Debug\", runDebug);\r\n        \r\n        List\u003cShortcutEntry\u003e versionControl \u003d new ArrayList\u003c\u003e();\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad +\", \"Show diff\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad -\", \"Show history\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad *\", \"Commit changes\"));\r\n        categoryShortcuts.put(\"Version Control\", versionControl);\r\n        \r\n        List\u003cShortcutEntry\u003e codeAnalysis \u003d new ArrayList\u003c\u003e();\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad /\", \"Find Usages\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 1\", \"Go to Implementation\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 3\", \"Show quick documentation\"));\r\n        categoryShortcuts.put(\"Code Analysis\", codeAnalysis);\r\n    }",
          "comments": [
            "Add control to add new entry"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "DragWindowListener",
          "parameters": [],
          "body": "{\r\n        try {\r\n            File configFile \u003d new File(CONFIG_FILE);\r\n            if (configFile.exists()) {\r\n                loadFromFile();\r\n                return;\r\n            }\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error loading config: \" + e.getMessage());\r\n        }\r\n        \r\n        // Default shortcuts if file doesn\u0027t exist\r\n        List\u003cShortcutEntry\u003e navigationShortcuts \u003d new ArrayList\u003c\u003e();\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 1\", \"Toggle Project view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 2\", \"Toggle Bookmarks\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 3\", \"Toggle Structure view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 4\", \"Toggle Run/Debug tool window\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 5\", \"Toggle Terminal\"));\r\n        categoryShortcuts.put(\"Navigation\", navigationShortcuts);\r\n        \r\n        List\u003cShortcutEntry\u003e codeOperations \u003d new ArrayList\u003c\u003e();\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 7\", \"Generate Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 8\", \"Reformat Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 9\", \"Optimize Imports\"));\r\n        categoryShortcuts.put(\"Code Operations\", codeOperations);\r\n        \r\n        List\u003cShortcutEntry\u003e refactoring \u003d new ArrayList\u003c\u003e();\r\n        refactoring.add(new ShortcutEntry(\"ALT + 4\", \"Rename\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 5\", \"Extract Method\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 6\", \"Extract Variable/Constant\"));\r\n        categoryShortcuts.put(\"Refactoring\", refactoring);\r\n        \r\n        List\u003cShortcutEntry\u003e runDebug \u003d new ArrayList\u003c\u003e();\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad 0\", \"Run current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad .\", \"Debug current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad Enter\", \"Run with Coverage\"));\r\n        categoryShortcuts.put(\"Run \u0026 Debug\", runDebug);\r\n        \r\n        List\u003cShortcutEntry\u003e versionControl \u003d new ArrayList\u003c\u003e();\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad +\", \"Show diff\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad -\", \"Show history\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad *\", \"Commit changes\"));\r\n        categoryShortcuts.put(\"Version Control\", versionControl);\r\n        \r\n        List\u003cShortcutEntry\u003e codeAnalysis \u003d new ArrayList\u003c\u003e();\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad /\", \"Find Usages\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 1\", \"Go to Implementation\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 3\", \"Show quick documentation\"));\r\n        categoryShortcuts.put(\"Code Analysis\", codeAnalysis);\r\n    }",
          "comments": [
            "Make window draggable"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "data",
          "methodName": "refreshTable",
          "parameters": [],
          "body": "{\r\n        try {\r\n            File configFile \u003d new File(CONFIG_FILE);\r\n            if (configFile.exists()) {\r\n                loadFromFile();\r\n                return;\r\n            }\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error loading config: \" + e.getMessage());\r\n        }\r\n        \r\n        // Default shortcuts if file doesn\u0027t exist\r\n        List\u003cShortcutEntry\u003e navigationShortcuts \u003d new ArrayList\u003c\u003e();\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 1\", \"Toggle Project view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 2\", \"Toggle Bookmarks\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 3\", \"Toggle Structure view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 4\", \"Toggle Run/Debug tool window\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 5\", \"Toggle Terminal\"));\r\n        categoryShortcuts.put(\"Navigation\", navigationShortcuts);\r\n        \r\n        List\u003cShortcutEntry\u003e codeOperations \u003d new ArrayList\u003c\u003e();\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 7\", \"Generate Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 8\", \"Reformat Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 9\", \"Optimize Imports\"));\r\n        categoryShortcuts.put(\"Code Operations\", codeOperations);\r\n        \r\n        List\u003cShortcutEntry\u003e refactoring \u003d new ArrayList\u003c\u003e();\r\n        refactoring.add(new ShortcutEntry(\"ALT + 4\", \"Rename\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 5\", \"Extract Method\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 6\", \"Extract Variable/Constant\"));\r\n        categoryShortcuts.put(\"Refactoring\", refactoring);\r\n        \r\n        List\u003cShortcutEntry\u003e runDebug \u003d new ArrayList\u003c\u003e();\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad 0\", \"Run current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad .\", \"Debug current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad Enter\", \"Run with Coverage\"));\r\n        categoryShortcuts.put(\"Run \u0026 Debug\", runDebug);\r\n        \r\n        List\u003cShortcutEntry\u003e versionControl \u003d new ArrayList\u003c\u003e();\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad +\", \"Show diff\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad -\", \"Show history\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad *\", \"Commit changes\"));\r\n        categoryShortcuts.put(\"Version Control\", versionControl);\r\n        \r\n        List\u003cShortcutEntry\u003e codeAnalysis \u003d new ArrayList\u003c\u003e();\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad /\", \"Find Usages\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 1\", \"Go to Implementation\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 3\", \"Show quick documentation\"));\r\n        categoryShortcuts.put(\"Code Analysis\", codeAnalysis);\r\n    }",
          "comments": [
            "Refresh table with initial data",
            "Set transparency of the window"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "window",
          "methodName": "setOpacity",
          "parameters": [],
          "body": "{\r\n        try {\r\n            File configFile \u003d new File(CONFIG_FILE);\r\n            if (configFile.exists()) {\r\n                loadFromFile();\r\n                return;\r\n            }\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error loading config: \" + e.getMessage());\r\n        }\r\n        \r\n        // Default shortcuts if file doesn\u0027t exist\r\n        List\u003cShortcutEntry\u003e navigationShortcuts \u003d new ArrayList\u003c\u003e();\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 1\", \"Toggle Project view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 2\", \"Toggle Bookmarks\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 3\", \"Toggle Structure view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 4\", \"Toggle Run/Debug tool window\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 5\", \"Toggle Terminal\"));\r\n        categoryShortcuts.put(\"Navigation\", navigationShortcuts);\r\n        \r\n        List\u003cShortcutEntry\u003e codeOperations \u003d new ArrayList\u003c\u003e();\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 7\", \"Generate Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 8\", \"Reformat Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 9\", \"Optimize Imports\"));\r\n        categoryShortcuts.put(\"Code Operations\", codeOperations);\r\n        \r\n        List\u003cShortcutEntry\u003e refactoring \u003d new ArrayList\u003c\u003e();\r\n        refactoring.add(new ShortcutEntry(\"ALT + 4\", \"Rename\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 5\", \"Extract Method\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 6\", \"Extract Variable/Constant\"));\r\n        categoryShortcuts.put(\"Refactoring\", refactoring);\r\n        \r\n        List\u003cShortcutEntry\u003e runDebug \u003d new ArrayList\u003c\u003e();\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad 0\", \"Run current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad .\", \"Debug current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad Enter\", \"Run with Coverage\"));\r\n        categoryShortcuts.put(\"Run \u0026 Debug\", runDebug);\r\n        \r\n        List\u003cShortcutEntry\u003e versionControl \u003d new ArrayList\u003c\u003e();\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad +\", \"Show diff\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad -\", \"Show history\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad *\", \"Commit changes\"));\r\n        categoryShortcuts.put(\"Version Control\", versionControl);\r\n        \r\n        List\u003cShortcutEntry\u003e codeAnalysis \u003d new ArrayList\u003c\u003e();\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad /\", \"Find Usages\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 1\", \"Go to Implementation\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 3\", \"Show quick documentation\"));\r\n        categoryShortcuts.put(\"Code Analysis\", codeAnalysis);\r\n    }",
          "comments": [
            "Refresh table with initial data",
            "Set transparency of the window",
            "Center on screen"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "screen",
          "methodName": "setLocationRelativeTo",
          "parameters": [],
          "body": "{\r\n        try {\r\n            File configFile \u003d new File(CONFIG_FILE);\r\n            if (configFile.exists()) {\r\n                loadFromFile();\r\n                return;\r\n            }\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error loading config: \" + e.getMessage());\r\n        }\r\n        \r\n        // Default shortcuts if file doesn\u0027t exist\r\n        List\u003cShortcutEntry\u003e navigationShortcuts \u003d new ArrayList\u003c\u003e();\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 1\", \"Toggle Project view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 2\", \"Toggle Bookmarks\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 3\", \"Toggle Structure view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 4\", \"Toggle Run/Debug tool window\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 5\", \"Toggle Terminal\"));\r\n        categoryShortcuts.put(\"Navigation\", navigationShortcuts);\r\n        \r\n        List\u003cShortcutEntry\u003e codeOperations \u003d new ArrayList\u003c\u003e();\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 7\", \"Generate Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 8\", \"Reformat Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 9\", \"Optimize Imports\"));\r\n        categoryShortcuts.put(\"Code Operations\", codeOperations);\r\n        \r\n        List\u003cShortcutEntry\u003e refactoring \u003d new ArrayList\u003c\u003e();\r\n        refactoring.add(new ShortcutEntry(\"ALT + 4\", \"Rename\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 5\", \"Extract Method\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 6\", \"Extract Variable/Constant\"));\r\n        categoryShortcuts.put(\"Refactoring\", refactoring);\r\n        \r\n        List\u003cShortcutEntry\u003e runDebug \u003d new ArrayList\u003c\u003e();\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad 0\", \"Run current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad .\", \"Debug current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad Enter\", \"Run with Coverage\"));\r\n        categoryShortcuts.put(\"Run \u0026 Debug\", runDebug);\r\n        \r\n        List\u003cShortcutEntry\u003e versionControl \u003d new ArrayList\u003c\u003e();\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad +\", \"Show diff\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad -\", \"Show history\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad *\", \"Commit changes\"));\r\n        categoryShortcuts.put(\"Version Control\", versionControl);\r\n        \r\n        List\u003cShortcutEntry\u003e codeAnalysis \u003d new ArrayList\u003c\u003e();\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad /\", \"Find Usages\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 1\", \"Go to Implementation\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 3\", \"Show quick documentation\"));\r\n        categoryShortcuts.put(\"Code Analysis\", codeAnalysis);\r\n    }",
          "comments": [
            "Refresh table with initial data",
            "Set transparency of the window",
            "Center on screen"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "initializeShortcuts",
          "parameters": [],
          "body": "{\r\n        try {\r\n            File configFile \u003d new File(CONFIG_FILE);\r\n            if (configFile.exists()) {\r\n                loadFromFile();\r\n                return;\r\n            }\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error loading config: \" + e.getMessage());\r\n        }\r\n        \r\n        // Default shortcuts if file doesn\u0027t exist\r\n        List\u003cShortcutEntry\u003e navigationShortcuts \u003d new ArrayList\u003c\u003e();\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 1\", \"Toggle Project view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 2\", \"Toggle Bookmarks\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 3\", \"Toggle Structure view\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 4\", \"Toggle Run/Debug tool window\"));\r\n        navigationShortcuts.add(new ShortcutEntry(\"ALT + 5\", \"Toggle Terminal\"));\r\n        categoryShortcuts.put(\"Navigation\", navigationShortcuts);\r\n        \r\n        List\u003cShortcutEntry\u003e codeOperations \u003d new ArrayList\u003c\u003e();\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 7\", \"Generate Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 8\", \"Reformat Code\"));\r\n        codeOperations.add(new ShortcutEntry(\"ALT + 9\", \"Optimize Imports\"));\r\n        categoryShortcuts.put(\"Code Operations\", codeOperations);\r\n        \r\n        List\u003cShortcutEntry\u003e refactoring \u003d new ArrayList\u003c\u003e();\r\n        refactoring.add(new ShortcutEntry(\"ALT + 4\", \"Rename\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 5\", \"Extract Method\"));\r\n        refactoring.add(new ShortcutEntry(\"ALT + 6\", \"Extract Variable/Constant\"));\r\n        categoryShortcuts.put(\"Refactoring\", refactoring);\r\n        \r\n        List\u003cShortcutEntry\u003e runDebug \u003d new ArrayList\u003c\u003e();\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad 0\", \"Run current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad .\", \"Debug current configuration\"));\r\n        runDebug.add(new ShortcutEntry(\"ALT + Numpad Enter\", \"Run with Coverage\"));\r\n        categoryShortcuts.put(\"Run \u0026 Debug\", runDebug);\r\n        \r\n        List\u003cShortcutEntry\u003e versionControl \u003d new ArrayList\u003c\u003e();\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad +\", \"Show diff\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad -\", \"Show history\"));\r\n        versionControl.add(new ShortcutEntry(\"ALT + Numpad *\", \"Commit changes\"));\r\n        categoryShortcuts.put(\"Version Control\", versionControl);\r\n        \r\n        List\u003cShortcutEntry\u003e codeAnalysis \u003d new ArrayList\u003c\u003e();\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad /\", \"Find Usages\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 1\", \"Go to Implementation\"));\r\n        codeAnalysis.add(new ShortcutEntry(\"ALT + Numpad 3\", \"Show quick documentation\"));\r\n        categoryShortcuts.put(\"Code Analysis\", codeAnalysis);\r\n    }",
          "comments": [
            "Set transparency of the window",
            "Center on screen"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                loadFromFile();\r\n                return;\r\n            }",
          "comments": [
            "Center on screen"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Toggle",
              "name": "Project"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": [
            "Default shortcuts if file doesn\u0027t exist"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Toggle",
              "name": "Bookmarks\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Toggle",
              "name": "Structure"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Toggle",
              "name": "Run/Debug"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Toggle",
              "name": "Terminal\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Generate",
              "name": "Code\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Reformat",
              "name": "Code\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Optimize",
              "name": "Imports\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Extract",
              "name": "Method\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Extract",
              "name": "Variable/Constant\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Run",
              "name": "current"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Debug",
              "name": "current"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Run",
              "name": "with"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Show",
              "name": "diff\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Show",
              "name": "history\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Commit",
              "name": "changes\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Find",
              "name": "Usages\""
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Go",
              "name": "to"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"ALT",
              "name": "+"
            },
            {
              "type": "\"Show",
              "name": "quick"
            }
          ],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "refreshTable",
          "parameters": [],
          "body": "{\r\n        tableModel.setRowCount(0);\r\n        \r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        for (ShortcutEntry entry : entries) {\r\n            tableModel.addRow(new String[]{entry.shortcut, entry.action});\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "addNewEntry",
          "parameters": [],
          "body": "{\r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(selectedCategory);\r\n        entries.add(new ShortcutEntry(\"New Shortcut\", \"New Action\"));\r\n        refreshTable();\r\n        \r\n        // Set focus on the new row for editing\r\n        int lastRow \u003d tableModel.getRowCount() - 1;\r\n        shortcutsTable.editCellAt(lastRow, 0);\r\n        shortcutsTable.getEditorComponent().requestFocus();\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [
            {
              "type": "\"New",
              "name": "Shortcut\""
            },
            {
              "type": "\"New",
              "name": "Action\""
            }
          ],
          "body": "{\r\n        // First update the current category from the table\r\n        updateCurrentCategoryFromTable();\r\n        \r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(CONFIG_FILE))) {\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                writer.println(\"[\" + category + \"]\");\r\n                \r\n                List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(category);\r\n                for (ShortcutEntry entry : entries) {\r\n                    writer.println(entry.shortcut + \"\u003d\" + entry.action);\r\n                }\r\n                \r\n                writer.println(); // Empty line between categories\r\n            }\r\n            JOptionPane.showMessageDialog(this, \"Settings saved successfully!\", \r\n                    \"Save Complete\", JOptionPane.INFORMATION_MESSAGE);\r\n        } catch (IOException e) {\r\n            JOptionPane.showMessageDialog(this, \"Error saving settings: \" + e.getMessage(), \r\n                    \"Save Error\", JOptionPane.ERROR_MESSAGE);\r\n        }\r\n    }",
          "comments": [
            "Set"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "saveShortcuts",
          "parameters": [],
          "body": "{\r\n        // First update the current category from the table\r\n        updateCurrentCategoryFromTable();\r\n        \r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(CONFIG_FILE))) {\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                writer.println(\"[\" + category + \"]\");\r\n                \r\n                List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(category);\r\n                for (ShortcutEntry entry : entries) {\r\n                    writer.println(entry.shortcut + \"\u003d\" + entry.action);\r\n                }\r\n                \r\n                writer.println(); // Empty line between categories\r\n            }\r\n            JOptionPane.showMessageDialog(this, \"Settings saved successfully!\", \r\n                    \"Save Complete\", JOptionPane.INFORMATION_MESSAGE);\r\n        } catch (IOException e) {\r\n            JOptionPane.showMessageDialog(this, \"Error saving settings: \" + e.getMessage(), \r\n                    \"Save Error\", JOptionPane.ERROR_MESSAGE);\r\n        }\r\n    }",
          "comments": [
            "First update the current category from the table"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "table",
          "methodName": "updateCurrentCategoryFromTable",
          "parameters": [],
          "body": "{\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                writer.println(\"[\" + category + \"]\");\r\n                \r\n                List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(category);\r\n                for (ShortcutEntry entry : entries) {\r\n                    writer.println(entry.shortcut + \"\u003d\" + entry.action);\r\n                }\r\n                \r\n                writer.println(); // Empty line between categories\r\n            }\r\n            JOptionPane.showMessageDialog(this, \"Settings saved successfully!\", \r\n                    \"Save Complete\", JOptionPane.INFORMATION_MESSAGE);\r\n        }",
          "comments": [
            "First update the current category from the table"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(CONFIG_FILE"
            }
          ],
          "body": "{\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                writer.println(\"[\" + category + \"]\");\r\n                \r\n                List\u003cShortcutEntry\u003e entries \u003d categoryShortcuts.get(category);\r\n                for (ShortcutEntry entry : entries) {\r\n                    writer.println(entry.shortcut + \"\u003d\" + entry.action);\r\n                }\r\n                \r\n                writer.println(); // Empty line between categories\r\n            }\r\n            JOptionPane.showMessageDialog(this, \"Settings saved successfully!\", \r\n                    \"Save Complete\", JOptionPane.INFORMATION_MESSAGE);\r\n        }",
          "comments": [
            "First update the current category from the table"
          ]
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "updateCurrentCategoryFromTable",
          "parameters": [],
          "body": "{\r\n        String selectedCategory \u003d (String) categoryComboBox.getSelectedItem();\r\n        if (selectedCategory \u003d\u003d null) return;\r\n        \r\n        List\u003cShortcutEntry\u003e entries \u003d new ArrayList\u003c\u003e();\r\n        for (int i \u003d 0; i \u003c tableModel.getRowCount(); i++) {\r\n            String shortcut \u003d (String) tableModel.getValueAt(i, 0);\r\n            String action \u003d (String) tableModel.getValueAt(i, 1);\r\n            entries.add(new ShortcutEntry(shortcut, action));\r\n        }\r\n        \r\n        categoryShortcuts.put(selectedCategory, entries);\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [],
          "body": "{\r\n        categoryShortcuts.clear();\r\n        \r\n        try (BufferedReader reader \u003d new BufferedReader(new FileReader(CONFIG_FILE))) {\r\n            String line;\r\n            String currentCategory \u003d null;\r\n            List\u003cShortcutEntry\u003e currentEntries \u003d null;\r\n            \r\n            while ((line \u003d reader.readLine()) !\u003d null) {\r\n                line \u003d line.trim();\r\n                if (line.isEmpty()) continue;\r\n                \r\n                if (line.startsWith(\"[\") \u0026\u0026 line.endsWith(\"]\")) {\r\n                    // Save previous category if needed\r\n                    if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                        categoryShortcuts.put(currentCategory, currentEntries);\r\n                    }\r\n                    \r\n                    // Start new category\r\n                    currentCategory \u003d line.substring(1, line.length() - 1);\r\n                    currentEntries \u003d new ArrayList\u003c\u003e();\r\n                } else if (currentCategory !\u003d null \u0026\u0026 line.contains(\"\u003d\")) {\r\n                    // Parse shortcut entry\r\n                    int separatorIndex \u003d line.indexOf(\u0027\u003d\u0027);\r\n                    String shortcut \u003d line.substring(0, separatorIndex);\r\n                    String action \u003d line.substring(separatorIndex + 1);\r\n                    currentEntries.add(new ShortcutEntry(shortcut, action));\r\n                }\r\n            }\r\n            \r\n            // Save last category\r\n            if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                categoryShortcuts.put(currentCategory, currentEntries);\r\n            }\r\n            \r\n            // Update combo box with loaded categories\r\n            categoryComboBox.removeAllItems();\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                categoryComboBox.addItem(category);\r\n            }\r\n        } catch (IOException e) {\r\n            System.err.println(\"Error reading config file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "void",
          "methodName": "loadFromFile",
          "parameters": [],
          "body": "{\r\n        categoryShortcuts.clear();\r\n        \r\n        try (BufferedReader reader \u003d new BufferedReader(new FileReader(CONFIG_FILE))) {\r\n            String line;\r\n            String currentCategory \u003d null;\r\n            List\u003cShortcutEntry\u003e currentEntries \u003d null;\r\n            \r\n            while ((line \u003d reader.readLine()) !\u003d null) {\r\n                line \u003d line.trim();\r\n                if (line.isEmpty()) continue;\r\n                \r\n                if (line.startsWith(\"[\") \u0026\u0026 line.endsWith(\"]\")) {\r\n                    // Save previous category if needed\r\n                    if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                        categoryShortcuts.put(currentCategory, currentEntries);\r\n                    }\r\n                    \r\n                    // Start new category\r\n                    currentCategory \u003d line.substring(1, line.length() - 1);\r\n                    currentEntries \u003d new ArrayList\u003c\u003e();\r\n                } else if (currentCategory !\u003d null \u0026\u0026 line.contains(\"\u003d\")) {\r\n                    // Parse shortcut entry\r\n                    int separatorIndex \u003d line.indexOf(\u0027\u003d\u0027);\r\n                    String shortcut \u003d line.substring(0, separatorIndex);\r\n                    String action \u003d line.substring(separatorIndex + 1);\r\n                    currentEntries.add(new ShortcutEntry(shortcut, action));\r\n                }\r\n            }\r\n            \r\n            // Save last category\r\n            if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                categoryShortcuts.put(currentCategory, currentEntries);\r\n            }\r\n            \r\n            // Update combo box with loaded categories\r\n            categoryComboBox.removeAllItems();\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                categoryComboBox.addItem(category);\r\n            }\r\n        } catch (IOException e) {\r\n            System.err.println(\"Error reading config file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "BufferedReader",
          "parameters": [
            {
              "type": "new",
              "name": "FileReader(CONFIG_FILE"
            }
          ],
          "body": "{\r\n            String line;\r\n            String currentCategory \u003d null;\r\n            List\u003cShortcutEntry\u003e currentEntries \u003d null;\r\n            \r\n            while ((line \u003d reader.readLine()) !\u003d null) {\r\n                line \u003d line.trim();\r\n                if (line.isEmpty()) continue;\r\n                \r\n                if (line.startsWith(\"[\") \u0026\u0026 line.endsWith(\"]\")) {\r\n                    // Save previous category if needed\r\n                    if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                        categoryShortcuts.put(currentCategory, currentEntries);\r\n                    }\r\n                    \r\n                    // Start new category\r\n                    currentCategory \u003d line.substring(1, line.length() - 1);\r\n                    currentEntries \u003d new ArrayList\u003c\u003e();\r\n                } else if (currentCategory !\u003d null \u0026\u0026 line.contains(\"\u003d\")) {\r\n                    // Parse shortcut entry\r\n                    int separatorIndex \u003d line.indexOf(\u0027\u003d\u0027);\r\n                    String shortcut \u003d line.substring(0, separatorIndex);\r\n                    String action \u003d line.substring(separatorIndex + 1);\r\n                    currentEntries.add(new ShortcutEntry(shortcut, action));\r\n                }\r\n            }\r\n            \r\n            // Save last category\r\n            if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                categoryShortcuts.put(currentCategory, currentEntries);\r\n            }\r\n            \r\n            // Update combo box with loaded categories\r\n            categoryComboBox.removeAllItems();\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                categoryComboBox.addItem(category);\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "needed",
          "methodName": "if",
          "parameters": [
            {
              "type": "currentCategory",
              "name": "!\u003d"
            }
          ],
          "body": "{\r\n                        categoryShortcuts.put(currentCategory, currentEntries);\r\n                    }",
          "comments": [
            "Save previous category if needed"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [
            {
              "type": "currentCategory",
              "name": "!\u003d"
            }
          ],
          "body": "{\r\n                    // Parse shortcut entry\r\n                    int separatorIndex \u003d line.indexOf(\u0027\u003d\u0027);\r\n                    String shortcut \u003d line.substring(0, separatorIndex);\r\n                    String action \u003d line.substring(separatorIndex + 1);\r\n                    currentEntries.add(new ShortcutEntry(shortcut, action));\r\n                }",
          "comments": [
            "Start new category",
            "Parse shortcut en"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ShortcutEntry",
          "parameters": [],
          "body": "{\r\n        categoryShortcuts.clear();\r\n        \r\n        try (BufferedReader reader \u003d new BufferedReader(new FileReader(CONFIG_FILE))) {\r\n            String line;\r\n            String currentCategory \u003d null;\r\n            List\u003cShortcutEntry\u003e currentEntries \u003d null;\r\n            \r\n            while ((line \u003d reader.readLine()) !\u003d null) {\r\n                line \u003d line.trim();\r\n                if (line.isEmpty()) continue;\r\n                \r\n                if (line.startsWith(\"[\") \u0026\u0026 line.endsWith(\"]\")) {\r\n                    // Save previous category if needed\r\n                    if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                        categoryShortcuts.put(currentCategory, currentEntries);\r\n                    }\r\n                    \r\n                    // Start new category\r\n                    currentCategory \u003d line.substring(1, line.length() - 1);\r\n                    currentEntries \u003d new ArrayList\u003c\u003e();\r\n                } else if (currentCategory !\u003d null \u0026\u0026 line.contains(\"\u003d\")) {\r\n                    // Parse shortcut entry\r\n                    int separatorIndex \u003d line.indexOf(\u0027\u003d\u0027);\r\n                    String shortcut \u003d line.substring(0, separatorIndex);\r\n                    String action \u003d line.substring(separatorIndex + 1);\r\n                    currentEntries.add(new ShortcutEntry(shortcut, action));\r\n                }\r\n            }\r\n            \r\n            // Save last category\r\n            if (currentCategory !\u003d null \u0026\u0026 currentEntries !\u003d null) {\r\n                categoryShortcuts.put(currentCategory, currentEntries);\r\n            }\r\n            \r\n            // Update combo box with loaded categories\r\n            categoryComboBox.removeAllItems();\r\n            for (String category : categoryShortcuts.keySet()) {\r\n                categoryComboBox.addItem(category);\r\n            }\r\n        } catch (IOException e) {\r\n            System.err.println(\"Error reading config file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "category",
          "methodName": "if",
          "parameters": [
            {
              "type": "currentCategory",
              "name": "!\u003d"
            }
          ],
          "body": "{\r\n                categoryShortcuts.put(currentCategory, currentEntries);\r\n            }",
          "comments": [
            "Save last category"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "mousePressed",
          "parameters": [
            {
              "type": "MouseEvent",
              "name": "e"
            }
          ],
          "body": "{\r\n            dragStart \u003d e.getPoint();\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "mouseDragged",
          "parameters": [
            {
              "type": "MouseEvent",
              "name": "e"
            }
          ],
          "body": "{\r\n            if (dragStart !\u003d null) {\r\n                Point currentLocation \u003d getLocation();\r\n                setLocation(\r\n                    currentLocation.x + e.getX() - dragStart.x,\r\n                    currentLocation.y + e.getY() - dragStart.y\r\n                );\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "mouseReleased",
          "parameters": [
            {
              "type": "MouseEvent",
              "name": "e"
            }
          ],
          "body": "{\r\n            dragStart \u003d null;\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "main",
          "parameters": [
            {
              "type": "String[]",
              "name": "args"
            }
          ],
          "body": "{\r\n        // Set look and feel to system default\r\n        try {\r\n            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        \r\n        // Enable anti-aliased text\r\n        System.setProperty(\"awt.useSystemAAFontSettings\", \"on\");\r\n        System.setProperty(\"swing.aatext\", \"true\");\r\n        \r\n        SwingUtilities.invokeLater(() -\u003e {\r\n            KeyMappingDisplay display \u003d new KeyMappingDisplay();\r\n            display.setVisible(true);\r\n        });\r\n    }",
          "comments": [
            "Set look and feel to system default"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "KeyMappingDisplay",
          "parameters": [],
          "body": "",
          "comments": []
        }
      ],
      "className": "KeyMappingDisplay",
      "packageName": "io.joshuasalcedo"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/test/java/io/joshuasalcedo/parsers/GitParserTest.java",
      "methods": [
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "boolean",
          "methodName": "isCurrentDirGitRepo",
          "parameters": [],
          "body": "{\r\n        File gitDir \u003d new File(\".git\");\r\n        return gitDir.exists() \u0026\u0026 gitDir.isDirectory();\r\n    }",
          "javadoc": {
            "description": "Helper method to check if the current directory is a Git repository",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Use the current directory as the repository to parse\r\n            GitRepositoryInfo repoInfo \u003d GitParser.parseRepository(\".\");\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-parser-output.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }\r\n\r\n            // Basic assertions to make sure the parser works\r\n            assertNotNull(repoInfo.getName(), \"Repository name should not be null\");\r\n            assertNotNull(repoInfo.getCurrentBranch(), \"Current branch should not be null\");\r\n\r\n            // Don\u0027t assert on latest commit - it might be null in a fresh repo\r\n            // Only check commit count instead\r\n            assertTrue(repoInfo.getCommitCount() \u003e\u003d 0, \"Commit count should be zero or positive\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while parsing repository: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to check if the current directory is a Git repository",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "Git",
          "methodName": "repository",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Use the current directory as the repository to parse\r\n            GitRepositoryInfo repoInfo \u003d GitParser.parseRepository(\".\");\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-parser-output.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }\r\n\r\n            // Basic assertions to make sure the parser works\r\n            assertNotNull(repoInfo.getName(), \"Repository name should not be null\");\r\n            assertNotNull(repoInfo.getCurrentBranch(), \"Current branch should not be null\");\r\n\r\n            // Don\u0027t assert on latest commit - it might be null in a fresh repo\r\n            // Only check commit count instead\r\n            assertTrue(repoInfo.getCommitCount() \u003e\u003d 0, \"Commit count should be zero or positive\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while parsing repository: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Helper method to check if the current directory is a Git repository",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseCurrentRepository",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Use the current directory as the repository to parse\r\n            GitRepositoryInfo repoInfo \u003d GitParser.parseRepository(\".\");\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-parser-output.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }\r\n\r\n            // Basic assertions to make sure the parser works\r\n            assertNotNull(repoInfo.getName(), \"Repository name should not be null\");\r\n            assertNotNull(repoInfo.getCurrentBranch(), \"Current branch should not be null\");\r\n\r\n            // Don\u0027t assert on latest commit - it might be null in a fresh repo\r\n            // Only check commit count instead\r\n            assertTrue(repoInfo.getCommitCount() \u003e\u003d 0, \"Commit count should be zero or positive\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while parsing repository: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test parsing the current Git repository (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Use the cu"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }",
          "javadoc": {
            "description": "Test parsing the current Git repository (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Create an output file in the target directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }",
          "comments": [
            "Print basic repository informati"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }",
          "comments": [
            "Print file extension counts if available"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }",
          "comments": [
            "Print statistics if available"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }",
          "comments": [
            "Print top contributors if available"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "commit",
          "methodName": "information",
          "parameters": [
            {
              "type": "if",
              "name": "available"
            }
          ],
          "body": "{\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                }",
          "comments": [
            "Print latest commit information (if available)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "works",
          "methodName": "assertNotNull",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while parsing repository: \" + e.getMessage());\r\n        }",
          "comments": [
            "Basic assertions to make sure the parser works"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "instead",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while parsing repository: \" + e.getMessage());\r\n        }",
          "comments": [
            "Don\u0027t assert on latest commit - it might be null in a fresh repo",
            "Only check commit count instead"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "commit",
          "methodName": "log",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        // Create an output file in the target directory\r\n        File outputFile \u003d new File(\"target/git-commit-log.txt\");\r\n        outputFile.getParentFile().mkdirs();\r\n\r\n        try {\r\n            // Get formatted commit log\r\n            String commitLog \u003d GitParser.getFormattedCommitLog(\".\", 10);\r\n\r\n            // Save to file\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(commitLog);\r\n            }\r\n\r\n            System.out.println(\"Commit log written to: \" + outputFile.getAbsolutePath());\r\n\r\n            // Verify log is not empty\r\n            assertNotNull(commitLog, \"Commit log should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commit log: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testGetCommitLog",
          "parameters": [],
          "body": "{\r\n        // Create an output file in the target directory\r\n        File outputFile \u003d new File(\"target/git-commit-log.txt\");\r\n        outputFile.getParentFile().mkdirs();\r\n\r\n        try {\r\n            // Get formatted commit log\r\n            String commitLog \u003d GitParser.getFormattedCommitLog(\".\", 10);\r\n\r\n            // Save to file\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(commitLog);\r\n            }\r\n\r\n            System.out.println(\"Commit log written to: \" + outputFile.getAbsolutePath());\r\n\r\n            // Verify log is not empty\r\n            assertNotNull(commitLog, \"Commit log should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commit log: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting commit log (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Create an output file in the target dir"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            // Get formatted commit log\r\n            String commitLog \u003d GitParser.getFormattedCommitLog(\".\", 10);\r\n\r\n            // Save to file\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(commitLog);\r\n            }\r\n\r\n            System.out.println(\"Commit log written to: \" + outputFile.getAbsolutePath());\r\n\r\n            // Verify log is not empty\r\n            assertNotNull(commitLog, \"Commit log should not be null\");\r\n\r\n        }",
          "javadoc": {
            "description": "Test getting commit log (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Create an output file in the target directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "file",
          "methodName": "try",
          "parameters": [
            {
              "type": "PrintWriter",
              "name": "writer"
            }
          ],
          "body": "{\r\n                writer.println(commitLog);\r\n            }",
          "comments": [
            "Get formatted commit log",
            "Save to file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "empty",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Commit",
              "name": "log"
            }
          ],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commit log: \" + e.getMessage());\r\n        }",
          "comments": [
            "Verify log is not empty"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "of",
          "methodName": "week",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get contributions by day of week\r\n            Map\u003cString, Integer\u003e contributionsByDay \u003d GitParser.getContributionsByDayOfWeek(\".\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d CONTRIBUTIONS BY DAY OF WEEK \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, Integer\u003e entry : contributionsByDay.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n            }\r\n\r\n            // Verify map is not empty\r\n            assertFalse(contributionsByDay.isEmpty(), \"Contributions by day should not be empty\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contributions by day: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testContributionsByDayOfWeek",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Get contributions by day of week\r\n            Map\u003cString, Integer\u003e contributionsByDay \u003d GitParser.getContributionsByDayOfWeek(\".\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d CONTRIBUTIONS BY DAY OF WEEK \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, Integer\u003e entry : contributionsByDay.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n            }\r\n\r\n            // Verify map is not empty\r\n            assertFalse(contributionsByDay.isEmpty(), \"Contributions by day should not be empty\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contributions by day: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test contributions by day of week (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Get cont"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "empty",
          "methodName": "assertFalse",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contributions by day: \" + e.getMessage());\r\n        }",
          "comments": [
            "Verify map is not empty"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "active",
          "methodName": "files",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get most active files\r\n            Map\u003cString, Integer\u003e activeFiles \u003d GitParser.getMostActiveFiles(\".\", 10);\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d MOST ACTIVE FILES \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, Integer\u003e entry : activeFiles.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue() + \" changes\");\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting most active files: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testMostActiveFiles",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Get most active files\r\n            Map\u003cString, Integer\u003e activeFiles \u003d GitParser.getMostActiveFiles(\".\", 10);\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d MOST ACTIVE FILES \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, Integer\u003e entry : activeFiles.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue() + \" changes\");\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting most active files: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting most active files (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Get most active f"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "current",
          "methodName": "year",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get current year\r\n            int currentYear \u003d Calendar.getInstance().get(Calendar.YEAR);\r\n\r\n            // Get contribution heat map\r\n            Map\u003cString, Integer\u003e heatMap \u003d GitParser.getContributionHeatMap(\".\", currentYear);\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d CONTRIBUTION HEAT MAP FOR \" + currentYear + \" \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + heatMap.size() + \" days in the heat map\");\r\n\r\n            // Print a sample of the heat map (first 10 days with commits)\r\n            int count \u003d 0;\r\n            for (Map.Entry\u003cString, Integer\u003e entry : heatMap.entrySet()) {\r\n                if (entry.getValue() \u003e 0) {\r\n                    System.out.println(entry.getKey() + \": \" + entry.getValue() + \" commits\");\r\n                    count++;\r\n\r\n                    if (count \u003e\u003d 10) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contribution heat map: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testContributionHeatMap",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Get current year\r\n            int currentYear \u003d Calendar.getInstance().get(Calendar.YEAR);\r\n\r\n            // Get contribution heat map\r\n            Map\u003cString, Integer\u003e heatMap \u003d GitParser.getContributionHeatMap(\".\", currentYear);\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d CONTRIBUTION HEAT MAP FOR \" + currentYear + \" \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + heatMap.size() + \" days in the heat map\");\r\n\r\n            // Print a sample of the heat map (first 10 days with commits)\r\n            int count \u003d 0;\r\n            for (Map.Entry\u003cString, Integer\u003e entry : heatMap.entrySet()) {\r\n                if (entry.getValue() \u003e 0) {\r\n                    System.out.println(entry.getKey() + \": \" + entry.getValue() + \" commits\");\r\n                    count++;\r\n\r\n                    if (count \u003e\u003d 10) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contribution heat map: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test contribution heat map for current year (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Get current y"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "heat",
          "methodName": "map",
          "parameters": [
            {
              "type": "first",
              "name": "10"
            }
          ],
          "body": "{\r\n                if (entry.getValue() \u003e 0) {\r\n                    System.out.println(entry.getKey() + \": \" + entry.getValue() + \" commits\");\r\n                    count++;\r\n\r\n                    if (count \u003e\u003d 10) {\r\n                        break;\r\n                    }\r\n                }\r\n            }",
          "comments": [
            "Print a sample of the heat map (first 10 days with commits)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testIsValidRepository",
          "parameters": [],
          "body": "{\r\n        // The current directory should be a valid repository if .git exists\r\n        File gitDir \u003d new File(\".git\");\r\n        boolean expected \u003d gitDir.exists() \u0026\u0026 gitDir.isDirectory();\r\n        boolean actual \u003d GitParser.isValidRepository(\".\");\r\n\r\n        assertEquals(expected, actual, \"isValidRepository should correctly identify a valid repository\");\r\n\r\n        // A non-existent directory should not be a valid repository\r\n        assertFalse(GitParser.isValidRepository(\"/non/existent/directory\"),\r\n                \"Non-existent directory should not be a valid repository\");\r\n    }",
          "javadoc": {
            "description": "Test isValidRepository method",
            "tags": []
          },
          "comments": [
            "The current directory should be a valid repository"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Use the current directory as the repository to parse\r\n            GitRepositoryInfo repoInfo \u003d GitParser.parseRepository(\".\");\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-parser-output.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }\r\n\r\n            // Basic assertions to make sure the parser works\r\n            assertNotNull(repoInfo.getName(), \"Repository name should not be null\");\r\n            assertNotNull(repoInfo.getCurrentBranch(), \"Current branch should not be null\");\r\n\r\n            // Don\u0027t assert on latest commit - it might be null in a fresh repo\r\n            // Only check commit count instead\r\n            assertTrue(repoInfo.getCommitCount() \u003e\u003d 0, \"Commit count should be zero or positive\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while parsing repository: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test isValidRepository method",
            "tags": []
          },
          "comments": [
            "The current directory should be a valid repository if .git exists"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "repository",
          "methodName": "assertFalse",
          "parameters": [],
          "body": "{\r\n        // Testing the findGitRepositories method on src directory\r\n        File srcDir \u003d new File(\"src\");\r\n        List\u003cFile\u003e gitRepos \u003d GitParser.findGitRepositories(srcDir);\r\n\r\n        System.out.println(\"\\n\u003d\u003d\u003d GIT REPOSITORIES FOUND IN SRC \u003d\u003d\u003d\");\r\n        if (gitRepos.isEmpty()) {\r\n            System.out.println(\"No Git repositories found in src directory\");\r\n        } else {\r\n            for (File repo : gitRepos) {\r\n                System.out.println(repo.getAbsolutePath());\r\n            }\r\n        }\r\n\r\n        // Also try at project root level\r\n        File projectDir \u003d new File(\".\");\r\n        List\u003cFile\u003e rootGitRepos \u003d GitParser.findGitRepositories(projectDir);\r\n\r\n        System.out.println(\"\\n\u003d\u003d\u003d GIT REPOSITORIES FOUND AT ROOT \u003d\u003d\u003d\");\r\n        assertTrue(rootGitRepos.size() \u003e\u003d 0, \"Should be able to find repositories without error\");\r\n\r\n        for (File repo : rootGitRepos) {\r\n            System.out.println(repo.getAbsolutePath());\r\n            // Verify it\u0027s a valid repository\r\n            assertTrue(GitParser.isValidRepository(repo.getAbsolutePath()),\r\n                    \"Found repository should be valid: \" + repo.getAbsolutePath());\r\n        }\r\n    }",
          "comments": [
            "A non-existent directory should not be a valid repository"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testFindGitRepositories",
          "parameters": [],
          "body": "{\r\n        // Testing the findGitRepositories method on src directory\r\n        File srcDir \u003d new File(\"src\");\r\n        List\u003cFile\u003e gitRepos \u003d GitParser.findGitRepositories(srcDir);\r\n\r\n        System.out.println(\"\\n\u003d\u003d\u003d GIT REPOSITORIES FOUND IN SRC \u003d\u003d\u003d\");\r\n        if (gitRepos.isEmpty()) {\r\n            System.out.println(\"No Git repositories found in src directory\");\r\n        } else {\r\n            for (File repo : gitRepos) {\r\n                System.out.println(repo.getAbsolutePath());\r\n            }\r\n        }\r\n\r\n        // Also try at project root level\r\n        File projectDir \u003d new File(\".\");\r\n        List\u003cFile\u003e rootGitRepos \u003d GitParser.findGitRepositories(projectDir);\r\n\r\n        System.out.println(\"\\n\u003d\u003d\u003d GIT REPOSITORIES FOUND AT ROOT \u003d\u003d\u003d\");\r\n        assertTrue(rootGitRepos.size() \u003e\u003d 0, \"Should be able to find repositories without error\");\r\n\r\n        for (File repo : rootGitRepos) {\r\n            System.out.println(repo.getAbsolutePath());\r\n            // Verify it\u0027s a valid repository\r\n            assertTrue(GitParser.isValidRepository(repo.getAbsolutePath()),\r\n                    \"Found repository should be valid: \" + repo.getAbsolutePath());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test findGitRepositories method",
            "tags": []
          },
          "comments": [
            "Testing the findGitRepositories method on src dir"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            System.out.println(\"No Git repositories found in src directory\");\r\n        }",
          "javadoc": {
            "description": "Test findGitRepositories method",
            "tags": []
          },
          "comments": [
            "Testing the findGitRepositories method on src directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            System.out.println(repo.getAbsolutePath());\r\n            // Verify it\u0027s a valid repository\r\n            assertTrue(GitParser.isValidRepository(repo.getAbsolutePath()),\r\n                    \"Found repository should be valid: \" + repo.getAbsolutePath());\r\n        }",
          "comments": [
            "Also try at project root level"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "repository",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        // Create a temporary directory that\u0027s definitely not a Git repo\r\n        File tempDir \u003d new File(\"target/temp-non-git-dir\");\r\n        tempDir.mkdirs();\r\n\r\n        assertFalse(GitParser.isValidRepository(tempDir.getAbsolutePath()),\r\n                \"Non-Git directory should not be identified as a valid repository\");\r\n\r\n        // Cleanup\r\n        tempDir.delete();\r\n    }",
          "comments": [
            "Verify it\u0027s a valid repository"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testNonGitDirectory",
          "parameters": [],
          "body": "{\r\n        // Create a temporary directory that\u0027s definitely not a Git repo\r\n        File tempDir \u003d new File(\"target/temp-non-git-dir\");\r\n        tempDir.mkdirs();\r\n\r\n        assertFalse(GitParser.isValidRepository(tempDir.getAbsolutePath()),\r\n                \"Non-Git directory should not be identified as a valid repository\");\r\n\r\n        // Cleanup\r\n        tempDir.delete();\r\n    }",
          "javadoc": {
            "description": "Test that the GitParser can handle a non-Git directory",
            "tags": []
          },
          "comments": [
            "Create a temporary directory that\u0027s definitely not a"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Get the 5 most recent commits\r\n            List\u003cCommitInfo\u003e recentCommits \u003d GitParser.getRecentCommits(\".\", 5);\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-recent-commits.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(\"\u003d\u003d\u003d RECENT COMMITS \u003d\u003d\u003d\");\r\n                writer.println(\"Found \" + recentCommits.size() + \" recent commits:\");\r\n\r\n                SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n                for (CommitInfo commit : recentCommits) {\r\n                    writer.println(\"\\nCommit: \" + commit.getShortId());\r\n                    writer.println(\"Author: \" + commit.getAuthorName() + \" \u003c\" + commit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + dateFormat.format(commit.getAuthorDate()));\r\n                    writer.println(\"Message: \" + commit.getMessage());\r\n\r\n                    // Print changed files\r\n                    if (commit.getChangedFiles() !\u003d null \u0026\u0026 !commit.getChangedFiles().isEmpty()) {\r\n                        writer.println(\"Changed Files:\");\r\n\r\n                        for (FileChange change : commit.getChangedFiles()) {\r\n                            writer.println(\"  \" + change.getType() + \": \" + change.getPath());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            System.out.println(\"Recent commits written to: \" + outputFile.getAbsolutePath());\r\n\r\n            // Verify we got some commits (unless it\u0027s a brand new repo)\r\n            assertNotNull(recentCommits, \"Recent commits should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting recent commits: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test that the GitParser can handle a non-Git directory",
            "tags": []
          },
          "comments": [
            "Create a temporary directory that\u0027s definitely not a Git repo"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "recent",
          "methodName": "commits",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get the 5 most recent commits\r\n            List\u003cCommitInfo\u003e recentCommits \u003d GitParser.getRecentCommits(\".\", 5);\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-recent-commits.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(\"\u003d\u003d\u003d RECENT COMMITS \u003d\u003d\u003d\");\r\n                writer.println(\"Found \" + recentCommits.size() + \" recent commits:\");\r\n\r\n                SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n                for (CommitInfo commit : recentCommits) {\r\n                    writer.println(\"\\nCommit: \" + commit.getShortId());\r\n                    writer.println(\"Author: \" + commit.getAuthorName() + \" \u003c\" + commit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + dateFormat.format(commit.getAuthorDate()));\r\n                    writer.println(\"Message: \" + commit.getMessage());\r\n\r\n                    // Print changed files\r\n                    if (commit.getChangedFiles() !\u003d null \u0026\u0026 !commit.getChangedFiles().isEmpty()) {\r\n                        writer.println(\"Changed Files:\");\r\n\r\n                        for (FileChange change : commit.getChangedFiles()) {\r\n                            writer.println(\"  \" + change.getType() + \": \" + change.getPath());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            System.out.println(\"Recent commits written to: \" + outputFile.getAbsolutePath());\r\n\r\n            // Verify we got some commits (unless it\u0027s a brand new repo)\r\n            assertNotNull(recentCommits, \"Recent commits should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting recent commits: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": [
            "Cleanup"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "recent",
          "methodName": "commits",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get the 5 most recent commits\r\n            List\u003cCommitInfo\u003e recentCommits \u003d GitParser.getRecentCommits(\".\", 5);\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-recent-commits.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(\"\u003d\u003d\u003d RECENT COMMITS \u003d\u003d\u003d\");\r\n                writer.println(\"Found \" + recentCommits.size() + \" recent commits:\");\r\n\r\n                SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n                for (CommitInfo commit : recentCommits) {\r\n                    writer.println(\"\\nCommit: \" + commit.getShortId());\r\n                    writer.println(\"Author: \" + commit.getAuthorName() + \" \u003c\" + commit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + dateFormat.format(commit.getAuthorDate()));\r\n                    writer.println(\"Message: \" + commit.getMessage());\r\n\r\n                    // Print changed files\r\n                    if (commit.getChangedFiles() !\u003d null \u0026\u0026 !commit.getChangedFiles().isEmpty()) {\r\n                        writer.println(\"Changed Files:\");\r\n\r\n                        for (FileChange change : commit.getChangedFiles()) {\r\n                            writer.println(\"  \" + change.getType() + \": \" + change.getPath());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            System.out.println(\"Recent commits written to: \" + outputFile.getAbsolutePath());\r\n\r\n            // Verify we got some commits (unless it\u0027s a brand new repo)\r\n            assertNotNull(recentCommits, \"Recent commits should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting recent commits: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting recent commits (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Cleanup"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testGetRecentCommits",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Get the 5 most recent commits\r\n            List\u003cCommitInfo\u003e recentCommits \u003d GitParser.getRecentCommits(\".\", 5);\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-recent-commits.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(\"\u003d\u003d\u003d RECENT COMMITS \u003d\u003d\u003d\");\r\n                writer.println(\"Found \" + recentCommits.size() + \" recent commits:\");\r\n\r\n                SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n                for (CommitInfo commit : recentCommits) {\r\n                    writer.println(\"\\nCommit: \" + commit.getShortId());\r\n                    writer.println(\"Author: \" + commit.getAuthorName() + \" \u003c\" + commit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + dateFormat.format(commit.getAuthorDate()));\r\n                    writer.println(\"Message: \" + commit.getMessage());\r\n\r\n                    // Print changed files\r\n                    if (commit.getChangedFiles() !\u003d null \u0026\u0026 !commit.getChangedFiles().isEmpty()) {\r\n                        writer.println(\"Changed Files:\");\r\n\r\n                        for (FileChange change : commit.getChangedFiles()) {\r\n                            writer.println(\"  \" + change.getType() + \": \" + change.getPath());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            System.out.println(\"Recent commits written to: \" + outputFile.getAbsolutePath());\r\n\r\n            // Verify we got some commits (unless it\u0027s a brand new repo)\r\n            assertNotNull(recentCommits, \"Recent commits should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting recent commits: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting recent commits (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Get the 5 most r"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                writer.println(\"\u003d\u003d\u003d RECENT COMMITS \u003d\u003d\u003d\");\r\n                writer.println(\"Found \" + recentCommits.size() + \" recent commits:\");\r\n\r\n                SimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n                for (CommitInfo commit : recentCommits) {\r\n                    writer.println(\"\\nCommit: \" + commit.getShortId());\r\n                    writer.println(\"Author: \" + commit.getAuthorName() + \" \u003c\" + commit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + dateFormat.format(commit.getAuthorDate()));\r\n                    writer.println(\"Message: \" + commit.getMessage());\r\n\r\n                    // Print changed files\r\n                    if (commit.getChangedFiles() !\u003d null \u0026\u0026 !commit.getChangedFiles().isEmpty()) {\r\n                        writer.println(\"Changed Files:\");\r\n\r\n                        for (FileChange change : commit.getChangedFiles()) {\r\n                            writer.println(\"  \" + change.getType() + \": \" + change.getPath());\r\n                        }\r\n                    }\r\n                }\r\n            }",
          "javadoc": {
            "description": "Test getting recent commits (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Create an output file in the target directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [
            {
              "type": "\"yyyy-MM-dd",
              "name": "HH:mm:ss\""
            }
          ],
          "body": "{\r\n                    writer.println(\"\\nCommit: \" + commit.getShortId());\r\n                    writer.println(\"Author: \" + commit.getAuthorName() + \" \u003c\" + commit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + dateFormat.format(commit.getAuthorDate()));\r\n                    writer.println(\"Message: \" + commit.getMessage());\r\n\r\n                    // Print changed files\r\n                    if (commit.getChangedFiles() !\u003d null \u0026\u0026 !commit.getChangedFiles().isEmpty()) {\r\n                        writer.println(\"Changed Files:\");\r\n\r\n                        for (FileChange change : commit.getChangedFiles()) {\r\n                            writer.println(\"  \" + change.getType() + \": \" + change.getPath());\r\n                        }\r\n                    }\r\n                }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "files",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                        writer.println(\"Changed Files:\");\r\n\r\n                        for (FileChange change : commit.getChangedFiles()) {\r\n                            writer.println(\"  \" + change.getType() + \": \" + change.getPath());\r\n                        }\r\n                    }",
          "comments": [
            "Print changed files"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "some",
          "methodName": "commits",
          "parameters": [
            {
              "type": "unless",
              "name": "it\u0027s"
            }
          ],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting recent commits: \" + e.getMessage());\r\n        }",
          "comments": [
            "Verify we got some commits (unless it\u0027s a brand new repo)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "by",
          "methodName": "author",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // First, get any commit to find an author\u0027s name\r\n            List\u003cCommitInfo\u003e commits \u003d GitParser.getRecentCommits(\".\", 1);\r\n\r\n            if (!commits.isEmpty()) {\r\n                String authorName \u003d commits.get(0).getAuthorName();\r\n\r\n                // Now use that author name to find their commits\r\n                List\u003cCommitInfo\u003e authorCommits \u003d GitParser.getCommitsByAuthor(\".\", authorName);\r\n\r\n                System.out.println(\"\\n\u003d\u003d\u003d COMMITS BY \" + authorName + \" \u003d\u003d\u003d\");\r\n                System.out.println(\"Found \" + authorCommits.size() + \" commits\");\r\n\r\n                for (int i \u003d 0; i \u003c Math.min(5, authorCommits.size()); i++) {\r\n                    CommitInfo commit \u003d authorCommits.get(i);\r\n                    System.out.println(commit.getShortId() + \": \" + commit.getMessage());\r\n                }\r\n\r\n                // Verify we found at least the one commit we know this author made\r\n                assertTrue(authorCommits.size() \u003e\u003d 1,\r\n                        \"Should find at least one commit by \" + authorName);\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by author: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testGetCommitsByAuthor",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // First, get any commit to find an author\u0027s name\r\n            List\u003cCommitInfo\u003e commits \u003d GitParser.getRecentCommits(\".\", 1);\r\n\r\n            if (!commits.isEmpty()) {\r\n                String authorName \u003d commits.get(0).getAuthorName();\r\n\r\n                // Now use that author name to find their commits\r\n                List\u003cCommitInfo\u003e authorCommits \u003d GitParser.getCommitsByAuthor(\".\", authorName);\r\n\r\n                System.out.println(\"\\n\u003d\u003d\u003d COMMITS BY \" + authorName + \" \u003d\u003d\u003d\");\r\n                System.out.println(\"Found \" + authorCommits.size() + \" commits\");\r\n\r\n                for (int i \u003d 0; i \u003c Math.min(5, authorCommits.size()); i++) {\r\n                    CommitInfo commit \u003d authorCommits.get(i);\r\n                    System.out.println(commit.getShortId() + \": \" + commit.getMessage());\r\n                }\r\n\r\n                // Verify we found at least the one commit we know this author made\r\n                assertTrue(authorCommits.size() \u003e\u003d 1,\r\n                        \"Should find at least one commit by \" + authorName);\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by author: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting commits by author (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "First, get any"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "made",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by author: \" + e.getMessage());\r\n        }",
          "comments": [
            "Verify we found at least the one commit we know this author made"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "date",
          "methodName": "range",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get current date\r\n            Calendar calendar \u003d Calendar.getInstance();\r\n            Date today \u003d calendar.getTime();\r\n\r\n            // Set date one year ago\r\n            calendar.add(Calendar.YEAR, -1);\r\n            Date oneYearAgo \u003d calendar.getTime();\r\n\r\n            // Get commits in the last year\r\n            List\u003cCommitInfo\u003e yearCommits \u003d GitParser.getCommitsByDateRange(\".\", oneYearAgo, today);\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d COMMITS IN THE LAST YEAR \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + yearCommits.size() + \" commits between \" +\r\n                    new SimpleDateFormat(\"yyyy-MM-dd\").format(oneYearAgo) + \" and \" +\r\n                    new SimpleDateFormat(\"yyyy-MM-dd\").format(today));\r\n\r\n            // Verify we got a result (might be empty for new repos)\r\n            assertNotNull(yearCommits, \"Year commits should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by date range: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testGetCommitsByDateRange",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Get current date\r\n            Calendar calendar \u003d Calendar.getInstance();\r\n            Date today \u003d calendar.getTime();\r\n\r\n            // Set date one year ago\r\n            calendar.add(Calendar.YEAR, -1);\r\n            Date oneYearAgo \u003d calendar.getTime();\r\n\r\n            // Get commits in the last year\r\n            List\u003cCommitInfo\u003e yearCommits \u003d GitParser.getCommitsByDateRange(\".\", oneYearAgo, today);\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d COMMITS IN THE LAST YEAR \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + yearCommits.size() + \" commits between \" +\r\n                    new SimpleDateFormat(\"yyyy-MM-dd\").format(oneYearAgo) + \" and \" +\r\n                    new SimpleDateFormat(\"yyyy-MM-dd\").format(today));\r\n\r\n            // Verify we got a result (might be empty for new repos)\r\n            assertNotNull(yearCommits, \"Year commits should not be null\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by date range: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting commits by date range (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Get current"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by date range: \" + e.getMessage());\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by date range: \" + e.getMessage());\r\n        }",
          "comments": [
            "Verify we"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "a",
          "methodName": "result",
          "parameters": [
            {
              "type": "might",
              "name": "be"
            }
          ],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting commits by date range: \" + e.getMessage());\r\n        }",
          "comments": [
            "Verify we got a result (might be empty for new repos)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "specific",
          "methodName": "file",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // First, find a file in the repository\r\n            File gitParserFile \u003d new File(\"src/main/java/io/joshuasalcedo/parsers/GitParser.java\");\r\n\r\n            if (!gitParserFile.exists()) {\r\n                System.out.println(\"GitParser.java file not found, skipping file history test\");\r\n                return;\r\n            }\r\n\r\n            // Get history for the file\r\n            List\u003cCommitInfo\u003e fileHistory \u003d GitParser.getFileHistory(\".\",\r\n                    \"src/main/java/io/joshuasalcedo/parsers/GitParser.java\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d FILE HISTORY FOR GitParser.java \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + fileHistory.size() + \" commits that modified this file\");\r\n\r\n            for (int i \u003d 0; i \u003c Math.min(5, fileHistory.size()); i++) {\r\n                CommitInfo commit \u003d fileHistory.get(i);\r\n                System.out.println(commit.getShortId() + \" (\" +\r\n                        new SimpleDateFormat(\"yyyy-MM-dd\").format(commit.getAuthorDate()) +\r\n                        \"): \" + commit.getMessage());\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting file history: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testGetFileHistory",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // First, find a file in the repository\r\n            File gitParserFile \u003d new File(\"src/main/java/io/joshuasalcedo/parsers/GitParser.java\");\r\n\r\n            if (!gitParserFile.exists()) {\r\n                System.out.println(\"GitParser.java file not found, skipping file history test\");\r\n                return;\r\n            }\r\n\r\n            // Get history for the file\r\n            List\u003cCommitInfo\u003e fileHistory \u003d GitParser.getFileHistory(\".\",\r\n                    \"src/main/java/io/joshuasalcedo/parsers/GitParser.java\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d FILE HISTORY FOR GitParser.java \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + fileHistory.size() + \" commits that modified this file\");\r\n\r\n            for (int i \u003d 0; i \u003c Math.min(5, fileHistory.size()); i++) {\r\n                CommitInfo commit \u003d fileHistory.get(i);\r\n                System.out.println(commit.getShortId() + \" (\" +\r\n                        new SimpleDateFormat(\"yyyy-MM-dd\").format(commit.getAuthorDate()) +\r\n                        \"): \" + commit.getMessage());\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting file history: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting file history for a specific file (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "First, find a file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                System.out.println(\"GitParser.java file not found, skipping file history test\");\r\n                return;\r\n            }",
          "javadoc": {
            "description": "Test getting file history for a specific file (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "First, find a file in the repository"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "SimpleDateFormat",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting file history: \" + e.getMessage());\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "of",
          "methodName": "day",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // Get contributions by hour of day\r\n            Map\u003cInteger, Integer\u003e contributionsByHour \u003d GitParser.getContributionsByHourOfDay(\".\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d CONTRIBUTIONS BY HOUR OF DAY \u003d\u003d\u003d\");\r\n            for (int hour \u003d 0; hour \u003c 24; hour++) {\r\n                System.out.println(String.format(\"%02d:00\", hour) + \" - \" + contributionsByHour.get(hour) + \" commits\");\r\n            }\r\n\r\n            // Verify map is not empty and has 24 hours\r\n            assertFalse(contributionsByHour.isEmpty(), \"Contributions by hour should not be empty\");\r\n            assertEquals(24, contributionsByHour.size(), \"Contributions by hour should have 24 entries\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contributions by hour: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testContributionsByHourOfDay",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Get contributions by hour of day\r\n            Map\u003cInteger, Integer\u003e contributionsByHour \u003d GitParser.getContributionsByHourOfDay(\".\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d CONTRIBUTIONS BY HOUR OF DAY \u003d\u003d\u003d\");\r\n            for (int hour \u003d 0; hour \u003c 24; hour++) {\r\n                System.out.println(String.format(\"%02d:00\", hour) + \" - \" + contributionsByHour.get(hour) + \" commits\");\r\n            }\r\n\r\n            // Verify map is not empty and has 24 hours\r\n            assertFalse(contributionsByHour.isEmpty(), \"Contributions by hour should not be empty\");\r\n            assertEquals(24, contributionsByHour.size(), \"Contributions by hour should have 24 entries\");\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contributions by hour: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test contribution statistics by hour of day (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Get cont"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "hours",
          "methodName": "assertFalse",
          "parameters": [],
          "body": "{\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting contributions by hour: \" + e.getMessage());\r\n        }",
          "comments": [
            "Verify map is not empty and has 24 hours"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "specific",
          "methodName": "file",
          "parameters": [
            {
              "type": "only",
              "name": "runs"
            }
          ],
          "body": "{\r\n        try {\r\n            // First, find a file in the repository\r\n            File gitParserFile \u003d new File(\"src/main/java/io/joshuasalcedo/parsers/GitParser.java\");\r\n\r\n            if (!gitParserFile.exists()) {\r\n                System.out.println(\"GitParser.java file not found, skipping file history test\");\r\n                return;\r\n            }\r\n\r\n            // Get history for the file\r\n            List\u003cCommitInfo\u003e fileHistory \u003d GitParser.getFileHistory(\".\",\r\n                    \"src/main/java/io/joshuasalcedo/parsers/GitParser.java\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d FILE HISTORY FOR GitParser.java \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + fileHistory.size() + \" commits that modified this file\");\r\n\r\n            for (int i \u003d 0; i \u003c Math.min(5, fileHistory.size()); i++) {\r\n                CommitInfo commit \u003d fileHistory.get(i);\r\n                System.out.println(commit.getShortId() + \" (\" +\r\n                        new SimpleDateFormat(\"yyyy-MM-dd\").format(commit.getAuthorDate()) +\r\n                        \"): \" + commit.getMessage());\r\n            }\r\n\r\n        } catch (IOException | org.eclipse.jgit.api.errors.GitAPIException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting file history: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testGetFileBlame",
          "parameters": [],
          "body": "{\r\n        try {\r\n            // Find a Java file that\u0027s likely to exist and have commits\r\n            String filePath \u003d null;\r\n\r\n            // Check if GitParser.java exists\r\n            File gitParserFile \u003d new File(\"src/main/java/io/joshuasalcedo/parsers/GitParser.java\");\r\n            if (gitParserFile.exists()) {\r\n                filePath \u003d \"src/main/java/io/joshuasalcedo/parsers/GitParser.java\";\r\n            } else {\r\n                // If not, try to find any Java file\r\n                File srcDir \u003d new File(\"src\");\r\n                if (srcDir.exists()) {\r\n                    List\u003cFile\u003e javaFiles \u003d findJavaFiles(srcDir);\r\n                    if (!javaFiles.isEmpty()) {\r\n                        filePath \u003d javaFiles.get(0).getPath();\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (filePath \u003d\u003d null) {\r\n                System.out.println(\"No suitable Java file found for blame test, skipping\");\r\n                return;\r\n            }\r\n\r\n            System.out.println(\"Running blame test on file: \" + filePath);\r\n\r\n            // Create a simple implementation to get blame info\r\n            String blameInfo \u003d getSimpleBlameInfo(filePath);\r\n\r\n            // Create an output file in the target directory\r\n            File outputFile \u003d new File(\"target/git-file-blame.txt\");\r\n            outputFile.getParentFile().mkdirs();\r\n\r\n            try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n                writer.println(\"\u003d\u003d\u003d BLAME INFO FOR \" + filePath + \" \u003d\u003d\u003d\");\r\n                writer.println(blameInfo);\r\n            }\r\n\r\n            System.out.println(\"Blame info written to: \" + outputFile.getAbsolutePath());\r\n\r\n        } catch (IOException e) {\r\n            // If there\u0027s an exception, print it and fail the test\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while getting file blame: \" + e.getMessage());\r\n        }\r\n    }",
          "javadoc": {
            "description": "Test getting file blame for a specific file (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Find a Java file tha"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                System.out.println(\"GitParser.java file not found, skipping file history test\");\r\n                return;\r\n            }",
          "javadoc": {
            "description": "Test getting file blame for a specific file (only runs if we\u0027re in a Git repository)",
            "tags": []
          },
          "comments": [
            "Find a Java file that\u0027s likely to exist and have commits",
            "Check if GitParser.java exists"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            System.out.println(\"No Git repositories found in src directory\");\r\n        }",
          "comments": [
            "If not, try to find any Java file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                writer.println(\"\u003d\u003d\u003d BLAME INFO FOR \" + filePath + \" \u003d\u003d\u003d\");\r\n                writer.println(blameInfo);\r\n            }",
          "comments": [
            "Create an output file in the target directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n                // Print basic repository information\r\n                System.out.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d REPOSITORY INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Repository Name: \" + repoInfo.getName());\r\n                System.out.println(\"Repository Path: \" + repoInfo.getPath());\r\n                System.out.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                System.out.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                System.out.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                System.out.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                writer.println(\"Repository Name: \" + repoInfo.getName());\r\n                writer.println(\"Repository Path: \" + repoInfo.getPath());\r\n                writer.println(\"Current Branch: \" + repoInfo.getCurrentBranch());\r\n                writer.println(\"Remote URL: \" + repoInfo.getRemoteUrl());\r\n                writer.println(\"Has Uncommitted Changes: \" + repoInfo.isHasUncommittedChanges());\r\n                writer.println(\"Commit Count: \" + repoInfo.getCommitCount());\r\n\r\n                // Print file extension counts if available\r\n                if (repoInfo.getFileExtensionCounts() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d FILE EXTENSION COUNTS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Integer\u003e entry : repoInfo.getFileExtensionCounts().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print statistics if available\r\n                if (repoInfo.getStatistics() !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d REPOSITORY STATISTICS \u003d\u003d\u003d\");\r\n\r\n                    for (Map.Entry\u003cString, Object\u003e entry : repoInfo.getStatistics().entrySet()) {\r\n                        System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                        writer.println(entry.getKey() + \": \" + entry.getValue());\r\n                    }\r\n                }\r\n\r\n                // Print top contributors if available\r\n                if (repoInfo.getTopContributors() !\u003d null \u0026\u0026 !repoInfo.getTopContributors().isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d TOP CONTRIBUTORS \u003d\u003d\u003d\");\r\n\r\n                    for (ContributorInfo contributor : repoInfo.getTopContributors()) {\r\n                        System.out.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                        writer.println(contributor.getName() + \" \u003c\" + contributor.getEmail() + \"\u003e: \" +\r\n                                contributor.getCommitCount() + \" commits\");\r\n                    }\r\n                }\r\n\r\n                // Print latest commit information (if available)\r\n                CommitInfo latestCommit \u003d repoInfo.getLatestCommit();\r\n                if (latestCommit !\u003d null) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d LATEST COMMIT \u003d\u003d\u003d\");\r\n\r\n                    System.out.println(\"Commit ID: \" + latestCommit.getId());\r\n                    System.out.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    System.out.println(\"Message: \" + latestCommit.getMessage());\r\n                    System.out.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    System.out.println(\"Date: \" + latestCommit.getAuthorDate());\r\n\r\n                    writer.println(\"Commit ID: \" + latestCommit.getId());\r\n                    writer.println(\"Short ID: \" + latestCommit.getShortId());\r\n                    writer.println(\"Message: \" + latestCommit.getMessage());\r\n                    writer.println(\"Author: \" + latestCommit.getAuthorName() + \" \u003c\" + latestCommit.getAuthorEmail() + \"\u003e\");\r\n                    writer.println(\"Date: \" + latestCommit.getAuthorDate());\r\n                } else {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d NO COMMITS FOUND \u003d\u003d\u003d\");\r\n                }\r\n\r\n                // Print branches\r\n                List\u003cBranchInfo\u003e branches \u003d repoInfo.getBranches();\r\n                if (branches !\u003d null \u0026\u0026 !branches.isEmpty()) {\r\n                    System.out.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    writer.println(\"\\n\u003d\u003d\u003d BRANCHES \u003d\u003d\u003d\");\r\n                    System.out.println(\"Found \" + branches.size() + \" branches:\");\r\n                    writer.println(\"Found \" + branches.size() + \" branches:\");\r\n\r\n                    for (BranchInfo branch : branches) {\r\n                        String current \u003d branch.isCurrent() ? \" (current)\" : \"\";\r\n                        String remote \u003d branch.isRemote() ? \" [remote: \" + branch.getRemoteName() + \"]\" : \"\";\r\n\r\n                        System.out.println(\"  \" + branch.getName() + current + remote);\r\n                        writer.println(\"  \" + branch.getName() + current + remote);\r\n                    }\r\n                }\r\n\r\n                System.out.println(\"\\nGit parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n            }",
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "List\u003cFile\u003e",
          "methodName": "findJavaFiles",
          "parameters": [
            {
              "type": "File",
              "name": "directory"
            }
          ],
          "body": "{\r\n        List\u003cFile\u003e javaFiles \u003d new ArrayList\u003c\u003e();\r\n        File[] files \u003d directory.listFiles();\r\n        if (files !\u003d null) {\r\n            for (File file : files) {\r\n                if (file.isDirectory()) {\r\n                    javaFiles.addAll(findJavaFiles(file));\r\n                } else if (file.getName().endsWith(\".java\")) {\r\n                    javaFiles.add(file);\r\n                }\r\n            }\r\n        }\r\n        return javaFiles;\r\n    }",
          "javadoc": {
            "description": "Helper method to find Java files in a directory",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "else",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    javaFiles.add(file);\r\n                }",
          "javadoc": {
            "description": "Helper method to find Java files in a directory",
            "tags": []
          },
          "comments": []
        },
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "String",
          "methodName": "getSimpleBlameInfo",
          "parameters": [
            {
              "type": "String",
              "name": "filePath"
            }
          ],
          "body": "{\r\n        // Use git command line instead of JGit to avoid potential null pointer issues\r\n        try {\r\n            ProcessBuilder pb \u003d new ProcessBuilder(\"git\", \"blame\", filePath);\r\n            pb.redirectErrorStream(true);\r\n            Process process \u003d pb.start();\r\n\r\n            // Read the output\r\n            StringBuilder output \u003d new StringBuilder();\r\n            try (BufferedReader reader \u003d new BufferedReader(\r\n                    new InputStreamReader(process.getInputStream()))) {\r\n                String line;\r\n                while ((line \u003d reader.readLine()) !\u003d null) {\r\n                    output.append(line).append(\"\\n\");\r\n                }\r\n            }\r\n\r\n            // Wait for the process to complete\r\n            int exitCode \u003d process.waitFor();\r\n\r\n            if (exitCode \u003d\u003d 0) {\r\n                return output.toString();\r\n            } else {\r\n                return \"Failed to get blame info. Exit code: \" + exitCode;\r\n            }\r\n        } catch (Exception e) {\r\n            return \"Error getting blame info: \" + e.getMessage();\r\n        }\r\n    }",
          "javadoc": {
            "description": "Simple implementation to get blame info without using JGit directly",
            "tags": []
          },
          "comments": [
            "Use git command"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "ProcessBuilder",
          "parameters": [],
          "body": "{\r\n                String line;\r\n                while ((line \u003d reader.readLine()) !\u003d null) {\r\n                    output.append(line).append(\"\\n\");\r\n                }\r\n            }",
          "javadoc": {
            "description": "Simple implementation to get blame info without using JGit directly",
            "tags": []
          },
          "comments": [
            "Use git command line instead of JGit to avoid potential null pointer issues"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "StringBuilder",
          "parameters": [],
          "body": "{\r\n                String line;\r\n                while ((line \u003d reader.readLine()) !\u003d null) {\r\n                    output.append(line).append(\"\\n\");\r\n                }\r\n            }",
          "comments": [
            "Read the output"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "BufferedReader",
          "parameters": [
            {
              "type": "new",
              "name": "InputStreamReader(process.getInputStream("
            }
          ],
          "body": "{\r\n                String line;\r\n                while ((line \u003d reader.readLine()) !\u003d null) {\r\n                    output.append(line).append(\"\\n\");\r\n                }\r\n            }",
          "comments": [
            "Read the output"
          ]
        }
      ],
      "className": "GitParserTest",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/test/java/io/joshuasalcedo/parsers/HtmlParserTest.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "setUp",
          "parameters": [],
          "body": "{\r\n        // Set up the test HTML file location\r\n        testHtmlFile \u003d new File(\"src/test/resources/test/html/test.html\");\r\n        assertTrue(testHtmlFile.exists(), \"Test HTML file does not exist\");\r\n\r\n        // Set up output file\r\n        outputFile \u003d new File(\"src/test/resources/test/html/test-output.txt\");\r\n    }",
          "comments": [
            "Set up the test HTML file location"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        // Create output file writer\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            // Parse the HTML file\r\n            Document document \u003d HtmlParser.parse(testHtmlFile, \"UTF-8\", \"\");\r\n\r\n            // Test basic HTML parsing\r\n            assertNotNull(document, \"Document should not be null\");\r\n            String title \u003d document.title();\r\n            assertEquals(\"Test HTML Document\", title, \"Document title should match\");\r\n\r\n            // Print document title\r\n            System.out.println(\"Document Title: \" + title);\r\n            writer.println(\"Document Title: \" + title);\r\n\r\n            // Test extracting headings\r\n            Elements headings \u003d HtmlParser.getHeadings(document);\r\n            assertFalse(headings.isEmpty(), \"There should be at least one heading\");\r\n\r\n            // Print headings\r\n            System.out.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            for (Element heading : headings) {\r\n                System.out.println(heading.tagName() + \": \" + heading.text());\r\n                writer.println(heading.tagName() + \": \" + heading.text());\r\n            }\r\n\r\n            // Test extracting links\r\n            Elements links \u003d HtmlParser.getLinks(document);\r\n            assertFalse(links.isEmpty(), \"There should be at least one link\");\r\n\r\n            // Print links\r\n            System.out.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            for (Element link : links) {\r\n                System.out.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n                writer.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n            }\r\n\r\n            // Test metadata extraction\r\n            Map\u003cString, String\u003e metadata \u003d HtmlParser.getMetadata(document);\r\n            assertNotNull(metadata, \"Metadata should not be null\");\r\n            assertTrue(metadata.containsKey(\"title\"), \"Metadata should contain title\");\r\n\r\n            // Print metadata\r\n            System.out.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, String\u003e entry : metadata.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                writer.println(entry.getKey() + \": \" + entry.getValue());\r\n            }\r\n\r\n            // Test tables\r\n            Elements tables \u003d HtmlParser.getTables(document);\r\n\r\n            // Print tables\r\n            System.out.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            for (Element table : tables) {\r\n                System.out.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n                writer.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n\r\n                // Extract table data as array\r\n                String[][] tableData \u003d HtmlParser.tableToArray(table);\r\n                for (String[] row : tableData) {\r\n                    for (String cell : row) {\r\n                        System.out.print(cell + \"\\t| \");\r\n                        writer.print(cell + \"\\t| \");\r\n                    }\r\n                    System.out.println();\r\n                    writer.println();\r\n                }\r\n\r\n                // Extract table as maps\r\n                Map\u003cString, String\u003e[] tableMaps \u003d HtmlParser.tableToMaps(table);\r\n                System.out.println(\"\\nTable as Maps:\");\r\n                writer.println(\"\\nTable as Maps:\");\r\n                for (Map\u003cString, String\u003e row : tableMaps) {\r\n                    System.out.println(row);\r\n                    writer.println(row);\r\n                }\r\n            }\r\n\r\n            // Test images\r\n            Elements images \u003d HtmlParser.getImages(document);\r\n\r\n            // Print images\r\n            System.out.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            for (Element image : images) {\r\n                System.out.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n                writer.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n            }\r\n\r\n            // Test lists\r\n            Elements lists \u003d HtmlParser.getLists(document);\r\n\r\n            // Print lists\r\n            System.out.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            for (Element list : lists) {\r\n                System.out.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                writer.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                for (Element item : list.select(\"li\")) {\r\n                    System.out.println(\"- \" + item.text());\r\n                    writer.println(\"- \" + item.text());\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nHTML parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }\r\n    }",
          "comments": [
            "Set up the test HTML file location"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        // Create output file writer\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            // Parse the HTML file\r\n            Document document \u003d HtmlParser.parse(testHtmlFile, \"UTF-8\", \"\");\r\n\r\n            // Test basic HTML parsing\r\n            assertNotNull(document, \"Document should not be null\");\r\n            String title \u003d document.title();\r\n            assertEquals(\"Test HTML Document\", title, \"Document title should match\");\r\n\r\n            // Print document title\r\n            System.out.println(\"Document Title: \" + title);\r\n            writer.println(\"Document Title: \" + title);\r\n\r\n            // Test extracting headings\r\n            Elements headings \u003d HtmlParser.getHeadings(document);\r\n            assertFalse(headings.isEmpty(), \"There should be at least one heading\");\r\n\r\n            // Print headings\r\n            System.out.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            for (Element heading : headings) {\r\n                System.out.println(heading.tagName() + \": \" + heading.text());\r\n                writer.println(heading.tagName() + \": \" + heading.text());\r\n            }\r\n\r\n            // Test extracting links\r\n            Elements links \u003d HtmlParser.getLinks(document);\r\n            assertFalse(links.isEmpty(), \"There should be at least one link\");\r\n\r\n            // Print links\r\n            System.out.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            for (Element link : links) {\r\n                System.out.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n                writer.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n            }\r\n\r\n            // Test metadata extraction\r\n            Map\u003cString, String\u003e metadata \u003d HtmlParser.getMetadata(document);\r\n            assertNotNull(metadata, \"Metadata should not be null\");\r\n            assertTrue(metadata.containsKey(\"title\"), \"Metadata should contain title\");\r\n\r\n            // Print metadata\r\n            System.out.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, String\u003e entry : metadata.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                writer.println(entry.getKey() + \": \" + entry.getValue());\r\n            }\r\n\r\n            // Test tables\r\n            Elements tables \u003d HtmlParser.getTables(document);\r\n\r\n            // Print tables\r\n            System.out.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            for (Element table : tables) {\r\n                System.out.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n                writer.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n\r\n                // Extract table data as array\r\n                String[][] tableData \u003d HtmlParser.tableToArray(table);\r\n                for (String[] row : tableData) {\r\n                    for (String cell : row) {\r\n                        System.out.print(cell + \"\\t| \");\r\n                        writer.print(cell + \"\\t| \");\r\n                    }\r\n                    System.out.println();\r\n                    writer.println();\r\n                }\r\n\r\n                // Extract table as maps\r\n                Map\u003cString, String\u003e[] tableMaps \u003d HtmlParser.tableToMaps(table);\r\n                System.out.println(\"\\nTable as Maps:\");\r\n                writer.println(\"\\nTable as Maps:\");\r\n                for (Map\u003cString, String\u003e row : tableMaps) {\r\n                    System.out.println(row);\r\n                    writer.println(row);\r\n                }\r\n            }\r\n\r\n            // Test images\r\n            Elements images \u003d HtmlParser.getImages(document);\r\n\r\n            // Print images\r\n            System.out.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            for (Element image : images) {\r\n                System.out.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n                writer.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n            }\r\n\r\n            // Test lists\r\n            Elements lists \u003d HtmlParser.getLists(document);\r\n\r\n            // Print lists\r\n            System.out.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            for (Element list : lists) {\r\n                System.out.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                writer.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                for (Element item : list.select(\"li\")) {\r\n                    System.out.println(\"- \" + item.text());\r\n                    writer.println(\"- \" + item.text());\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nHTML parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }\r\n    }",
          "comments": [
            "Set up output file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseAndExtractElements",
          "parameters": [],
          "body": "{\r\n        // Create output file writer\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            // Parse the HTML file\r\n            Document document \u003d HtmlParser.parse(testHtmlFile, \"UTF-8\", \"\");\r\n\r\n            // Test basic HTML parsing\r\n            assertNotNull(document, \"Document should not be null\");\r\n            String title \u003d document.title();\r\n            assertEquals(\"Test HTML Document\", title, \"Document title should match\");\r\n\r\n            // Print document title\r\n            System.out.println(\"Document Title: \" + title);\r\n            writer.println(\"Document Title: \" + title);\r\n\r\n            // Test extracting headings\r\n            Elements headings \u003d HtmlParser.getHeadings(document);\r\n            assertFalse(headings.isEmpty(), \"There should be at least one heading\");\r\n\r\n            // Print headings\r\n            System.out.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            for (Element heading : headings) {\r\n                System.out.println(heading.tagName() + \": \" + heading.text());\r\n                writer.println(heading.tagName() + \": \" + heading.text());\r\n            }\r\n\r\n            // Test extracting links\r\n            Elements links \u003d HtmlParser.getLinks(document);\r\n            assertFalse(links.isEmpty(), \"There should be at least one link\");\r\n\r\n            // Print links\r\n            System.out.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            for (Element link : links) {\r\n                System.out.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n                writer.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n            }\r\n\r\n            // Test metadata extraction\r\n            Map\u003cString, String\u003e metadata \u003d HtmlParser.getMetadata(document);\r\n            assertNotNull(metadata, \"Metadata should not be null\");\r\n            assertTrue(metadata.containsKey(\"title\"), \"Metadata should contain title\");\r\n\r\n            // Print metadata\r\n            System.out.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, String\u003e entry : metadata.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                writer.println(entry.getKey() + \": \" + entry.getValue());\r\n            }\r\n\r\n            // Test tables\r\n            Elements tables \u003d HtmlParser.getTables(document);\r\n\r\n            // Print tables\r\n            System.out.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            for (Element table : tables) {\r\n                System.out.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n                writer.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n\r\n                // Extract table data as array\r\n                String[][] tableData \u003d HtmlParser.tableToArray(table);\r\n                for (String[] row : tableData) {\r\n                    for (String cell : row) {\r\n                        System.out.print(cell + \"\\t| \");\r\n                        writer.print(cell + \"\\t| \");\r\n                    }\r\n                    System.out.println();\r\n                    writer.println();\r\n                }\r\n\r\n                // Extract table as maps\r\n                Map\u003cString, String\u003e[] tableMaps \u003d HtmlParser.tableToMaps(table);\r\n                System.out.println(\"\\nTable as Maps:\");\r\n                writer.println(\"\\nTable as Maps:\");\r\n                for (Map\u003cString, String\u003e row : tableMaps) {\r\n                    System.out.println(row);\r\n                    writer.println(row);\r\n                }\r\n            }\r\n\r\n            // Test images\r\n            Elements images \u003d HtmlParser.getImages(document);\r\n\r\n            // Print images\r\n            System.out.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            for (Element image : images) {\r\n                System.out.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n                writer.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n            }\r\n\r\n            // Test lists\r\n            Elements lists \u003d HtmlParser.getLists(document);\r\n\r\n            // Print lists\r\n            System.out.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            for (Element list : lists) {\r\n                System.out.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                writer.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                for (Element item : list.select(\"li\")) {\r\n                    System.out.println(\"- \" + item.text());\r\n                    writer.println(\"- \" + item.text());\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nHTML parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }\r\n    }",
          "comments": [
            "Set up output file",
            "Create output file writer"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "writer",
          "methodName": "try",
          "parameters": [
            {
              "type": "PrintWriter",
              "name": "writer"
            }
          ],
          "body": "{\r\n            // Parse the HTML file\r\n            Document document \u003d HtmlParser.parse(testHtmlFile, \"UTF-8\", \"\");\r\n\r\n            // Test basic HTML parsing\r\n            assertNotNull(document, \"Document should not be null\");\r\n            String title \u003d document.title();\r\n            assertEquals(\"Test HTML Document\", title, \"Document title should match\");\r\n\r\n            // Print document title\r\n            System.out.println(\"Document Title: \" + title);\r\n            writer.println(\"Document Title: \" + title);\r\n\r\n            // Test extracting headings\r\n            Elements headings \u003d HtmlParser.getHeadings(document);\r\n            assertFalse(headings.isEmpty(), \"There should be at least one heading\");\r\n\r\n            // Print headings\r\n            System.out.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d HEADINGS \u003d\u003d\u003d\");\r\n            for (Element heading : headings) {\r\n                System.out.println(heading.tagName() + \": \" + heading.text());\r\n                writer.println(heading.tagName() + \": \" + heading.text());\r\n            }\r\n\r\n            // Test extracting links\r\n            Elements links \u003d HtmlParser.getLinks(document);\r\n            assertFalse(links.isEmpty(), \"There should be at least one link\");\r\n\r\n            // Print links\r\n            System.out.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LINKS \u003d\u003d\u003d\");\r\n            for (Element link : links) {\r\n                System.out.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n                writer.println(\"Link: \" + link.text() + \" -\u003e \" + link.attr(\"href\"));\r\n            }\r\n\r\n            // Test metadata extraction\r\n            Map\u003cString, String\u003e metadata \u003d HtmlParser.getMetadata(document);\r\n            assertNotNull(metadata, \"Metadata should not be null\");\r\n            assertTrue(metadata.containsKey(\"title\"), \"Metadata should contain title\");\r\n\r\n            // Print metadata\r\n            System.out.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METADATA \u003d\u003d\u003d\");\r\n            for (Map.Entry\u003cString, String\u003e entry : metadata.entrySet()) {\r\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\r\n                writer.println(entry.getKey() + \": \" + entry.getValue());\r\n            }\r\n\r\n            // Test tables\r\n            Elements tables \u003d HtmlParser.getTables(document);\r\n\r\n            // Print tables\r\n            System.out.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d TABLES \u003d\u003d\u003d\");\r\n            for (Element table : tables) {\r\n                System.out.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n                writer.println(\"Table found with \" + table.select(\"tr\").size() + \" rows\");\r\n\r\n                // Extract table data as array\r\n                String[][] tableData \u003d HtmlParser.tableToArray(table);\r\n                for (String[] row : tableData) {\r\n                    for (String cell : row) {\r\n                        System.out.print(cell + \"\\t| \");\r\n                        writer.print(cell + \"\\t| \");\r\n                    }\r\n                    System.out.println();\r\n                    writer.println();\r\n                }\r\n\r\n                // Extract table as maps\r\n                Map\u003cString, String\u003e[] tableMaps \u003d HtmlParser.tableToMaps(table);\r\n                System.out.println(\"\\nTable as Maps:\");\r\n                writer.println(\"\\nTable as Maps:\");\r\n                for (Map\u003cString, String\u003e row : tableMaps) {\r\n                    System.out.println(row);\r\n                    writer.println(row);\r\n                }\r\n            }\r\n\r\n            // Test images\r\n            Elements images \u003d HtmlParser.getImages(document);\r\n\r\n            // Print images\r\n            System.out.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d IMAGES \u003d\u003d\u003d\");\r\n            for (Element image : images) {\r\n                System.out.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n                writer.println(\"Image: \" + image.attr(\"src\") + \" (Alt: \" + image.attr(\"alt\") + \")\");\r\n            }\r\n\r\n            // Test lists\r\n            Elements lists \u003d HtmlParser.getLists(document);\r\n\r\n            // Print lists\r\n            System.out.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d LISTS \u003d\u003d\u003d\");\r\n            for (Element list : lists) {\r\n                System.out.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                writer.println(list.tagName() + \" with \" + list.select(\"li\").size() + \" items:\");\r\n                for (Element item : list.select(\"li\")) {\r\n                    System.out.println(\"- \" + item.text());\r\n                    writer.println(\"- \" + item.text());\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nHTML parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }",
          "comments": [
            "Create output file writer"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parsing",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Document",
              "name": "should"
            }
          ],
          "body": "{\r\n                System.out.println(heading.tagName() + \": \" + heading.text());\r\n                writer.println(heading.tagName() + \": \" + heading.text());\r\n            }",
          "comments": [
            "Parse the HTML file",
            "Test basic HTML parsing"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testExtractingTextContent",
          "parameters": [],
          "body": "{\r\n        // Parse the HTML file\r\n        Document document \u003d HtmlParser.parse(testHtmlFile, \"UTF-8\", \"\");\r\n\r\n        // Test extracting text content\r\n        String textContent \u003d HtmlParser.getTextContent(document);\r\n        assertNotNull(textContent, \"Text content should not be null\");\r\n        assertFalse(textContent.isEmpty(), \"Text content should not be empty\");\r\n\r\n        // Print text content\r\n        System.out.println(\"\\n\u003d\u003d\u003d FULL TEXT CONTENT \u003d\u003d\u003d\");\r\n        System.out.println(textContent);\r\n\r\n        // Write to file\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            writer.println(\"\\n\u003d\u003d\u003d FULL TEXT CONTENT \u003d\u003d\u003d\");\r\n            writer.println(textContent);\r\n        }\r\n    }",
          "comments": [
            "Parse the HTML file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "file",
          "methodName": "try",
          "parameters": [
            {
              "type": "PrintWriter",
              "name": "writer"
            }
          ],
          "body": "{\r\n            writer.println(\"\\n\u003d\u003d\u003d FULL TEXT CONTENT \u003d\u003d\u003d\");\r\n            writer.println(textContent);\r\n        }",
          "comments": [
            "Print text content",
            "Write to file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testCssSelectors",
          "parameters": [],
          "body": "{\r\n        // Parse the HTML file\r\n        Document document \u003d HtmlParser.parse(testHtmlFile, \"UTF-8\", \"\");\r\n\r\n        // Write to file\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            // Test using CSS selectors\r\n            Elements paragraphs \u003d HtmlParser.select(document, \"p\");\r\n            assertFalse(paragraphs.isEmpty(), \"There should be at least one paragraph\");\r\n\r\n            // Print paragraphs\r\n            System.out.println(\"\\n\u003d\u003d\u003d PARAGRAPHS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d PARAGRAPHS \u003d\u003d\u003d\");\r\n            for (Element p : paragraphs) {\r\n                System.out.println(p.text());\r\n                writer.println(p.text());\r\n            }\r\n\r\n            // Test custom selectors\r\n            Elements containerDiv \u003d HtmlParser.select(document, \"div.container\");\r\n\r\n            // Print container info\r\n            System.out.println(\"\\n\u003d\u003d\u003d CONTAINER DIV \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CONTAINER DIV \u003d\u003d\u003d\");\r\n            if (!containerDiv.isEmpty()) {\r\n                System.out.println(\"Container found with \" + containerDiv.first().children().size() + \" child elements\");\r\n                writer.println(\"Container found with \" + containerDiv.first().children().size() + \" child elements\");\r\n            }\r\n\r\n            // Test checking if elements exist\r\n            boolean hasDivs \u003d HtmlParser.exists(document, \"div\");\r\n            boolean hasForm \u003d HtmlParser.exists(document, \"form\");\r\n\r\n            System.out.println(\"\\n\u003d\u003d\u003d ELEMENT EXISTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d ELEMENT EXISTS \u003d\u003d\u003d\");\r\n            System.out.println(\"Has divs: \" + hasDivs);\r\n            writer.println(\"Has divs: \" + hasDivs);\r\n            System.out.println(\"Has forms: \" + hasForm);\r\n            writer.println(\"Has forms: \" + hasForm);\r\n        }\r\n    }",
          "comments": [
            "Parse the HTML file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "file",
          "methodName": "try",
          "parameters": [
            {
              "type": "PrintWriter",
              "name": "writer"
            }
          ],
          "body": "{\r\n            writer.println(\"\\n\u003d\u003d\u003d FULL TEXT CONTENT \u003d\u003d\u003d\");\r\n            writer.println(textContent);\r\n        }",
          "comments": [
            "Parse the HTML file",
            "Write to file"
          ]
        }
      ],
      "className": "HtmlParserTest",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/test/java/io/joshuasalcedo/parsers/JavaParserTest.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "setUp",
          "parameters": [],
          "body": "{\r\n        // Set up the test Java file location\r\n        testJavaFile \u003d new File(\"src/test/resources/test/java/TestSample.java\");\r\n        assertTrue(testJavaFile.exists(), \"Test Java file does not exist\");\r\n\r\n        // Set up output file\r\n        outputFile \u003d new File(\"src/test/resources/test/java/java-parser-output.txt\");\r\n    }",
          "comments": [
            "Set up the test Java file location"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            // Read the Java file content\r\n            String content \u003d new String(Files.readAllBytes(testJavaFile.toPath()));\r\n\r\n            // Extract package name\r\n            String packageName \u003d JavaParser.extractPackageName(content);\r\n            System.out.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            System.out.println(packageName);\r\n            writer.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            writer.println(packageName);\r\n\r\n            // Extract class JavaDoc\r\n            JavadocStructure classJavadoc \u003d JavaParser.extractClassJavadoc(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            if (classJavadoc !\u003d null) {\r\n                System.out.println(\"Description: \" + classJavadoc.getDescription());\r\n                writer.println(\"Description: \" + classJavadoc.getDescription());\r\n\r\n                System.out.println(\"\\nJavaDoc Tags:\");\r\n                writer.println(\"\\nJavaDoc Tags:\");\r\n                for (JavadocTag tag : classJavadoc.getTags()) {\r\n                    System.out.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                    writer.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                }\r\n            } else {\r\n                System.out.println(\"No class JavaDoc found\");\r\n                writer.println(\"No class JavaDoc found\");\r\n            }\r\n\r\n            // Extract class comments\r\n            List\u003cString\u003e classComments \u003d JavaParser.extractClassComments(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            if (!classComments.isEmpty()) {\r\n                for (String comment : classComments) {\r\n                    System.out.println(comment);\r\n                    writer.println(comment);\r\n                }\r\n            } else {\r\n                System.out.println(\"No class comments found\");\r\n                writer.println(\"No class comments found\");\r\n            }\r\n\r\n            // Extract class structure\r\n            ClassStructure classStructure \u003d JavaParser.extractClassStructure(testJavaFile.getName(), content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            System.out.println(\"File Name: \" + classStructure.getFileName());\r\n            System.out.println(\"Package Name: \" + classStructure.getPackageName());\r\n            System.out.println(\"Class Name: \" + classStructure.getClassName());\r\n            System.out.println(\"Class Type: \" + classStructure.getClassType());\r\n            writer.println(\"File Name: \" + classStructure.getFileName());\r\n            writer.println(\"Package Name: \" + classStructure.getPackageName());\r\n            writer.println(\"Class Name: \" + classStructure.getClassName());\r\n            writer.println(\"Class Type: \" + classStructure.getClassType());\r\n\r\n            // Extract methods\r\n            List\u003cMethodStructure\u003e methods \u003d JavaParser.extractMethods(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + methods.size() + \" methods:\");\r\n            writer.println(\"Found \" + methods.size() + \" methods:\");\r\n\r\n            for (MethodStructure method : methods) {\r\n                System.out.println(\"\\nMethod: \" + method.getMethodName());\r\n                System.out.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                System.out.println(\"Static: \" + method.isStatic());\r\n                System.out.println(\"Return Type: \" + method.getReturnType());\r\n                System.out.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                writer.println(\"\\nMethod: \" + method.getMethodName());\r\n                writer.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                writer.println(\"Static: \" + method.isStatic());\r\n                writer.println(\"Return Type: \" + method.getReturnType());\r\n                writer.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                // Print parameters\r\n                if (!method.getParameters().isEmpty()) {\r\n                    System.out.println(\"Parameter list:\");\r\n                    writer.println(\"Parameter list:\");\r\n                    method.getParameters().forEach(param -\u003e {\r\n                        System.out.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                        writer.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                    });\r\n                }\r\n\r\n                // Print method JavaDoc if available\r\n                if (method.getJavadoc() !\u003d null) {\r\n                    System.out.println(\"Method JavaDoc:\");\r\n                    writer.println(\"Method JavaDoc:\");\r\n                    System.out.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n                    writer.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n\r\n                    if (!method.getJavadoc().getTags().isEmpty()) {\r\n                        System.out.println(\"  Tags:\");\r\n                        writer.println(\"  Tags:\");\r\n                        method.getJavadoc().getTags().forEach(tag -\u003e {\r\n                            System.out.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                            writer.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // Print method body (truncated for readability)\r\n                if (method.getBody() !\u003d null \u0026\u0026 !method.getBody().isEmpty()) {\r\n                    String bodyPreview \u003d method.getBody().length() \u003e 100\r\n                            ? method.getBody().substring(0, 100) + \"...\"\r\n                            : method.getBody();\r\n                    System.out.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                    writer.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nJava parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }\r\n    }",
          "comments": [
            "Set up the test Java file location"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            // Read the Java file content\r\n            String content \u003d new String(Files.readAllBytes(testJavaFile.toPath()));\r\n\r\n            // Extract package name\r\n            String packageName \u003d JavaParser.extractPackageName(content);\r\n            System.out.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            System.out.println(packageName);\r\n            writer.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            writer.println(packageName);\r\n\r\n            // Extract class JavaDoc\r\n            JavadocStructure classJavadoc \u003d JavaParser.extractClassJavadoc(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            if (classJavadoc !\u003d null) {\r\n                System.out.println(\"Description: \" + classJavadoc.getDescription());\r\n                writer.println(\"Description: \" + classJavadoc.getDescription());\r\n\r\n                System.out.println(\"\\nJavaDoc Tags:\");\r\n                writer.println(\"\\nJavaDoc Tags:\");\r\n                for (JavadocTag tag : classJavadoc.getTags()) {\r\n                    System.out.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                    writer.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                }\r\n            } else {\r\n                System.out.println(\"No class JavaDoc found\");\r\n                writer.println(\"No class JavaDoc found\");\r\n            }\r\n\r\n            // Extract class comments\r\n            List\u003cString\u003e classComments \u003d JavaParser.extractClassComments(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            if (!classComments.isEmpty()) {\r\n                for (String comment : classComments) {\r\n                    System.out.println(comment);\r\n                    writer.println(comment);\r\n                }\r\n            } else {\r\n                System.out.println(\"No class comments found\");\r\n                writer.println(\"No class comments found\");\r\n            }\r\n\r\n            // Extract class structure\r\n            ClassStructure classStructure \u003d JavaParser.extractClassStructure(testJavaFile.getName(), content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            System.out.println(\"File Name: \" + classStructure.getFileName());\r\n            System.out.println(\"Package Name: \" + classStructure.getPackageName());\r\n            System.out.println(\"Class Name: \" + classStructure.getClassName());\r\n            System.out.println(\"Class Type: \" + classStructure.getClassType());\r\n            writer.println(\"File Name: \" + classStructure.getFileName());\r\n            writer.println(\"Package Name: \" + classStructure.getPackageName());\r\n            writer.println(\"Class Name: \" + classStructure.getClassName());\r\n            writer.println(\"Class Type: \" + classStructure.getClassType());\r\n\r\n            // Extract methods\r\n            List\u003cMethodStructure\u003e methods \u003d JavaParser.extractMethods(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + methods.size() + \" methods:\");\r\n            writer.println(\"Found \" + methods.size() + \" methods:\");\r\n\r\n            for (MethodStructure method : methods) {\r\n                System.out.println(\"\\nMethod: \" + method.getMethodName());\r\n                System.out.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                System.out.println(\"Static: \" + method.isStatic());\r\n                System.out.println(\"Return Type: \" + method.getReturnType());\r\n                System.out.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                writer.println(\"\\nMethod: \" + method.getMethodName());\r\n                writer.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                writer.println(\"Static: \" + method.isStatic());\r\n                writer.println(\"Return Type: \" + method.getReturnType());\r\n                writer.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                // Print parameters\r\n                if (!method.getParameters().isEmpty()) {\r\n                    System.out.println(\"Parameter list:\");\r\n                    writer.println(\"Parameter list:\");\r\n                    method.getParameters().forEach(param -\u003e {\r\n                        System.out.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                        writer.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                    });\r\n                }\r\n\r\n                // Print method JavaDoc if available\r\n                if (method.getJavadoc() !\u003d null) {\r\n                    System.out.println(\"Method JavaDoc:\");\r\n                    writer.println(\"Method JavaDoc:\");\r\n                    System.out.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n                    writer.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n\r\n                    if (!method.getJavadoc().getTags().isEmpty()) {\r\n                        System.out.println(\"  Tags:\");\r\n                        writer.println(\"  Tags:\");\r\n                        method.getJavadoc().getTags().forEach(tag -\u003e {\r\n                            System.out.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                            writer.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // Print method body (truncated for readability)\r\n                if (method.getBody() !\u003d null \u0026\u0026 !method.getBody().isEmpty()) {\r\n                    String bodyPreview \u003d method.getBody().length() \u003e 100\r\n                            ? method.getBody().substring(0, 100) + \"...\"\r\n                            : method.getBody();\r\n                    System.out.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                    writer.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nJava parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }\r\n    }",
          "comments": [
            "Set up output file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseJavaFile",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            // Read the Java file content\r\n            String content \u003d new String(Files.readAllBytes(testJavaFile.toPath()));\r\n\r\n            // Extract package name\r\n            String packageName \u003d JavaParser.extractPackageName(content);\r\n            System.out.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            System.out.println(packageName);\r\n            writer.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            writer.println(packageName);\r\n\r\n            // Extract class JavaDoc\r\n            JavadocStructure classJavadoc \u003d JavaParser.extractClassJavadoc(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            if (classJavadoc !\u003d null) {\r\n                System.out.println(\"Description: \" + classJavadoc.getDescription());\r\n                writer.println(\"Description: \" + classJavadoc.getDescription());\r\n\r\n                System.out.println(\"\\nJavaDoc Tags:\");\r\n                writer.println(\"\\nJavaDoc Tags:\");\r\n                for (JavadocTag tag : classJavadoc.getTags()) {\r\n                    System.out.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                    writer.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                }\r\n            } else {\r\n                System.out.println(\"No class JavaDoc found\");\r\n                writer.println(\"No class JavaDoc found\");\r\n            }\r\n\r\n            // Extract class comments\r\n            List\u003cString\u003e classComments \u003d JavaParser.extractClassComments(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            if (!classComments.isEmpty()) {\r\n                for (String comment : classComments) {\r\n                    System.out.println(comment);\r\n                    writer.println(comment);\r\n                }\r\n            } else {\r\n                System.out.println(\"No class comments found\");\r\n                writer.println(\"No class comments found\");\r\n            }\r\n\r\n            // Extract class structure\r\n            ClassStructure classStructure \u003d JavaParser.extractClassStructure(testJavaFile.getName(), content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            System.out.println(\"File Name: \" + classStructure.getFileName());\r\n            System.out.println(\"Package Name: \" + classStructure.getPackageName());\r\n            System.out.println(\"Class Name: \" + classStructure.getClassName());\r\n            System.out.println(\"Class Type: \" + classStructure.getClassType());\r\n            writer.println(\"File Name: \" + classStructure.getFileName());\r\n            writer.println(\"Package Name: \" + classStructure.getPackageName());\r\n            writer.println(\"Class Name: \" + classStructure.getClassName());\r\n            writer.println(\"Class Type: \" + classStructure.getClassType());\r\n\r\n            // Extract methods\r\n            List\u003cMethodStructure\u003e methods \u003d JavaParser.extractMethods(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + methods.size() + \" methods:\");\r\n            writer.println(\"Found \" + methods.size() + \" methods:\");\r\n\r\n            for (MethodStructure method : methods) {\r\n                System.out.println(\"\\nMethod: \" + method.getMethodName());\r\n                System.out.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                System.out.println(\"Static: \" + method.isStatic());\r\n                System.out.println(\"Return Type: \" + method.getReturnType());\r\n                System.out.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                writer.println(\"\\nMethod: \" + method.getMethodName());\r\n                writer.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                writer.println(\"Static: \" + method.isStatic());\r\n                writer.println(\"Return Type: \" + method.getReturnType());\r\n                writer.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                // Print parameters\r\n                if (!method.getParameters().isEmpty()) {\r\n                    System.out.println(\"Parameter list:\");\r\n                    writer.println(\"Parameter list:\");\r\n                    method.getParameters().forEach(param -\u003e {\r\n                        System.out.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                        writer.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                    });\r\n                }\r\n\r\n                // Print method JavaDoc if available\r\n                if (method.getJavadoc() !\u003d null) {\r\n                    System.out.println(\"Method JavaDoc:\");\r\n                    writer.println(\"Method JavaDoc:\");\r\n                    System.out.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n                    writer.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n\r\n                    if (!method.getJavadoc().getTags().isEmpty()) {\r\n                        System.out.println(\"  Tags:\");\r\n                        writer.println(\"  Tags:\");\r\n                        method.getJavadoc().getTags().forEach(tag -\u003e {\r\n                            System.out.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                            writer.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // Print method body (truncated for readability)\r\n                if (method.getBody() !\u003d null \u0026\u0026 !method.getBody().isEmpty()) {\r\n                    String bodyPreview \u003d method.getBody().length() \u003e 100\r\n                            ? method.getBody().substring(0, 100) + \"...\"\r\n                            : method.getBody();\r\n                    System.out.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                    writer.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nJava parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }\r\n    }",
          "comments": [
            "Set up output file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            // Read the Java file content\r\n            String content \u003d new String(Files.readAllBytes(testJavaFile.toPath()));\r\n\r\n            // Extract package name\r\n            String packageName \u003d JavaParser.extractPackageName(content);\r\n            System.out.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            System.out.println(packageName);\r\n            writer.println(\"\u003d\u003d\u003d PACKAGE NAME \u003d\u003d\u003d\");\r\n            writer.println(packageName);\r\n\r\n            // Extract class JavaDoc\r\n            JavadocStructure classJavadoc \u003d JavaParser.extractClassJavadoc(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS JAVADOC \u003d\u003d\u003d\");\r\n            if (classJavadoc !\u003d null) {\r\n                System.out.println(\"Description: \" + classJavadoc.getDescription());\r\n                writer.println(\"Description: \" + classJavadoc.getDescription());\r\n\r\n                System.out.println(\"\\nJavaDoc Tags:\");\r\n                writer.println(\"\\nJavaDoc Tags:\");\r\n                for (JavadocTag tag : classJavadoc.getTags()) {\r\n                    System.out.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                    writer.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                }\r\n            } else {\r\n                System.out.println(\"No class JavaDoc found\");\r\n                writer.println(\"No class JavaDoc found\");\r\n            }\r\n\r\n            // Extract class comments\r\n            List\u003cString\u003e classComments \u003d JavaParser.extractClassComments(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS COMMENTS \u003d\u003d\u003d\");\r\n            if (!classComments.isEmpty()) {\r\n                for (String comment : classComments) {\r\n                    System.out.println(comment);\r\n                    writer.println(comment);\r\n                }\r\n            } else {\r\n                System.out.println(\"No class comments found\");\r\n                writer.println(\"No class comments found\");\r\n            }\r\n\r\n            // Extract class structure\r\n            ClassStructure classStructure \u003d JavaParser.extractClassStructure(testJavaFile.getName(), content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d CLASS STRUCTURE \u003d\u003d\u003d\");\r\n            System.out.println(\"File Name: \" + classStructure.getFileName());\r\n            System.out.println(\"Package Name: \" + classStructure.getPackageName());\r\n            System.out.println(\"Class Name: \" + classStructure.getClassName());\r\n            System.out.println(\"Class Type: \" + classStructure.getClassType());\r\n            writer.println(\"File Name: \" + classStructure.getFileName());\r\n            writer.println(\"Package Name: \" + classStructure.getPackageName());\r\n            writer.println(\"Class Name: \" + classStructure.getClassName());\r\n            writer.println(\"Class Type: \" + classStructure.getClassType());\r\n\r\n            // Extract methods\r\n            List\u003cMethodStructure\u003e methods \u003d JavaParser.extractMethods(content);\r\n            System.out.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d METHODS \u003d\u003d\u003d\");\r\n            System.out.println(\"Found \" + methods.size() + \" methods:\");\r\n            writer.println(\"Found \" + methods.size() + \" methods:\");\r\n\r\n            for (MethodStructure method : methods) {\r\n                System.out.println(\"\\nMethod: \" + method.getMethodName());\r\n                System.out.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                System.out.println(\"Static: \" + method.isStatic());\r\n                System.out.println(\"Return Type: \" + method.getReturnType());\r\n                System.out.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                writer.println(\"\\nMethod: \" + method.getMethodName());\r\n                writer.println(\"Access Modifier: \" + method.getAccessModifier());\r\n                writer.println(\"Static: \" + method.isStatic());\r\n                writer.println(\"Return Type: \" + method.getReturnType());\r\n                writer.println(\"Parameters: \" + method.getParameters().size());\r\n\r\n                // Print parameters\r\n                if (!method.getParameters().isEmpty()) {\r\n                    System.out.println(\"Parameter list:\");\r\n                    writer.println(\"Parameter list:\");\r\n                    method.getParameters().forEach(param -\u003e {\r\n                        System.out.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                        writer.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                    });\r\n                }\r\n\r\n                // Print method JavaDoc if available\r\n                if (method.getJavadoc() !\u003d null) {\r\n                    System.out.println(\"Method JavaDoc:\");\r\n                    writer.println(\"Method JavaDoc:\");\r\n                    System.out.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n                    writer.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n\r\n                    if (!method.getJavadoc().getTags().isEmpty()) {\r\n                        System.out.println(\"  Tags:\");\r\n                        writer.println(\"  Tags:\");\r\n                        method.getJavadoc().getTags().forEach(tag -\u003e {\r\n                            System.out.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                            writer.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // Print method body (truncated for readability)\r\n                if (method.getBody() !\u003d null \u0026\u0026 !method.getBody().isEmpty()) {\r\n                    String bodyPreview \u003d method.getBody().length() \u003e 100\r\n                            ? method.getBody().substring(0, 100) + \"...\"\r\n                            : method.getBody();\r\n                    System.out.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                    writer.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\\nJava parsing test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        }",
          "comments": [
            "Read the Java file content"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "String",
          "parameters": [],
          "body": "{\r\n                System.out.println(\"Description: \" + classJavadoc.getDescription());\r\n                writer.println(\"Description: \" + classJavadoc.getDescription());\r\n\r\n                System.out.println(\"\\nJavaDoc Tags:\");\r\n                writer.println(\"\\nJavaDoc Tags:\");\r\n                for (JavadocTag tag : classJavadoc.getTags()) {\r\n                    System.out.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                    writer.println(\"@\" + tag.getName() + \" \" + tag.getValue());\r\n                }\r\n            }",
          "comments": [
            "Read the Java file content",
            "Extract package name"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parameters",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    System.out.println(\"Parameter list:\");\r\n                    writer.println(\"Parameter list:\");\r\n                    method.getParameters().forEach(param -\u003e {\r\n                        System.out.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                        writer.println(\"  - \" + param.getType() + \" \" + param.getName());\r\n                    });\r\n                }",
          "comments": [
            "Print parameters"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    System.out.println(\"Method JavaDoc:\");\r\n                    writer.println(\"Method JavaDoc:\");\r\n                    System.out.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n                    writer.println(\"  Description: \" + method.getJavadoc().getDescription());\r\n\r\n                    if (!method.getJavadoc().getTags().isEmpty()) {\r\n                        System.out.println(\"  Tags:\");\r\n                        writer.println(\"  Tags:\");\r\n                        method.getJavadoc().getTags().forEach(tag -\u003e {\r\n                            System.out.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                            writer.println(\"    @\" + tag.getName() + \" \" + tag.getValue());\r\n                        });\r\n                    }\r\n                }",
          "comments": [
            "Print method JavaDoc if available"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "method",
          "methodName": "body",
          "parameters": [
            {
              "type": "truncated",
              "name": "for"
            }
          ],
          "body": "{\r\n                    String bodyPreview \u003d method.getBody().length() \u003e 100\r\n                            ? method.getBody().substring(0, 100) + \"...\"\r\n                            : method.getBody();\r\n                    System.out.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                    writer.println(\"Body preview: \" + bodyPreview.replace(\"\\n\", \" \"));\r\n                }",
          "comments": [
            "Print method body (truncated for readability)"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testFindJavaFiles",
          "parameters": [],
          "body": "{\r\n        File testDir \u003d new File(\"src/test/resources/test/java\");\r\n        List\u003cFile\u003e javaFiles \u003d JavaParser.findJavaFiles(testDir);\r\n\r\n        System.out.println(\"\\n\u003d\u003d\u003d JAVA FILES IN DIRECTORY \u003d\u003d\u003d\");\r\n        System.out.println(\"Found \" + javaFiles.size() + \" Java files:\");\r\n\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            writer.println(\"\\n\u003d\u003d\u003d JAVA FILES IN DIRECTORY \u003d\u003d\u003d\");\r\n            writer.println(\"Found \" + javaFiles.size() + \" Java files:\");\r\n\r\n            for (File file : javaFiles) {\r\n                System.out.println(file.getName());\r\n                writer.println(file.getName());\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }",
          "comments": [
            "Optional: Add test for finding all Java files in a directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n            writer.println(\"\\n\u003d\u003d\u003d JAVA FILES IN DIRECTORY \u003d\u003d\u003d\");\r\n            writer.println(\"Found \" + javaFiles.size() + \" Java files:\");\r\n\r\n            for (File file : javaFiles) {\r\n                System.out.println(file.getName());\r\n                writer.println(file.getName());\r\n            }\r\n        }",
          "comments": [
            "Optional: Add test for finding all Java files in a directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            writer.println(\"\\n\u003d\u003d\u003d JAVA FILES IN DIRECTORY \u003d\u003d\u003d\");\r\n            writer.println(\"Found \" + javaFiles.size() + \" Java files:\");\r\n\r\n            for (File file : javaFiles) {\r\n                System.out.println(file.getName());\r\n                writer.println(file.getName());\r\n            }\r\n        }",
          "comments": []
        }
      ],
      "className": "JavaParserTest",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/test/java/io/joshuasalcedo/parsers/ParserTest.java",
      "methods": [
        {
          "accessModifier": "private",
          "isStatic": false,
          "returnType": "boolean",
          "methodName": "isCurrentDirGitRepo",
          "parameters": [],
          "body": "{\r\n        File gitDir \u003d new File(\".git\");\r\n        return gitDir.exists() \u0026\u0026 gitDir.isDirectory();\r\n    }",
          "javadoc": {
            "description": "Check if the current directory is a Git repository.\r\nThis is used to conditionally enable tests that require a Git repository.\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "true if the current directory is a Git repository"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the Git repository\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains the expected Git repository information\r\n        assertTrue(resultMap.containsKey(\"gitRepository\"), \"Result should contain gitRepository key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Git Repository Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Check if the current directory is a Git repository.\r\nThis is used to conditionally enable tests that require a Git repository.\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "true if the current directory is a Git repository"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseGit",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the Git repository\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains the expected Git repository information\r\n        assertTrue(resultMap.containsKey(\"gitRepository\"), \"Result should contain gitRepository key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Git Repository Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.git method with the current directory.\r\nThis test is only enabled if the current directory is a Git repository.",
            "tags": []
          },
          "comments": [
            "Get the current directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Result",
              "name": "map"
            }
          ],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.git method with the current directory.\r\nThis test is only enabled if the current directory is a Git repository.",
            "tags": []
          },
          "comments": [
            "Parse the Git repository",
            "Verify the result is not null"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "information",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "comments": [
            "Verify the map contains the expected Git repository information"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseGitNonExistentDirectory",
          "parameters": [],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.git method with a non-existent directory.",
            "tags": []
          },
          "comments": [
            "Parse a non-existent directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Result",
              "name": "map"
            }
          ],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.git method with a non-existent directory.",
            "tags": []
          },
          "comments": [
            "Parse a non-existent directory",
            "Verify the result is not null"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "message",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        // Create a temporary directory\r\n        File tempDir \u003d File.createTempFile(\"temp\", \"dir\");\r\n        tempDir.delete();\r\n        tempDir.mkdir();\r\n        tempDir.deleteOnExit();\r\n\r\n        // Parse the non-Git directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(tempDir.getAbsolutePath());\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Not a valid Git repository\"), \r\n                \"Error message should indicate not a valid Git repository\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-Git Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "comments": [
            "Verify the map contains an error message"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseGitNonGitDirectory",
          "parameters": [],
          "body": "{\r\n        // Create a temporary directory\r\n        File tempDir \u003d File.createTempFile(\"temp\", \"dir\");\r\n        tempDir.delete();\r\n        tempDir.mkdir();\r\n        tempDir.deleteOnExit();\r\n\r\n        // Parse the non-Git directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(tempDir.getAbsolutePath());\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Not a valid Git repository\"), \r\n                \"Error message should indicate not a valid Git repository\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-Git Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.git method with a directory that is not a Git repository.",
            "tags": []
          },
          "comments": [
            "Create a temporary directo"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Result",
              "name": "map"
            }
          ],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "comments": [
            "Parse the non-Git directory",
            "Verify the result is not null"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "message",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        // Create a temporary directory\r\n        File tempDir \u003d File.createTempFile(\"temp\", \"dir\");\r\n        tempDir.delete();\r\n        tempDir.mkdir();\r\n        tempDir.deleteOnExit();\r\n\r\n        // Parse the non-Git directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(tempDir.getAbsolutePath());\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Not a valid Git repository\"), \r\n                \"Error message should indicate not a valid Git repository\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-Git Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "comments": [
            "Verify the map contains an error message"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseAll",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the directory using all parsers\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.all(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains file statistics\r\n        assertTrue(resultMap.containsKey(\"fileStatistics\"), \"Result should contain fileStatistics key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"All Parsers Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.all method with the current directory.\r\nThis test parses the current directory using all available parsers.",
            "tags": []
          },
          "comments": [
            "Get the current directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Result",
              "name": "map"
            }
          ],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.all method with the current directory.\r\nThis test parses the current directory using all available parsers.",
            "tags": []
          },
          "comments": [
            "Parse the directory using all parsers",
            "Verify the result is not null"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "statistics",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the Java files in the directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.java(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains Java files information\r\n        assertTrue(resultMap.containsKey(\"javaFiles\"), \"Result should contain javaFiles key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Java Parser Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "comments": [
            "Verify the map contains file statistics"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseJava",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the Java files in the directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.java(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains Java files information\r\n        assertTrue(resultMap.containsKey(\"javaFiles\"), \"Result should contain javaFiles key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Java Parser Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.java method with the current directory.",
            "tags": []
          },
          "comments": [
            "Get the current directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Result",
              "name": "map"
            }
          ],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.java method with the current directory.",
            "tags": []
          },
          "comments": [
            "Parse the Java files in the directory",
            "Verify the result is not null"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "information",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the POM files in the directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.pom(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains POM files information\r\n        assertTrue(resultMap.containsKey(\"pomFiles\"), \"Result should contain pomFiles key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"POM Parser Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "comments": [
            "Verify the map contains Java files information"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParsePom",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the POM files in the directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.pom(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains POM files information\r\n        assertTrue(resultMap.containsKey(\"pomFiles\"), \"Result should contain pomFiles key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"POM Parser Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.pom method with the current directory.",
            "tags": []
          },
          "comments": [
            "Get the current directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Result",
              "name": "map"
            }
          ],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.pom method with the current directory.",
            "tags": []
          },
          "comments": [
            "Parse the POM files in the directory",
            "Verify the result is not null"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "information",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the HTML files in the directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.html(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains HTML files information\r\n        assertTrue(resultMap.containsKey(\"htmlFiles\"), \"Result should contain htmlFiles key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"HTML Parser Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "comments": [
            "Verify the map contains POM files information"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParseHtml",
          "parameters": [],
          "body": "{\r\n        // Get the current directory\r\n        String currentDir \u003d System.getProperty(\"user.dir\");\r\n\r\n        // Parse the HTML files in the directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.html(currentDir);\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains HTML files information\r\n        assertTrue(resultMap.containsKey(\"htmlFiles\"), \"Result should contain htmlFiles key\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"HTML Parser Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.html method with the current directory.",
            "tags": []
          },
          "comments": [
            "Get the current directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "null",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Result",
              "name": "map"
            }
          ],
          "body": "{\r\n        // Parse a non-existent directory\r\n        Map\u003cString, Object\u003e resultMap \u003d Parser.parse.git(\"non-existent-directory\");\r\n\r\n        // Verify the result is not null\r\n        assertNotNull(resultMap, \"Result map should not be null\");\r\n        assertFalse(resultMap.isEmpty(), \"Result map should not be empty\");\r\n\r\n        // Verify the map contains an error message\r\n        assertTrue(resultMap.containsKey(\"error\"), \"Result should contain error key\");\r\n        assertTrue(((String)resultMap.get(\"error\")).contains(\"Directory does not exist\"), \r\n                \"Error message should indicate directory does not exist\");\r\n\r\n        // Print the result for inspection\r\n        System.out.println(\"Non-existent Directory Result:\");\r\n        System.out.println(resultMap);\r\n    }",
          "javadoc": {
            "description": "Test the Parser.parse.html method with the current directory.",
            "tags": []
          },
          "comments": [
            "Parse the HTML files in the directory",
            "Verify the result is not null"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "information",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "",
          "comments": [
            "Verify the map contains HTML files information"
          ]
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/test/java/io/joshuasalcedo/parsers/PomParserTest.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "setUp",
          "parameters": [],
          "body": "{\r\n        // Set up the test POM file locations\r\n        singlePomFile \u003d new File(\"src/test/resources/test/pom/single-pom/sample-pom.xml\");\r\n        multiModulePomFile \u003d new File(\"src/test/resources/test/pom/multi-module-pom.xml\");\r\n\r\n        // Ensure the test files exist\r\n        assertTrue(singlePomFile.exists(), \"Single module test POM file does not exist at: \"\r\n                + singlePomFile.getAbsolutePath());\r\n        assertTrue(multiModulePomFile.exists(), \"Multi-module test POM file does not exist at: \"\r\n                + multiModulePomFile.getAbsolutePath());\r\n\r\n        // Set up output file\r\n        outputFile \u003d new File(\"target/pom-parser-output.txt\");\r\n        outputFile.getParentFile().mkdirs();\r\n    }",
          "comments": [
            "Set up the test POM file locations"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            if (!singlePomFile.exists()) {\r\n                System.out.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                writer.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Parse the single module POM file\r\n                Model model \u003d PomParser.parsePom(singlePomFile);\r\n\r\n                // Test basic parsing\r\n                assertNotNull(model, \"Model should not be null\");\r\n\r\n                // Print basic model information\r\n                System.out.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Group ID: \" + model.getGroupId());\r\n                System.out.println(\"Artifact ID: \" + model.getArtifactId());\r\n                System.out.println(\"Version: \" + model.getVersion());\r\n                System.out.println(\"Packaging: \" + model.getPackaging());\r\n                System.out.println(\"Name: \" + model.getName());\r\n                System.out.println(\"Description: \" + model.getDescription());\r\n\r\n                writer.println(\"Group ID: \" + model.getGroupId());\r\n                writer.println(\"Artifact ID: \" + model.getArtifactId());\r\n                writer.println(\"Version: \" + model.getVersion());\r\n                writer.println(\"Packaging: \" + model.getPackaging());\r\n                writer.println(\"Name: \" + model.getName());\r\n                writer.println(\"Description: \" + model.getDescription());\r\n\r\n                // Test for parent\r\n                Parent parent \u003d model.getParent();\r\n                if (parent !\u003d null) {\r\n                    System.out.println(\"\\nParent:\");\r\n                    System.out.println(\"Group ID: \" + parent.getGroupId());\r\n                    System.out.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    System.out.println(\"Version: \" + parent.getVersion());\r\n\r\n                    writer.println(\"\\nParent:\");\r\n                    writer.println(\"Group ID: \" + parent.getGroupId());\r\n                    writer.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    writer.println(\"Version: \" + parent.getVersion());\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"Error parsing POM: \" + e.getMessage());\r\n                writer.println(\"Error parsing POM: \" + e.getMessage());\r\n                fail(\"Failed to parse POM file: \" + e.getMessage());\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while writing to output file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": [
            "Set up the test POM file locations"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            if (!singlePomFile.exists()) {\r\n                System.out.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                writer.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Parse the single module POM file\r\n                Model model \u003d PomParser.parsePom(singlePomFile);\r\n\r\n                // Test basic parsing\r\n                assertNotNull(model, \"Model should not be null\");\r\n\r\n                // Print basic model information\r\n                System.out.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Group ID: \" + model.getGroupId());\r\n                System.out.println(\"Artifact ID: \" + model.getArtifactId());\r\n                System.out.println(\"Version: \" + model.getVersion());\r\n                System.out.println(\"Packaging: \" + model.getPackaging());\r\n                System.out.println(\"Name: \" + model.getName());\r\n                System.out.println(\"Description: \" + model.getDescription());\r\n\r\n                writer.println(\"Group ID: \" + model.getGroupId());\r\n                writer.println(\"Artifact ID: \" + model.getArtifactId());\r\n                writer.println(\"Version: \" + model.getVersion());\r\n                writer.println(\"Packaging: \" + model.getPackaging());\r\n                writer.println(\"Name: \" + model.getName());\r\n                writer.println(\"Description: \" + model.getDescription());\r\n\r\n                // Test for parent\r\n                Parent parent \u003d model.getParent();\r\n                if (parent !\u003d null) {\r\n                    System.out.println(\"\\nParent:\");\r\n                    System.out.println(\"Group ID: \" + parent.getGroupId());\r\n                    System.out.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    System.out.println(\"Version: \" + parent.getVersion());\r\n\r\n                    writer.println(\"\\nParent:\");\r\n                    writer.println(\"Group ID: \" + parent.getGroupId());\r\n                    writer.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    writer.println(\"Version: \" + parent.getVersion());\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"Error parsing POM: \" + e.getMessage());\r\n                writer.println(\"Error parsing POM: \" + e.getMessage());\r\n                fail(\"Failed to parse POM file: \" + e.getMessage());\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while writing to output file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": [
            "Set up the test POM file locations",
            "Ensure the test files e"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "exist",
          "methodName": "assertTrue",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            if (!singlePomFile.exists()) {\r\n                System.out.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                writer.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Parse the single module POM file\r\n                Model model \u003d PomParser.parsePom(singlePomFile);\r\n\r\n                // Test basic parsing\r\n                assertNotNull(model, \"Model should not be null\");\r\n\r\n                // Print basic model information\r\n                System.out.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Group ID: \" + model.getGroupId());\r\n                System.out.println(\"Artifact ID: \" + model.getArtifactId());\r\n                System.out.println(\"Version: \" + model.getVersion());\r\n                System.out.println(\"Packaging: \" + model.getPackaging());\r\n                System.out.println(\"Name: \" + model.getName());\r\n                System.out.println(\"Description: \" + model.getDescription());\r\n\r\n                writer.println(\"Group ID: \" + model.getGroupId());\r\n                writer.println(\"Artifact ID: \" + model.getArtifactId());\r\n                writer.println(\"Version: \" + model.getVersion());\r\n                writer.println(\"Packaging: \" + model.getPackaging());\r\n                writer.println(\"Name: \" + model.getName());\r\n                writer.println(\"Description: \" + model.getDescription());\r\n\r\n                // Test for parent\r\n                Parent parent \u003d model.getParent();\r\n                if (parent !\u003d null) {\r\n                    System.out.println(\"\\nParent:\");\r\n                    System.out.println(\"Group ID: \" + parent.getGroupId());\r\n                    System.out.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    System.out.println(\"Version: \" + parent.getVersion());\r\n\r\n                    writer.println(\"\\nParent:\");\r\n                    writer.println(\"Group ID: \" + parent.getGroupId());\r\n                    writer.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    writer.println(\"Version: \" + parent.getVersion());\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"Error parsing POM: \" + e.getMessage());\r\n                writer.println(\"Error parsing POM: \" + e.getMessage());\r\n                fail(\"Failed to parse POM file: \" + e.getMessage());\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while writing to output file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": [
            "Ensure the test files exist"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            if (!singlePomFile.exists()) {\r\n                System.out.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                writer.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Parse the single module POM file\r\n                Model model \u003d PomParser.parsePom(singlePomFile);\r\n\r\n                // Test basic parsing\r\n                assertNotNull(model, \"Model should not be null\");\r\n\r\n                // Print basic model information\r\n                System.out.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Group ID: \" + model.getGroupId());\r\n                System.out.println(\"Artifact ID: \" + model.getArtifactId());\r\n                System.out.println(\"Version: \" + model.getVersion());\r\n                System.out.println(\"Packaging: \" + model.getPackaging());\r\n                System.out.println(\"Name: \" + model.getName());\r\n                System.out.println(\"Description: \" + model.getDescription());\r\n\r\n                writer.println(\"Group ID: \" + model.getGroupId());\r\n                writer.println(\"Artifact ID: \" + model.getArtifactId());\r\n                writer.println(\"Version: \" + model.getVersion());\r\n                writer.println(\"Packaging: \" + model.getPackaging());\r\n                writer.println(\"Name: \" + model.getName());\r\n                writer.println(\"Description: \" + model.getDescription());\r\n\r\n                // Test for parent\r\n                Parent parent \u003d model.getParent();\r\n                if (parent !\u003d null) {\r\n                    System.out.println(\"\\nParent:\");\r\n                    System.out.println(\"Group ID: \" + parent.getGroupId());\r\n                    System.out.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    System.out.println(\"Version: \" + parent.getVersion());\r\n\r\n                    writer.println(\"\\nParent:\");\r\n                    writer.println(\"Group ID: \" + parent.getGroupId());\r\n                    writer.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    writer.println(\"Version: \" + parent.getVersion());\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"Error parsing POM: \" + e.getMessage());\r\n                writer.println(\"Error parsing POM: \" + e.getMessage());\r\n                fail(\"Failed to parse POM file: \" + e.getMessage());\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while writing to output file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": [
            "Set up output file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testParsePom",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile))) {\r\n            if (!singlePomFile.exists()) {\r\n                System.out.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                writer.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Parse the single module POM file\r\n                Model model \u003d PomParser.parsePom(singlePomFile);\r\n\r\n                // Test basic parsing\r\n                assertNotNull(model, \"Model should not be null\");\r\n\r\n                // Print basic model information\r\n                System.out.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Group ID: \" + model.getGroupId());\r\n                System.out.println(\"Artifact ID: \" + model.getArtifactId());\r\n                System.out.println(\"Version: \" + model.getVersion());\r\n                System.out.println(\"Packaging: \" + model.getPackaging());\r\n                System.out.println(\"Name: \" + model.getName());\r\n                System.out.println(\"Description: \" + model.getDescription());\r\n\r\n                writer.println(\"Group ID: \" + model.getGroupId());\r\n                writer.println(\"Artifact ID: \" + model.getArtifactId());\r\n                writer.println(\"Version: \" + model.getVersion());\r\n                writer.println(\"Packaging: \" + model.getPackaging());\r\n                writer.println(\"Name: \" + model.getName());\r\n                writer.println(\"Description: \" + model.getDescription());\r\n\r\n                // Test for parent\r\n                Parent parent \u003d model.getParent();\r\n                if (parent !\u003d null) {\r\n                    System.out.println(\"\\nParent:\");\r\n                    System.out.println(\"Group ID: \" + parent.getGroupId());\r\n                    System.out.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    System.out.println(\"Version: \" + parent.getVersion());\r\n\r\n                    writer.println(\"\\nParent:\");\r\n                    writer.println(\"Group ID: \" + parent.getGroupId());\r\n                    writer.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    writer.println(\"Version: \" + parent.getVersion());\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"Error parsing POM: \" + e.getMessage());\r\n                writer.println(\"Error parsing POM: \" + e.getMessage());\r\n                fail(\"Failed to parse POM file: \" + e.getMessage());\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while writing to output file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": [
            "Set up output file"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            if (!singlePomFile.exists()) {\r\n                System.out.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                writer.println(\"Skipping testParsePom: Single module POM file does not exist\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Parse the single module POM file\r\n                Model model \u003d PomParser.parsePom(singlePomFile);\r\n\r\n                // Test basic parsing\r\n                assertNotNull(model, \"Model should not be null\");\r\n\r\n                // Print basic model information\r\n                System.out.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n                writer.println(\"\u003d\u003d\u003d POM MODEL INFORMATION \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Group ID: \" + model.getGroupId());\r\n                System.out.println(\"Artifact ID: \" + model.getArtifactId());\r\n                System.out.println(\"Version: \" + model.getVersion());\r\n                System.out.println(\"Packaging: \" + model.getPackaging());\r\n                System.out.println(\"Name: \" + model.getName());\r\n                System.out.println(\"Description: \" + model.getDescription());\r\n\r\n                writer.println(\"Group ID: \" + model.getGroupId());\r\n                writer.println(\"Artifact ID: \" + model.getArtifactId());\r\n                writer.println(\"Version: \" + model.getVersion());\r\n                writer.println(\"Packaging: \" + model.getPackaging());\r\n                writer.println(\"Name: \" + model.getName());\r\n                writer.println(\"Description: \" + model.getDescription());\r\n\r\n                // Test for parent\r\n                Parent parent \u003d model.getParent();\r\n                if (parent !\u003d null) {\r\n                    System.out.println(\"\\nParent:\");\r\n                    System.out.println(\"Group ID: \" + parent.getGroupId());\r\n                    System.out.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    System.out.println(\"Version: \" + parent.getVersion());\r\n\r\n                    writer.println(\"\\nParent:\");\r\n                    writer.println(\"Group ID: \" + parent.getGroupId());\r\n                    writer.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    writer.println(\"Version: \" + parent.getVersion());\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"Error parsing POM: \" + e.getMessage());\r\n                writer.println(\"Error parsing POM: \" + e.getMessage());\r\n                fail(\"Failed to parse POM file: \" + e.getMessage());\r\n            }\r\n        }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "parsing",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Model",
              "name": "should"
            }
          ],
          "body": "{\r\n                    System.out.println(\"\\nParent:\");\r\n                    System.out.println(\"Group ID: \" + parent.getGroupId());\r\n                    System.out.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    System.out.println(\"Version: \" + parent.getVersion());\r\n\r\n                    writer.println(\"\\nParent:\");\r\n                    writer.println(\"Group ID: \" + parent.getGroupId());\r\n                    writer.println(\"Artifact ID: \" + parent.getArtifactId());\r\n                    writer.println(\"Version: \" + parent.getVersion());\r\n                }",
          "comments": [
            "Parse the single module POM file",
            "Test basic parsing",
            "Pr"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testExtractCoordinates",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            // Extract coordinates from the single module POM file\r\n            PomCoordinates coordinates \u003d PomParser.extractCoordinates(singlePomFile);\r\n\r\n            // Test coordinate extraction\r\n            assertNotNull(coordinates, \"Coordinates should not be null\");\r\n\r\n            // Print coordinates\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Group ID: \" + coordinates.getGroupId());\r\n            System.out.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            System.out.println(\"Version: \" + coordinates.getVersion());\r\n\r\n            writer.println(\"Group ID: \" + coordinates.getGroupId());\r\n            writer.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            writer.println(\"Version: \" + coordinates.getVersion());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            // Extract coordinates from the single module POM file\r\n            PomCoordinates coordinates \u003d PomParser.extractCoordinates(singlePomFile);\r\n\r\n            // Test coordinate extraction\r\n            assertNotNull(coordinates, \"Coordinates should not be null\");\r\n\r\n            // Print coordinates\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Group ID: \" + coordinates.getGroupId());\r\n            System.out.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            System.out.println(\"Version: \" + coordinates.getVersion());\r\n\r\n            writer.println(\"Group ID: \" + coordinates.getGroupId());\r\n            writer.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            writer.println(\"Version: \" + coordinates.getVersion());\r\n        }",
          "comments": [
            "Extract coordinates from the s"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "extraction",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Coordinates",
              "name": "should"
            }
          ],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            // Extract dependencies from the single module POM file\r\n            List\u003cDependency\u003e dependencies \u003d PomParser.extractDependencies(singlePomFile);\r\n\r\n            // Test dependency extraction\r\n            assertNotNull(dependencies, \"Dependencies list should not be null\");\r\n\r\n            // Print dependencies\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM DEPENDENCIES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM DEPENDENCIES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Found \" + dependencies.size() + \" dependencies:\");\r\n            writer.println(\"Found \" + dependencies.size() + \" dependencies:\");\r\n\r\n            for (Dependency dependency : dependencies) {\r\n                String scope \u003d dependency.getScope() !\u003d null ? dependency.getScope() : \"compile\";\r\n\r\n                System.out.println(dependency.getGroupId() + \":\" +\r\n                        dependency.getArtifactId() + \":\" +\r\n                        dependency.getVersion() + \" (Scope: \" + scope + \")\");\r\n\r\n                writer.println(dependency.getGroupId() + \":\" +\r\n                        dependency.getArtifactId() + \":\" +\r\n                        dependency.getVersion() + \" (Scope: \" + scope + \")\");\r\n            }\r\n        }\r\n    }",
          "comments": [
            "Extract coordinates from the single module POM file",
            "Test coordinate extraction"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testExtractDependencies",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            // Extract dependencies from the single module POM file\r\n            List\u003cDependency\u003e dependencies \u003d PomParser.extractDependencies(singlePomFile);\r\n\r\n            // Test dependency extraction\r\n            assertNotNull(dependencies, \"Dependencies list should not be null\");\r\n\r\n            // Print dependencies\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM DEPENDENCIES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM DEPENDENCIES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Found \" + dependencies.size() + \" dependencies:\");\r\n            writer.println(\"Found \" + dependencies.size() + \" dependencies:\");\r\n\r\n            for (Dependency dependency : dependencies) {\r\n                String scope \u003d dependency.getScope() !\u003d null ? dependency.getScope() : \"compile\";\r\n\r\n                System.out.println(dependency.getGroupId() + \":\" +\r\n                        dependency.getArtifactId() + \":\" +\r\n                        dependency.getVersion() + \" (Scope: \" + scope + \")\");\r\n\r\n                writer.println(dependency.getGroupId() + \":\" +\r\n                        dependency.getArtifactId() + \":\" +\r\n                        dependency.getVersion() + \" (Scope: \" + scope + \")\");\r\n            }\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            // Extract coordinates from the single module POM file\r\n            PomCoordinates coordinates \u003d PomParser.extractCoordinates(singlePomFile);\r\n\r\n            // Test coordinate extraction\r\n            assertNotNull(coordinates, \"Coordinates should not be null\");\r\n\r\n            // Print coordinates\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Group ID: \" + coordinates.getGroupId());\r\n            System.out.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            System.out.println(\"Version: \" + coordinates.getVersion());\r\n\r\n            writer.println(\"Group ID: \" + coordinates.getGroupId());\r\n            writer.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            writer.println(\"Version: \" + coordinates.getVersion());\r\n        }",
          "comments": [
            "Extract dependencies from the"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "extraction",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Dependencies",
              "name": "list"
            }
          ],
          "body": "{\r\n                String scope \u003d dependency.getScope() !\u003d null ? dependency.getScope() : \"compile\";\r\n\r\n                System.out.println(dependency.getGroupId() + \":\" +\r\n                        dependency.getArtifactId() + \":\" +\r\n                        dependency.getVersion() + \" (Scope: \" + scope + \")\");\r\n\r\n                writer.println(dependency.getGroupId() + \":\" +\r\n                        dependency.getArtifactId() + \":\" +\r\n                        dependency.getVersion() + \" (Scope: \" + scope + \")\");\r\n            }",
          "comments": [
            "Extract dependencies from the single module POM file",
            "Test dependency extraction"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testExtractParentInfo",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            // Extract parent information from the single module POM file\r\n            Parent parent \u003d PomParser.extractParentInfo(singlePomFile);\r\n\r\n            // Print parent information\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM PARENT INFO \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM PARENT INFO \u003d\u003d\u003d\");\r\n\r\n            if (parent !\u003d null) {\r\n                System.out.println(\"Parent Group ID: \" + parent.getGroupId());\r\n                System.out.println(\"Parent Artifact ID: \" + parent.getArtifactId());\r\n                System.out.println(\"Parent Version: \" + parent.getVersion());\r\n                System.out.println(\"Relative Path: \" + parent.getRelativePath());\r\n\r\n                writer.println(\"Parent Group ID: \" + parent.getGroupId());\r\n                writer.println(\"Parent Artifact ID: \" + parent.getArtifactId());\r\n                writer.println(\"Parent Version: \" + parent.getVersion());\r\n                writer.println(\"Relative Path: \" + parent.getRelativePath());\r\n            } else {\r\n                System.out.println(\"No parent information found\");\r\n                writer.println(\"No parent information found\");\r\n            }\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            // Extract coordinates from the single module POM file\r\n            PomCoordinates coordinates \u003d PomParser.extractCoordinates(singlePomFile);\r\n\r\n            // Test coordinate extraction\r\n            assertNotNull(coordinates, \"Coordinates should not be null\");\r\n\r\n            // Print coordinates\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Group ID: \" + coordinates.getGroupId());\r\n            System.out.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            System.out.println(\"Version: \" + coordinates.getVersion());\r\n\r\n            writer.println(\"Group ID: \" + coordinates.getGroupId());\r\n            writer.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            writer.println(\"Version: \" + coordinates.getVersion());\r\n        }",
          "comments": [
            "Extract parent information fro"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testExtractPlugins",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            // Extract plugins from the single module POM file\r\n            List\u003cPlugin\u003e plugins \u003d PomParser.extractPlugins(singlePomFile);\r\n\r\n            // Test plugin extraction\r\n            assertNotNull(plugins, \"Plugins list should not be null\");\r\n\r\n            // Print plugins\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM PLUGINS \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM PLUGINS \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Found \" + plugins.size() + \" plugins:\");\r\n            writer.println(\"Found \" + plugins.size() + \" plugins:\");\r\n\r\n            for (Plugin plugin : plugins) {\r\n                System.out.println(plugin.getGroupId() + \":\" +\r\n                        plugin.getArtifactId() + \":\" +\r\n                        plugin.getVersion());\r\n\r\n                writer.println(plugin.getGroupId() + \":\" +\r\n                        plugin.getArtifactId() + \":\" +\r\n                        plugin.getVersion());\r\n\r\n                // Print configuration if available\r\n                if (plugin.getConfiguration() !\u003d null) {\r\n                    System.out.println(\"  Configuration: \" + plugin.getConfiguration());\r\n                    writer.println(\"  Configuration: \" + plugin.getConfiguration());\r\n                }\r\n            }\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            // Extract coordinates from the single module POM file\r\n            PomCoordinates coordinates \u003d PomParser.extractCoordinates(singlePomFile);\r\n\r\n            // Test coordinate extraction\r\n            assertNotNull(coordinates, \"Coordinates should not be null\");\r\n\r\n            // Print coordinates\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Group ID: \" + coordinates.getGroupId());\r\n            System.out.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            System.out.println(\"Version: \" + coordinates.getVersion());\r\n\r\n            writer.println(\"Group ID: \" + coordinates.getGroupId());\r\n            writer.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            writer.println(\"Version: \" + coordinates.getVersion());\r\n        }",
          "comments": [
            "Extract plugins from the singl"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "extraction",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Plugins",
              "name": "list"
            }
          ],
          "body": "{\r\n                System.out.println(plugin.getGroupId() + \":\" +\r\n                        plugin.getArtifactId() + \":\" +\r\n                        plugin.getVersion());\r\n\r\n                writer.println(plugin.getGroupId() + \":\" +\r\n                        plugin.getArtifactId() + \":\" +\r\n                        plugin.getVersion());\r\n\r\n                // Print configuration if available\r\n                if (plugin.getConfiguration() !\u003d null) {\r\n                    System.out.println(\"  Configuration: \" + plugin.getConfiguration());\r\n                    writer.println(\"  Configuration: \" + plugin.getConfiguration());\r\n                }\r\n            }",
          "comments": [
            "Extract plugins from the single module POM file",
            "Test plugin extraction"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "available",
          "methodName": "if",
          "parameters": [],
          "body": "{\r\n                    System.out.println(\"  Configuration: \" + plugin.getConfiguration());\r\n                    writer.println(\"  Configuration: \" + plugin.getConfiguration());\r\n                }",
          "comments": [
            "Print configuration if available"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testExtractModules",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            try {\r\n                // Extract modules from the multi-module POM file\r\n                List\u003cString\u003e modules \u003d PomParser.extractModules(multiModulePomFile);\r\n\r\n                // Test module extraction\r\n                assertNotNull(modules, \"Modules list should not be null\");\r\n\r\n                // Print modules\r\n                System.out.println(\"\\n\u003d\u003d\u003d POM MODULES \u003d\u003d\u003d\");\r\n                writer.println(\"\\n\u003d\u003d\u003d POM MODULES \u003d\u003d\u003d\");\r\n\r\n                System.out.println(\"Found \" + modules.size() + \" modules:\");\r\n                writer.println(\"Found \" + modules.size() + \" modules:\");\r\n\r\n                for (String module : modules) {\r\n                    System.out.println(\"- \" + module);\r\n                    writer.println(\"- \" + module);\r\n                }\r\n            } catch (IOException e) {\r\n                // Log the error but don\u0027t fail the test\r\n                System.out.println(\"\\n\u003d\u003d\u003d POM MODULES TEST ERROR \u003d\u003d\u003d\");\r\n                writer.println(\"\\n\u003d\u003d\u003d POM MODULES TEST ERROR \u003d\u003d\u003d\");\r\n                System.out.println(\"Error extracting modules: \" + e.getMessage());\r\n                writer.println(\"Error extracting modules: \" + e.getMessage());\r\n                System.out.println(\"This is expected if the multi-module POM file has XML format issues.\");\r\n                writer.println(\"This is expected if the multi-module POM file has XML format issues.\");\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while writing to output file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            // Extract coordinates from the single module POM file\r\n            PomCoordinates coordinates \u003d PomParser.extractCoordinates(singlePomFile);\r\n\r\n            // Test coordinate extraction\r\n            assertNotNull(coordinates, \"Coordinates should not be null\");\r\n\r\n            // Print coordinates\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Group ID: \" + coordinates.getGroupId());\r\n            System.out.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            System.out.println(\"Version: \" + coordinates.getVersion());\r\n\r\n            writer.println(\"Group ID: \" + coordinates.getGroupId());\r\n            writer.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            writer.println(\"Version: \" + coordinates.getVersion());\r\n        }",
          "comments": [
            "Extract"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "extraction",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"Modules",
              "name": "list"
            }
          ],
          "body": "{\r\n                    System.out.println(\"- \" + module);\r\n                    writer.println(\"- \" + module);\r\n                }",
          "comments": [
            "Extract modules from the multi-module POM file",
            "Test module extraction"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "void",
          "methodName": "testFindPomFiles",
          "parameters": [],
          "body": "{\r\n        try (PrintWriter writer \u003d new PrintWriter(new FileWriter(outputFile, true))) {\r\n            // Find POM files in the test resources directory\r\n            File testResourcesDir \u003d new File(\"src/test/resources\");\r\n            List\u003cFile\u003e pomFiles \u003d PomParser.findPomFiles(testResourcesDir);\r\n\r\n            // Test POM file finding\r\n            assertNotNull(pomFiles, \"POM files list should not be null\");\r\n            assertFalse(pomFiles.isEmpty(), \"POM files list should not be empty\");\r\n\r\n            // Print found POM files\r\n            System.out.println(\"\\n\u003d\u003d\u003d FOUND POM FILES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d FOUND POM FILES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Found \" + pomFiles.size() + \" POM files:\");\r\n            writer.println(\"Found \" + pomFiles.size() + \" POM files:\");\r\n\r\n            for (File pomFile : pomFiles) {\r\n                System.out.println(\"- \" + pomFile.getAbsolutePath());\r\n                writer.println(\"- \" + pomFile.getAbsolutePath());\r\n            }\r\n\r\n            System.out.println(\"\\nPOM parser test completed. Results written to: \" + outputFile.getAbsolutePath());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            fail(\"Exception occurred while writing to output file: \" + e.getMessage());\r\n        }\r\n    }",
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "PrintWriter",
          "parameters": [
            {
              "type": "new",
              "name": "FileWriter(outputFile"
            }
          ],
          "body": "{\r\n            // Extract coordinates from the single module POM file\r\n            PomCoordinates coordinates \u003d PomParser.extractCoordinates(singlePomFile);\r\n\r\n            // Test coordinate extraction\r\n            assertNotNull(coordinates, \"Coordinates should not be null\");\r\n\r\n            // Print coordinates\r\n            System.out.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n            writer.println(\"\\n\u003d\u003d\u003d POM COORDINATES \u003d\u003d\u003d\");\r\n\r\n            System.out.println(\"Group ID: \" + coordinates.getGroupId());\r\n            System.out.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            System.out.println(\"Version: \" + coordinates.getVersion());\r\n\r\n            writer.println(\"Group ID: \" + coordinates.getGroupId());\r\n            writer.println(\"Artifact ID: \" + coordinates.getArtifactId());\r\n            writer.println(\"Version: \" + coordinates.getVersion());\r\n        }",
          "comments": [
            "Find POM files in the test res"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "File",
          "parameters": [],
          "body": "{\r\n                System.out.println(\"- \" + pomFile.getAbsolutePath());\r\n                writer.println(\"- \" + pomFile.getAbsolutePath());\r\n            }",
          "comments": [
            "Find POM files in the test resources directory"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "finding",
          "methodName": "assertNotNull",
          "parameters": [
            {
              "type": "\"POM",
              "name": "files"
            }
          ],
          "body": "{\r\n                System.out.println(\"- \" + pomFile.getAbsolutePath());\r\n                writer.println(\"- \" + pomFile.getAbsolutePath());\r\n            }",
          "comments": [
            "Test POM file finding"
          ]
        }
      ],
      "className": "PomParserTest",
      "packageName": "io.joshuasalcedo.parsers"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/test/resources/test/java/TestSample.java",
      "methods": [
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "public",
          "methodName": "TestSample",
          "parameters": [],
          "body": "{\r\n        this.name \u003d \"default\";\r\n        this.count \u003d 0;\r\n    }",
          "javadoc": {
            "description": "Default constructor.",
            "tags": []
          },
          "comments": [
            "Class-level fields"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "public",
          "methodName": "TestSample",
          "parameters": [
            {
              "type": "String",
              "name": "name"
            },
            {
              "type": "int",
              "name": "count"
            }
          ],
          "body": "{\r\n        this.name \u003d name;\r\n        this.count \u003d count;\r\n    }",
          "javadoc": {
            "description": "Parameterized constructor.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "name The name to set"
              },
              {
                "name": "param",
                "value": "count The count to set"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "String",
          "methodName": "getName",
          "parameters": [],
          "body": "{\r\n        return this.name;\r\n    }",
          "javadoc": {
            "description": "Returns the name field.\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The name field"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "setName",
          "parameters": [
            {
              "type": "String",
              "name": "name"
            }
          ],
          "body": "{\r\n        this.name \u003d name;\r\n    }",
          "javadoc": {
            "description": "Sets the name field.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "name The new name value"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "int",
          "methodName": "getCount",
          "parameters": [],
          "body": "{\r\n        return this.count;\r\n    }",
          "javadoc": {
            "description": "Returns the count field.\r\n*",
            "tags": [
              {
                "name": "return",
                "value": "The count field"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "setCount",
          "parameters": [
            {
              "type": "int",
              "name": "count"
            }
          ],
          "body": "{\r\n        this.count \u003d count;\r\n    }",
          "javadoc": {
            "description": "Sets the count field.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "count The new count value"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "List\u003cString\u003e",
          "methodName": "processItems",
          "parameters": [
            {
              "type": "List\u003cString\u003e",
              "name": "items"
            },
            {
              "type": "String",
              "name": "filter"
            }
          ],
          "body": "{\r\n        if (items \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Items list cannot be null\");\r\n        }\r\n\r\n        List\u003cString\u003e result \u003d new ArrayList\u003c\u003e();\r\n\r\n        // Filter items based on the provided filter\r\n        for (String item : items) {\r\n            if (filter \u003d\u003d null || item.contains(filter)) {\r\n                result.add(item);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }",
          "javadoc": {
            "description": "Processes a list of strings and returns a filtered list.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "items The list of strings to process"
              },
              {
                "name": "param",
                "value": "filter The filter string to apply"
              },
              {
                "name": "return",
                "value": "A filtered list of strings"
              },
              {
                "name": "throws",
                "value": "IllegalArgumentException If items is null"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "new",
          "methodName": "IllegalArgumentException",
          "parameters": [
            {
              "type": "\"Items",
              "name": "list"
            }
          ],
          "body": "{\r\n            if (filter \u003d\u003d null || item.contains(filter)) {\r\n                result.add(item);\r\n            }\r\n        }",
          "javadoc": {
            "description": "Processes a list of strings and returns a filtered list.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "items The list of strings to process"
              },
              {
                "name": "param",
                "value": "filter The filter string to apply"
              },
              {
                "name": "return",
                "value": "A filtered list of strings"
              },
              {
                "name": "throws",
                "value": "IllegalArgumentException If items is null"
              }
            ]
          },
          "comments": []
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "filter",
          "methodName": "for",
          "parameters": [
            {
              "type": "String",
              "name": "item"
            }
          ],
          "body": "{\r\n            if (filter \u003d\u003d null || item.contains(filter)) {\r\n                result.add(item);\r\n            }\r\n        }",
          "comments": [
            "Filter items based on the provided filter"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "int",
          "methodName": "calculateSum",
          "parameters": [
            {
              "type": "int[]",
              "name": "numbers"
            }
          ],
          "body": "{\r\n        int sum \u003d 0;\r\n\r\n        // Simple summation\r\n        for (int num : numbers) {\r\n            sum +\u003d num;\r\n        }\r\n\r\n        return sum;\r\n    }",
          "javadoc": {
            "description": "Static utility method to calculate the sum of an array of integers.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "numbers The array of integers to sum"
              },
              {
                "name": "return",
                "value": "The sum of all numbers in the array"
              }
            ]
          },
          "comments": [
            "Simple summation"
          ]
        },
        {
          "accessModifier": "",
          "isStatic": false,
          "returnType": "summation",
          "methodName": "for",
          "parameters": [
            {
              "type": "int",
              "name": "num"
            }
          ],
          "body": "{\r\n            sum +\u003d num;\r\n        }",
          "javadoc": {
            "description": "Static utility method to calculate the sum of an array of integers.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "numbers The array of integers to sum"
              },
              {
                "name": "return",
                "value": "The sum of all numbers in the array"
              }
            ]
          },
          "comments": [
            "Simple summation"
          ]
        },
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "helperMethod",
          "parameters": [],
          "body": "{\r\n            // This is a helper method in an inner class\r\n            System.out.println(\"Helper method called\");\r\n        }",
          "javadoc": {
            "description": "Static utility method to calculate the sum of an array of integers.\r\n*",
            "tags": [
              {
                "name": "param",
                "value": "numbers The array of integers to sum"
              },
              {
                "name": "return",
                "value": "The sum of all numbers in the array"
              }
            ]
          },
          "comments": [
            "Inner class for demonstration purposes",
            "This is a helper method in an inner class"
          ]
        }
      ],
      "className": "for",
      "packageName": "io.joshuasalcedo.test"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/test/resources/repo/src/main/java/com/test/feature/FeatureClass.java",
      "methods": [],
      "className": "FeatureClass",
      "packageName": "com.test.feature"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/test/resources/repo/src/main/java/App.java",
      "methods": [],
      "className": "App",
      "packageName": "com.test"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/test/resources/repo/Utils.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "helper",
          "parameters": [],
          "body": "{ }",
          "comments": []
        }
      ],
      "className": "Utils",
      "packageName": "default"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/test/resources/repo/Feature.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": false,
          "returnType": "void",
          "methodName": "doSomething",
          "parameters": [],
          "body": "{ }",
          "comments": []
        }
      ],
      "className": "Feature",
      "packageName": "default"
    },
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/test/resources/repo/Main.java",
      "methods": [
        {
          "accessModifier": "public",
          "isStatic": true,
          "returnType": "void",
          "methodName": "main",
          "parameters": [
            {
              "type": "String[]",
              "name": "args"
            }
          ],
          "body": "{ System.out.println(\"Hello World\"); }",
          "comments": []
        }
      ],
      "className": "Main",
      "packageName": "default"
    }
  ],
  "htmlFiles": [
    {
      "path": "/home/joshuasalcedo-io/parser-utility/./src/test/resources/test/html/test.html",
      "images": 1,
      "metadata": {
        "keywords": "test, html, parser",
        "author": "Joshua Salcedo",
        "description": "Test HTML file for parser",
        "title": "Test HTML Document"
      },
      "headings": 5,
      "links": 2,
      "title": "Test HTML Document"
    }
  ]
}